<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Wrap</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- An example of how to use `Wrap` to help term inference.</a>
<a id="165" class="Comment">------------------------------------------------------------------------</a>

<a id="239" class="Symbol">{-#</a> <a id="243" class="Keyword">OPTIONS</a> <a id="251" class="Pragma">--cubical-compatible</a> <a id="272" class="Pragma">--safe</a> <a id="279" class="Symbol">#-}</a>

<a id="284" class="Keyword">module</a> <a id="291" href="README.Data.Wrap.html" class="Module">README.Data.Wrap</a> <a id="308" class="Keyword">where</a>

<a id="315" class="Keyword">open</a> <a id="320" class="Keyword">import</a> <a id="327" href="Data.Wrap.html" class="Module">Data.Wrap</a>

<a id="338" class="Keyword">open</a> <a id="343" class="Keyword">import</a> <a id="350" href="Algebra.html" class="Module">Algebra</a>
<a id="358" class="Keyword">open</a> <a id="363" class="Keyword">import</a> <a id="370" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="379" class="Keyword">open</a> <a id="384" class="Keyword">import</a> <a id="391" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="411" class="Keyword">open</a> <a id="416" class="Keyword">import</a> <a id="423" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="441" class="Keyword">using</a> <a id="447" class="Symbol">(</a><a id="448" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="451" class="Symbol">;</a> <a id="453" href="Data.Product.Base.html#852" class="Function">∃</a><a id="454" class="Symbol">;</a> <a id="456" href="Data.Product.Base.html#907" class="Function">∃₂</a><a id="458" class="Symbol">;</a> <a id="460" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="463" class="Symbol">)</a>
<a id="465" class="Keyword">open</a> <a id="470" class="Keyword">import</a> <a id="477" href="Level.html" class="Module">Level</a> <a id="483" class="Keyword">using</a> <a id="489" class="Symbol">(</a><a id="490" href="Agda.Primitive.html#742" class="Postulate">Level</a><a id="495" class="Symbol">)</a>

<a id="498" class="Keyword">private</a>
  <a id="508" class="Keyword">variable</a>
    <a id="521" href="README.Data.Wrap.html#521" class="Generalizable">c</a> <a id="523" href="README.Data.Wrap.html#523" class="Generalizable">ℓ</a> <a id="525" class="Symbol">:</a> <a id="527" href="Agda.Primitive.html#742" class="Postulate">Level</a>
    <a id="537" href="README.Data.Wrap.html#537" class="Generalizable">A</a> <a id="539" class="Symbol">:</a> <a id="541" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="545" href="README.Data.Wrap.html#521" class="Generalizable">c</a>
    <a id="551" href="README.Data.Wrap.html#551" class="Generalizable">m</a> <a id="553" href="README.Data.Wrap.html#553" class="Generalizable">n</a> <a id="555" class="Symbol">:</a> <a id="557" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>

<a id="560" class="Comment">------------------------------------------------------------------------</a>
<a id="633" class="Comment">-- `Wrap` for remembering instances</a>
<a id="669" class="Comment">------------------------------------------------------------------------</a>

<a id="743" class="Keyword">module</a> <a id="Instances"></a><a id="750" href="README.Data.Wrap.html#750" class="Module">Instances</a> <a id="760" class="Keyword">where</a>

  <a id="769" class="Comment">-- `Monoid.Carrier` gets the carrier set from a monoid, and thus has</a>
  <a id="840" class="Comment">-- type `Monoid c ℓ → Set c`.</a>
  <a id="872" class="Comment">-- Using `Wrap`, we can convert `Monoid.Carrier` into an equivalent</a>
  <a id="942" class="Comment">-- “wrapped” version: `MonoidEl`.</a>
  <a id="Instances.MonoidEl"></a><a id="978" href="README.Data.Wrap.html#978" class="Function">MonoidEl</a> <a id="987" class="Symbol">:</a> <a id="989" href="Algebra.Bundles.html#7315" class="Record">Monoid</a> <a id="996" href="README.Data.Wrap.html#521" class="Generalizable">c</a> <a id="998" href="README.Data.Wrap.html#523" class="Generalizable">ℓ</a> <a id="1000" class="Symbol">→</a> <a id="1002" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1006" href="README.Data.Wrap.html#521" class="Generalizable">c</a>
  <a id="1010" href="README.Data.Wrap.html#978" class="Function">MonoidEl</a> <a id="1019" class="Symbol">=</a> <a id="1021" href="Data.Wrap.html#743" class="Function">Wrap</a> <a id="1026" href="Algebra.Bundles.html#7394" class="Field">Monoid.Carrier</a>

  <a id="1044" class="Comment">-- We can turn any monoid into the equivalent monoid where the elements</a>
  <a id="1118" class="Comment">-- and equations have been wrapped.</a>
  <a id="1156" class="Comment">-- The translation mainly consists of wrapping and unwrapping everything</a>
  <a id="1231" class="Comment">-- via the `Wrap` constructor, `[_]`.</a>
  <a id="1271" class="Comment">-- Notice that the equality field is wrapping the binary relation</a>
  <a id="1339" class="Comment">-- `_≈_ : (x y : Carrier) → Set ℓ`, giving an example of how `Wrap` works</a>
  <a id="1415" class="Comment">-- for arbitrary n-ary relations.</a>
  <a id="Instances.Wrap-monoid"></a><a id="1451" href="README.Data.Wrap.html#1451" class="Function">Wrap-monoid</a> <a id="1463" class="Symbol">:</a> <a id="1465" href="Algebra.Bundles.html#7315" class="Record">Monoid</a> <a id="1472" href="README.Data.Wrap.html#521" class="Generalizable">c</a> <a id="1474" href="README.Data.Wrap.html#523" class="Generalizable">ℓ</a> <a id="1476" class="Symbol">→</a> <a id="1478" href="Algebra.Bundles.html#7315" class="Record">Monoid</a> <a id="1485" href="README.Data.Wrap.html#521" class="Generalizable">c</a> <a id="1487" href="README.Data.Wrap.html#523" class="Generalizable">ℓ</a>
  <a id="1491" href="README.Data.Wrap.html#1451" class="Function">Wrap-monoid</a> <a id="1503" href="README.Data.Wrap.html#1503" class="Bound">M</a> <a id="1505" class="Symbol">=</a> <a id="1507" class="Keyword">record</a>
    <a id="1518" class="Symbol">{</a> <a id="1520" href="Algebra.Bundles.html#7394" class="Field">Carrier</a> <a id="1528" class="Symbol">=</a> <a id="1530" href="README.Data.Wrap.html#978" class="Function">MonoidEl</a> <a id="1539" href="README.Data.Wrap.html#1503" class="Bound">M</a>
    <a id="1545" class="Symbol">;</a> <a id="1547" href="Algebra.Bundles.html#7415" class="Field Operator">_≈_</a> <a id="1551" class="Symbol">=</a> <a id="1553" class="Symbol">λ</a> <a id="1555" class="Symbol">(</a><a id="1556" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1558" href="README.Data.Wrap.html#1558" class="Bound">x</a> <a id="1560" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1561" class="Symbol">)</a> <a id="1563" class="Symbol">(</a><a id="1564" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1566" href="README.Data.Wrap.html#1566" class="Bound">y</a> <a id="1568" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1569" class="Symbol">)</a> <a id="1571" class="Symbol">→</a> <a id="1573" href="Data.Wrap.html#743" class="Function">Wrap</a> <a id="1578" href="Algebra.Bundles.html#7415" class="Field Operator">_≈_</a> <a id="1582" href="README.Data.Wrap.html#1558" class="Bound">x</a> <a id="1584" href="README.Data.Wrap.html#1566" class="Bound">y</a>
    <a id="1590" class="Symbol">;</a> <a id="1592" href="Algebra.Bundles.html#7444" class="Field Operator">_∙_</a> <a id="1596" class="Symbol">=</a> <a id="1598" class="Symbol">λ</a> <a id="1600" class="Symbol">(</a><a id="1601" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1603" href="README.Data.Wrap.html#1603" class="Bound">x</a> <a id="1605" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1606" class="Symbol">)</a> <a id="1608" class="Symbol">(</a><a id="1609" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1611" href="README.Data.Wrap.html#1611" class="Bound">y</a> <a id="1613" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1614" class="Symbol">)</a> <a id="1616" class="Symbol">→</a> <a id="1618" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1620" href="README.Data.Wrap.html#1603" class="Bound">x</a> <a id="1622" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="1624" href="README.Data.Wrap.html#1611" class="Bound">y</a> <a id="1626" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
    <a id="1632" class="Symbol">;</a> <a id="1634" href="Algebra.Bundles.html#7471" class="Field">ε</a> <a id="1636" class="Symbol">=</a> <a id="1638" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1640" href="Algebra.Bundles.html#7471" class="Field">ε</a> <a id="1642" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
    <a id="1648" class="Symbol">;</a> <a id="1650" href="Algebra.Bundles.html#7494" class="Field">isMonoid</a> <a id="1659" class="Symbol">=</a> <a id="1661" class="Keyword">record</a>
      <a id="1674" class="Symbol">{</a> <a id="1676" href="Algebra.Structures.html#4886" class="Field">isSemigroup</a> <a id="1688" class="Symbol">=</a> <a id="1690" class="Keyword">record</a>
        <a id="1705" class="Symbol">{</a> <a id="1707" href="Algebra.Structures.html#3436" class="Field">isMagma</a> <a id="1715" class="Symbol">=</a> <a id="1717" class="Keyword">record</a>
          <a id="1734" class="Symbol">{</a> <a id="1736" href="Algebra.Structures.html#1760" class="Field">isEquivalence</a> <a id="1750" class="Symbol">=</a> <a id="1752" class="Keyword">record</a>
            <a id="1771" class="Symbol">{</a> <a id="1773" href="Relation.Binary.Structures.html#1596" class="Field">refl</a> <a id="1778" class="Symbol">=</a> <a id="1780" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1782" href="Relation.Binary.Structures.html#1596" class="Function">refl</a> <a id="1787" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
            <a id="1801" class="Symbol">;</a> <a id="1803" href="Relation.Binary.Structures.html#1622" class="Field">sym</a> <a id="1807" class="Symbol">=</a> <a id="1809" class="Symbol">λ</a> <a id="1811" class="Symbol">(</a><a id="1812" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1814" href="README.Data.Wrap.html#1814" class="Bound">xy</a> <a id="1817" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1818" class="Symbol">)</a> <a id="1820" class="Symbol">→</a> <a id="1822" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1824" href="Relation.Binary.Structures.html#1622" class="Function">sym</a> <a id="1828" href="README.Data.Wrap.html#1814" class="Bound">xy</a> <a id="1831" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
            <a id="1845" class="Symbol">;</a> <a id="1847" href="Relation.Binary.Structures.html#1648" class="Field">trans</a> <a id="1853" class="Symbol">=</a> <a id="1855" class="Symbol">λ</a> <a id="1857" class="Symbol">(</a><a id="1858" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1860" href="README.Data.Wrap.html#1860" class="Bound">xy</a> <a id="1863" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1864" class="Symbol">)</a> <a id="1866" class="Symbol">(</a><a id="1867" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1869" href="README.Data.Wrap.html#1869" class="Bound">yz</a> <a id="1872" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1873" class="Symbol">)</a> <a id="1875" class="Symbol">→</a> <a id="1877" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1879" href="Relation.Binary.Structures.html#1648" class="Function">trans</a> <a id="1885" href="README.Data.Wrap.html#1860" class="Bound">xy</a> <a id="1888" href="README.Data.Wrap.html#1869" class="Bound">yz</a> <a id="1891" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
            <a id="1905" class="Symbol">}</a>
          <a id="1917" class="Symbol">;</a> <a id="1919" href="Algebra.Structures.html#1798" class="Field">∙-cong</a> <a id="1926" class="Symbol">=</a> <a id="1928" class="Symbol">λ</a> <a id="1930" class="Symbol">(</a><a id="1931" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1933" href="README.Data.Wrap.html#1933" class="Bound">xx</a> <a id="1936" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1937" class="Symbol">)</a> <a id="1939" class="Symbol">(</a><a id="1940" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1942" href="README.Data.Wrap.html#1942" class="Bound">yy</a> <a id="1945" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1946" class="Symbol">)</a> <a id="1948" class="Symbol">→</a> <a id="1950" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1952" href="Algebra.Structures.html#1798" class="Function">∙-cong</a> <a id="1959" href="README.Data.Wrap.html#1933" class="Bound">xx</a> <a id="1962" href="README.Data.Wrap.html#1942" class="Bound">yy</a> <a id="1965" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
          <a id="1977" class="Symbol">}</a>
        <a id="1987" class="Symbol">;</a> <a id="1989" href="Algebra.Structures.html#3460" class="Field">assoc</a> <a id="1995" class="Symbol">=</a> <a id="1997" class="Symbol">λ</a> <a id="1999" class="Symbol">(</a><a id="2000" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2002" href="README.Data.Wrap.html#2002" class="Bound">x</a> <a id="2004" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2005" class="Symbol">)</a> <a id="2007" class="Symbol">(</a><a id="2008" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2010" href="README.Data.Wrap.html#2010" class="Bound">y</a> <a id="2012" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2013" class="Symbol">)</a> <a id="2015" class="Symbol">(</a><a id="2016" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2018" href="README.Data.Wrap.html#2018" class="Bound">z</a> <a id="2020" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2021" class="Symbol">)</a> <a id="2023" class="Symbol">→</a> <a id="2025" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2027" href="Algebra.Structures.html#3460" class="Function">assoc</a> <a id="2033" href="README.Data.Wrap.html#2002" class="Bound">x</a> <a id="2035" href="README.Data.Wrap.html#2010" class="Bound">y</a> <a id="2037" href="README.Data.Wrap.html#2018" class="Bound">z</a> <a id="2039" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
        <a id="2049" class="Symbol">}</a>
      <a id="2057" class="Symbol">;</a> <a id="2059" href="Algebra.Structures.html#4918" class="Field">identity</a> <a id="2068" class="Symbol">=</a> <a id="2070" class="Symbol">(λ</a> <a id="2073" class="Symbol">(</a><a id="2074" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2076" href="README.Data.Wrap.html#2076" class="Bound">x</a> <a id="2078" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2079" class="Symbol">)</a> <a id="2081" class="Symbol">→</a> <a id="2083" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2085" href="Algebra.Structures.html#4987" class="Function">identityˡ</a> <a id="2095" href="README.Data.Wrap.html#2076" class="Bound">x</a> <a id="2097" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2098" class="Symbol">)</a>
                 <a id="2117" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2119" class="Symbol">(λ</a> <a id="2122" class="Symbol">(</a><a id="2123" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2125" href="README.Data.Wrap.html#2125" class="Bound">x</a> <a id="2127" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2128" class="Symbol">)</a> <a id="2130" class="Symbol">→</a> <a id="2132" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2134" href="Algebra.Structures.html#5048" class="Function">identityʳ</a> <a id="2144" href="README.Data.Wrap.html#2125" class="Bound">x</a> <a id="2146" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2147" class="Symbol">)</a>
      <a id="2155" class="Symbol">}</a>
    <a id="2161" class="Symbol">}</a>
    <a id="2167" class="Keyword">where</a> <a id="2173" class="Keyword">open</a> <a id="2178" href="Algebra.Bundles.html#7315" class="Module">Monoid</a> <a id="2185" href="README.Data.Wrap.html#1503" class="Bound">M</a>

  <a id="2190" class="Comment">-- Usually, we would only open one monoid at a time.</a>
  <a id="2245" class="Comment">-- If we were to open two monoids `M` and `N` simultaneously, Agda would</a>
  <a id="2320" class="Comment">-- get confused whenever it came across, for example, `_∙_`, not knowing</a>
  <a id="2395" class="Comment">-- whether it came from `M` or `N`.</a>
  <a id="2433" class="Comment">-- This is true whether or not `M` and `N` can be disambiguated by some</a>
  <a id="2507" class="Comment">-- other means (such as by their `Carrier`s).</a>

  <a id="2556" class="Comment">-- However, with wrapped monoids, we are going to remember the monoid</a>
  <a id="2628" class="Comment">-- while checking any monoid expressions, so we can afford to have just</a>
  <a id="2702" class="Comment">-- one, polymorphic, version of `_∙_` visible globally.</a>
  <a id="2760" class="Keyword">open</a> <a id="2765" class="Keyword">module</a> <a id="Instances.Wrap-monoid"></a><a id="2772" href="README.Data.Wrap.html#2772" class="Module">Wrap-monoid</a> <a id="2784" class="Symbol">{</a><a id="2785" href="README.Data.Wrap.html#2785" class="Bound">c</a> <a id="2787" href="README.Data.Wrap.html#2787" class="Bound">ℓ</a><a id="2788" class="Symbol">}</a> <a id="2790" class="Symbol">{</a><a id="2791" href="README.Data.Wrap.html#2791" class="Bound">M</a> <a id="2793" class="Symbol">:</a> <a id="2795" href="Algebra.Bundles.html#7315" class="Record">Monoid</a> <a id="2802" href="README.Data.Wrap.html#2785" class="Bound">c</a> <a id="2804" href="README.Data.Wrap.html#2787" class="Bound">ℓ</a><a id="2805" class="Symbol">}</a> <a id="2807" class="Symbol">=</a> <a id="2809" href="Algebra.Bundles.html#7315" class="Module">Monoid</a> <a id="2816" class="Symbol">(</a><a id="2817" href="README.Data.Wrap.html#1451" class="Function">Wrap-monoid</a> <a id="2829" href="README.Data.Wrap.html#2791" class="Bound">M</a><a id="2830" class="Symbol">)</a>

  <a id="2835" class="Comment">-- Now we can test out this construct on some existing monoids.</a>

  <a id="2902" class="Keyword">open</a> <a id="2907" class="Keyword">import</a> <a id="2914" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>

  <a id="2937" class="Comment">-- Notice that, while the following two definitions appear to be defined</a>
  <a id="3012" class="Comment">-- by the same expression, their types are genuinely different.</a>
  <a id="3078" class="Comment">-- Whereas `Carrier +-0-monoid = ℕ = Carrier *-1-monoid`, `MonoidEl M`</a>
  <a id="3151" class="Comment">-- does not compute, and thus</a>
  <a id="3183" class="Comment">-- `MonoidEl +-0-monoid ≠ MonoidEl *-1-monoid` definitionally.</a>
  <a id="3248" class="Comment">-- This lets us use the respective monoids when checking the respective</a>
  <a id="3322" class="Comment">-- definitions.</a>

  <a id="Instances.test-+"></a><a id="3341" href="README.Data.Wrap.html#3341" class="Function">test-+</a> <a id="3348" class="Symbol">:</a> <a id="3350" href="README.Data.Wrap.html#978" class="Function">MonoidEl</a> <a id="3359" href="Data.Nat.Properties.html#17252" class="Function">+-0-monoid</a>
  <a id="3372" href="README.Data.Wrap.html#3341" class="Function">test-+</a> <a id="3379" class="Symbol">=</a> <a id="3381" class="Symbol">(</a><a id="3382" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="3384" class="Number">3</a> <a id="3386" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a> <a id="3388" href="Algebra.Bundles.html#7444" class="Function Operator">∙</a> <a id="3390" href="Algebra.Bundles.html#7471" class="Function">ε</a><a id="3391" class="Symbol">)</a> <a id="3393" href="Algebra.Bundles.html#7444" class="Function Operator">∙</a> <a id="3395" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="3397" class="Number">2</a> <a id="3399" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>

  <a id="Instances.test-*"></a><a id="3404" href="README.Data.Wrap.html#3404" class="Function">test-*</a> <a id="3411" class="Symbol">:</a> <a id="3413" href="README.Data.Wrap.html#978" class="Function">MonoidEl</a> <a id="3422" href="Data.Nat.Properties.html#24759" class="Function">*-1-monoid</a>
  <a id="3435" href="README.Data.Wrap.html#3404" class="Function">test-*</a> <a id="3442" class="Symbol">=</a> <a id="3444" class="Symbol">(</a><a id="3445" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="3447" class="Number">3</a> <a id="3449" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a> <a id="3451" href="Algebra.Bundles.html#7444" class="Function Operator">∙</a> <a id="3453" href="Algebra.Bundles.html#7471" class="Function">ε</a><a id="3454" class="Symbol">)</a> <a id="3456" href="Algebra.Bundles.html#7444" class="Function Operator">∙</a> <a id="3458" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="3460" class="Number">2</a> <a id="3462" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>

  <a id="3467" class="Comment">-- The reader is invited to normalise these two definitions</a>
  <a id="3529" class="Comment">-- (`C-c C-n`, then type in the name).</a>
  <a id="3570" class="Comment">-- `test-+` is interpreted using (ℕ, +, 0), and thus computes to `[ 5 ]`.</a>
  <a id="3646" class="Comment">-- Meanwhile, `test-*` is interpreted using (ℕ, *, 1), and thus computes</a>
  <a id="3721" class="Comment">-- to `[ 6 ]`.</a>

<a id="3737" class="Comment">------------------------------------------------------------------------</a>
<a id="3810" class="Comment">-- `Wrap` for dealing with functions spoiling unification</a>
<a id="3868" class="Comment">------------------------------------------------------------------------</a>

<a id="3942" class="Keyword">module</a> <a id="Unification"></a><a id="3949" href="README.Data.Wrap.html#3949" class="Module">Unification</a> <a id="3961" class="Keyword">where</a>

  <a id="3970" class="Keyword">open</a> <a id="3975" class="Keyword">import</a> <a id="3982" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

  <a id="4023" class="Keyword">module</a> <a id="Unification.Naïve"></a><a id="4030" href="README.Data.Wrap.html#4030" class="Module">Naïve</a> <a id="4036" class="Keyword">where</a>

    <a id="4047" class="Comment">-- We want to work with factorisations of natural numbers in a</a>
    <a id="4114" class="Comment">-- “proof-relevant” style. We could draw out `Factor m n o` as</a>
    <a id="4181" class="Comment">--   m</a>
    <a id="4192" class="Comment">--  /*\</a>
    <a id="4204" class="Comment">-- n   o.</a>

    <a id="Unification.Naïve.Factor"></a><a id="4219" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="4226" class="Symbol">:</a> <a id="4228" class="Symbol">(</a><a id="4229" href="README.Data.Wrap.html#4229" class="Bound">m</a> <a id="4231" href="README.Data.Wrap.html#4231" class="Bound">n</a> <a id="4233" href="README.Data.Wrap.html#4233" class="Bound">o</a> <a id="4235" class="Symbol">:</a> <a id="4237" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="4238" class="Symbol">)</a> <a id="4240" class="Symbol">→</a> <a id="4242" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="4250" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="4257" href="README.Data.Wrap.html#4257" class="Bound">m</a> <a id="4259" href="README.Data.Wrap.html#4259" class="Bound">n</a> <a id="4261" href="README.Data.Wrap.html#4261" class="Bound">o</a> <a id="4263" class="Symbol">=</a> <a id="4265" href="README.Data.Wrap.html#4257" class="Bound">m</a> <a id="4267" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4269" href="README.Data.Wrap.html#4259" class="Bound">n</a> <a id="4271" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="4273" href="README.Data.Wrap.html#4261" class="Bound">o</a>

    <a id="4280" class="Comment">-- We can prove a basic lemma about `Factor`: the following tree rotation</a>
    <a id="4358" class="Comment">-- can be done, due to associativity of `_*_`.</a>
    <a id="4409" class="Comment">--      m             m</a>
    <a id="4437" class="Comment">--     /*\           /*\</a>
    <a id="4466" class="Comment">--   no   p  ----&gt;  n   op</a>
    <a id="4497" class="Comment">--  /*\                 /*\</a>
    <a id="4529" class="Comment">-- n   o               o   p</a>

    <a id="Unification.Naïve.assoc-→"></a><a id="4563" href="README.Data.Wrap.html#4563" class="Function">assoc-→</a> <a id="4571" class="Symbol">:</a> <a id="4573" class="Symbol">∀</a> <a id="4575" class="Symbol">{</a><a id="4576" href="README.Data.Wrap.html#4576" class="Bound">m</a> <a id="4578" href="README.Data.Wrap.html#4578" class="Bound">n</a> <a id="4580" href="README.Data.Wrap.html#4580" class="Bound">o</a> <a id="4582" href="README.Data.Wrap.html#4582" class="Bound">p</a><a id="4583" class="Symbol">}</a> <a id="4585" class="Symbol">→</a>
              <a id="4601" class="Symbol">(</a><a id="4602" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="4604" class="Symbol">λ</a> <a id="4606" href="README.Data.Wrap.html#4606" class="Bound">no</a> <a id="4609" class="Symbol">→</a> <a id="4611" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="4618" href="README.Data.Wrap.html#4576" class="Bound">m</a> <a id="4620" href="README.Data.Wrap.html#4606" class="Bound">no</a> <a id="4623" href="README.Data.Wrap.html#4582" class="Bound">p</a> <a id="4625" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="4627" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="4634" href="README.Data.Wrap.html#4606" class="Bound">no</a> <a id="4637" href="README.Data.Wrap.html#4578" class="Bound">n</a> <a id="4639" href="README.Data.Wrap.html#4580" class="Bound">o</a><a id="4640" class="Symbol">)</a> <a id="4642" class="Symbol">→</a>
              <a id="4658" class="Symbol">(</a><a id="4659" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="4661" class="Symbol">λ</a> <a id="4663" href="README.Data.Wrap.html#4663" class="Bound">op</a> <a id="4666" class="Symbol">→</a> <a id="4668" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="4675" href="README.Data.Wrap.html#4576" class="Bound">m</a> <a id="4677" href="README.Data.Wrap.html#4578" class="Bound">n</a> <a id="4679" href="README.Data.Wrap.html#4663" class="Bound">op</a> <a id="4682" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="4684" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="4691" href="README.Data.Wrap.html#4663" class="Bound">op</a> <a id="4694" href="README.Data.Wrap.html#4580" class="Bound">o</a> <a id="4696" href="README.Data.Wrap.html#4582" class="Bound">p</a><a id="4697" class="Symbol">)</a>
    <a id="4703" href="README.Data.Wrap.html#4563" class="Function">assoc-→</a> <a id="4711" class="Symbol">{</a><a id="4712" href="README.Data.Wrap.html#4712" class="Bound">m</a><a id="4713" class="Symbol">}</a> <a id="4715" class="Symbol">{</a><a id="4716" href="README.Data.Wrap.html#4716" class="Bound">n</a><a id="4717" class="Symbol">}</a> <a id="4719" class="Symbol">{</a><a id="4720" href="README.Data.Wrap.html#4720" class="Bound">o</a><a id="4721" class="Symbol">}</a> <a id="4723" class="Symbol">{</a><a id="4724" href="README.Data.Wrap.html#4724" class="Bound">p</a><a id="4725" class="Symbol">}</a> <a id="4727" class="Symbol">(</a><a id="4728" class="DottedPattern Symbol">._</a> <a id="4731" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4733" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="4738" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4740" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="4744" class="Symbol">)</a> <a id="4746" class="Symbol">=</a> <a id="4748" class="Symbol">_</a> <a id="4750" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4752" href="Data.Nat.Properties.html#22870" class="Function">*-assoc</a> <a id="4760" href="README.Data.Wrap.html#4716" class="Bound">n</a> <a id="4762" href="README.Data.Wrap.html#4720" class="Bound">o</a> <a id="4764" href="README.Data.Wrap.html#4724" class="Bound">p</a> <a id="4766" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4768" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

    <a id="4778" class="Comment">-- We must give at least some arguments to `*-assoc`, as Agda is unable to</a>
    <a id="4857" class="Comment">-- unify `? * ? * ?` with `n * o * p`, as `_*_` is a function and not</a>
    <a id="4931" class="Comment">-- necessarily injective (and indeed not injective when one of its</a>
    <a id="5002" class="Comment">-- arguments is 0).</a>

    <a id="5027" class="Comment">-- We now want to use this lemma in a more complex proof:</a>
    <a id="5089" class="Comment">--         m            m</a>
    <a id="5119" class="Comment">--        /*\          /*\</a>
    <a id="5150" class="Comment">--     nop   q        n   opq</a>
    <a id="5184" class="Comment">--     /*\      ----&gt;     /*\</a>
    <a id="5218" class="Comment">--   no   p              o   pq</a>
    <a id="5254" class="Comment">--  /*\                      /*\</a>
    <a id="5291" class="Comment">-- n   o                    p   q</a>

    <a id="Unification.Naïve.test"></a><a id="5330" href="README.Data.Wrap.html#5330" class="Function">test</a> <a id="5335" class="Symbol">:</a> <a id="5337" class="Symbol">∀</a> <a id="5339" class="Symbol">{</a><a id="5340" href="README.Data.Wrap.html#5340" class="Bound">m</a> <a id="5342" href="README.Data.Wrap.html#5342" class="Bound">n</a> <a id="5344" href="README.Data.Wrap.html#5344" class="Bound">o</a> <a id="5346" href="README.Data.Wrap.html#5346" class="Bound">p</a> <a id="5348" href="README.Data.Wrap.html#5348" class="Bound">q</a><a id="5349" class="Symbol">}</a> <a id="5351" class="Symbol">→</a>
           <a id="5364" class="Symbol">(</a><a id="5365" href="Data.Product.Base.html#907" class="Function">∃₂</a> <a id="5368" class="Symbol">λ</a> <a id="5370" href="README.Data.Wrap.html#5370" class="Bound">no</a> <a id="5373" href="README.Data.Wrap.html#5373" class="Bound">nop</a> <a id="5377" class="Symbol">→</a> <a id="5379" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="5386" href="README.Data.Wrap.html#5340" class="Bound">m</a> <a id="5388" href="README.Data.Wrap.html#5373" class="Bound">nop</a> <a id="5392" href="README.Data.Wrap.html#5348" class="Bound">q</a> <a id="5394" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5396" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="5403" href="README.Data.Wrap.html#5373" class="Bound">nop</a> <a id="5407" href="README.Data.Wrap.html#5370" class="Bound">no</a> <a id="5410" href="README.Data.Wrap.html#5346" class="Bound">p</a> <a id="5412" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5414" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="5421" href="README.Data.Wrap.html#5370" class="Bound">no</a> <a id="5424" href="README.Data.Wrap.html#5342" class="Bound">n</a> <a id="5426" href="README.Data.Wrap.html#5344" class="Bound">o</a><a id="5427" class="Symbol">)</a> <a id="5429" class="Symbol">→</a>
           <a id="5442" class="Symbol">(</a><a id="5443" href="Data.Product.Base.html#907" class="Function">∃₂</a> <a id="5446" class="Symbol">λ</a> <a id="5448" href="README.Data.Wrap.html#5448" class="Bound">pq</a> <a id="5451" href="README.Data.Wrap.html#5451" class="Bound">opq</a> <a id="5455" class="Symbol">→</a> <a id="5457" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="5464" href="README.Data.Wrap.html#5340" class="Bound">m</a> <a id="5466" href="README.Data.Wrap.html#5342" class="Bound">n</a> <a id="5468" href="README.Data.Wrap.html#5451" class="Bound">opq</a> <a id="5472" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5474" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="5481" href="README.Data.Wrap.html#5451" class="Bound">opq</a> <a id="5485" href="README.Data.Wrap.html#5344" class="Bound">o</a> <a id="5487" href="README.Data.Wrap.html#5448" class="Bound">pq</a> <a id="5490" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5492" href="README.Data.Wrap.html#4219" class="Function">Factor</a> <a id="5499" href="README.Data.Wrap.html#5448" class="Bound">pq</a> <a id="5502" href="README.Data.Wrap.html#5346" class="Bound">p</a> <a id="5504" href="README.Data.Wrap.html#5348" class="Bound">q</a><a id="5505" class="Symbol">)</a>
    <a id="5511" href="README.Data.Wrap.html#5330" class="Function">test</a> <a id="5516" class="Symbol">{</a><a id="5517" class="Argument">n</a> <a id="5519" class="Symbol">=</a> <a id="5521" href="README.Data.Wrap.html#5521" class="Bound">n</a><a id="5522" class="Symbol">}</a> <a id="5524" class="Symbol">(</a><a id="5525" href="README.Data.Wrap.html#5525" class="Bound">no</a> <a id="5528" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5530" href="README.Data.Wrap.html#5530" class="Bound">nop</a> <a id="5534" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5536" href="README.Data.Wrap.html#5536" class="Bound">fm</a> <a id="5539" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5541" href="README.Data.Wrap.html#5541" class="Bound">fnop</a> <a id="5546" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5548" href="README.Data.Wrap.html#5548" class="Bound">fno</a><a id="5551" class="Symbol">)</a> <a id="5553" class="Symbol">=</a>
      <a id="5561" class="Keyword">let</a> <a id="5565" class="Symbol">_</a> <a id="5567" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5569" href="README.Data.Wrap.html#5569" class="Bound">fm</a> <a id="5572" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5574" href="README.Data.Wrap.html#5574" class="Bound">fpq</a> <a id="5578" class="Symbol">=</a> <a id="5580" href="README.Data.Wrap.html#4563" class="Function">assoc-→</a> <a id="5588" class="Symbol">{</a><a id="5589" class="Argument">n</a> <a id="5591" class="Symbol">=</a> <a id="5593" href="README.Data.Wrap.html#5525" class="Bound">no</a><a id="5595" class="Symbol">}</a> <a id="5597" class="Symbol">(_</a> <a id="5600" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5602" href="README.Data.Wrap.html#5536" class="Bound">fm</a> <a id="5605" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5607" href="README.Data.Wrap.html#5541" class="Bound">fnop</a><a id="5611" class="Symbol">)</a> <a id="5613" class="Keyword">in</a>
      <a id="5622" class="Keyword">let</a> <a id="5626" class="Symbol">_</a> <a id="5628" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5630" href="README.Data.Wrap.html#5630" class="Bound">fm</a> <a id="5633" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5635" href="README.Data.Wrap.html#5635" class="Bound">fopq</a> <a id="5640" class="Symbol">=</a> <a id="5642" href="README.Data.Wrap.html#4563" class="Function">assoc-→</a> <a id="5650" class="Symbol">{</a><a id="5651" class="Argument">n</a> <a id="5653" class="Symbol">=</a> <a id="5655" href="README.Data.Wrap.html#5521" class="Bound">n</a><a id="5656" class="Symbol">}</a> <a id="5658" class="Symbol">(_</a> <a id="5661" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5663" href="README.Data.Wrap.html#5569" class="Bound">fm</a> <a id="5666" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5668" href="README.Data.Wrap.html#5548" class="Bound">fno</a><a id="5671" class="Symbol">)</a> <a id="5673" class="Keyword">in</a>
      <a id="5682" class="Symbol">_</a> <a id="5684" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5686" class="Symbol">_</a> <a id="5688" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5690" href="README.Data.Wrap.html#5630" class="Bound">fm</a> <a id="5693" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5695" href="README.Data.Wrap.html#5635" class="Bound">fopq</a> <a id="5700" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5702" href="README.Data.Wrap.html#5574" class="Bound">fpq</a>

    <a id="5711" class="Comment">-- This works okay, but where we have written `{n = no}` and similar, we</a>
    <a id="5788" class="Comment">-- are being forced to deal with details we don&#39;t really care about. Agda</a>
    <a id="5866" class="Comment">-- should be able to fill in the vertices given part of a tree, but can&#39;t</a>
    <a id="5944" class="Comment">-- due to similar reasons as before: `Factor ? ? ?` doesn&#39;t unify against</a>
    <a id="6022" class="Comment">-- `Factor m no p`, because both instances of `Factor` compute and we&#39;re</a>
    <a id="6099" class="Comment">-- left trying to unify `? * ?` against `no * p`.</a>

  <a id="6152" class="Keyword">module</a> <a id="Unification.Wrapped"></a><a id="6159" href="README.Data.Wrap.html#6159" class="Module">Wrapped</a> <a id="6167" class="Keyword">where</a>

    <a id="6178" class="Comment">-- We can use `Wrap` to stop the computation of `Factor`.</a>

    <a id="Unification.Wrapped.Factor"></a><a id="6241" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="6248" class="Symbol">:</a> <a id="6250" class="Symbol">(</a><a id="6251" href="README.Data.Wrap.html#6251" class="Bound">m</a> <a id="6253" href="README.Data.Wrap.html#6253" class="Bound">n</a> <a id="6255" href="README.Data.Wrap.html#6255" class="Bound">o</a> <a id="6257" class="Symbol">:</a> <a id="6259" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="6260" class="Symbol">)</a> <a id="6262" class="Symbol">→</a> <a id="6264" href="Agda.Primitive.html#388" class="Primitive">Set</a>
    <a id="6272" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="6279" class="Symbol">=</a> <a id="6281" href="Data.Wrap.html#743" class="Function">Wrap</a> <a id="6286" class="Symbol">λ</a> <a id="6288" href="README.Data.Wrap.html#6288" class="Bound">m</a> <a id="6290" href="README.Data.Wrap.html#6290" class="Bound">n</a> <a id="6292" href="README.Data.Wrap.html#6292" class="Bound">o</a> <a id="6294" class="Symbol">→</a> <a id="6296" href="README.Data.Wrap.html#6288" class="Bound">m</a> <a id="6298" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6300" href="README.Data.Wrap.html#6290" class="Bound">n</a> <a id="6302" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="6304" href="README.Data.Wrap.html#6292" class="Bound">o</a>

    <a id="6311" class="Comment">-- Because `assoc-→` needs access to the implementation of `Factor`, the</a>
    <a id="6388" class="Comment">-- proof is exactly as before except for using `[_]` to wrap and unwrap.</a>

    <a id="Unification.Wrapped.assoc-→"></a><a id="6466" href="README.Data.Wrap.html#6466" class="Function">assoc-→</a> <a id="6474" class="Symbol">:</a> <a id="6476" class="Symbol">∀</a> <a id="6478" class="Symbol">{</a><a id="6479" href="README.Data.Wrap.html#6479" class="Bound">m</a> <a id="6481" href="README.Data.Wrap.html#6481" class="Bound">n</a> <a id="6483" href="README.Data.Wrap.html#6483" class="Bound">o</a> <a id="6485" href="README.Data.Wrap.html#6485" class="Bound">p</a><a id="6486" class="Symbol">}</a> <a id="6488" class="Symbol">→</a>
              <a id="6504" class="Symbol">(</a><a id="6505" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="6507" class="Symbol">λ</a> <a id="6509" href="README.Data.Wrap.html#6509" class="Bound">no</a> <a id="6512" class="Symbol">→</a> <a id="6514" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="6521" href="README.Data.Wrap.html#6479" class="Bound">m</a> <a id="6523" href="README.Data.Wrap.html#6509" class="Bound">no</a> <a id="6526" href="README.Data.Wrap.html#6485" class="Bound">p</a> <a id="6528" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6530" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="6537" href="README.Data.Wrap.html#6509" class="Bound">no</a> <a id="6540" href="README.Data.Wrap.html#6481" class="Bound">n</a> <a id="6542" href="README.Data.Wrap.html#6483" class="Bound">o</a><a id="6543" class="Symbol">)</a> <a id="6545" class="Symbol">→</a>
              <a id="6561" class="Symbol">(</a><a id="6562" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="6564" class="Symbol">λ</a> <a id="6566" href="README.Data.Wrap.html#6566" class="Bound">op</a> <a id="6569" class="Symbol">→</a> <a id="6571" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="6578" href="README.Data.Wrap.html#6479" class="Bound">m</a> <a id="6580" href="README.Data.Wrap.html#6481" class="Bound">n</a> <a id="6582" href="README.Data.Wrap.html#6566" class="Bound">op</a> <a id="6585" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6587" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="6594" href="README.Data.Wrap.html#6566" class="Bound">op</a> <a id="6597" href="README.Data.Wrap.html#6483" class="Bound">o</a> <a id="6599" href="README.Data.Wrap.html#6485" class="Bound">p</a><a id="6600" class="Symbol">)</a>
    <a id="6606" href="README.Data.Wrap.html#6466" class="Function">assoc-→</a> <a id="6614" class="Symbol">{</a><a id="6615" href="README.Data.Wrap.html#6615" class="Bound">m</a><a id="6616" class="Symbol">}</a> <a id="6618" class="Symbol">{</a><a id="6619" href="README.Data.Wrap.html#6619" class="Bound">n</a><a id="6620" class="Symbol">}</a> <a id="6622" class="Symbol">{</a><a id="6623" href="README.Data.Wrap.html#6623" class="Bound">o</a><a id="6624" class="Symbol">}</a> <a id="6626" class="Symbol">{</a><a id="6627" href="README.Data.Wrap.html#6627" class="Bound">p</a><a id="6628" class="Symbol">}</a> <a id="6630" class="Symbol">(</a><a id="6631" class="DottedPattern Symbol">._</a> <a id="6634" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6636" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="6638" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6643" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a> <a id="6645" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6647" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="6649" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6654" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="6655" class="Symbol">)</a> <a id="6657" class="Symbol">=</a>
      <a id="6665" class="Symbol">_</a> <a id="6667" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6669" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="6671" href="Data.Nat.Properties.html#22870" class="Function">*-assoc</a> <a id="6679" href="README.Data.Wrap.html#6619" class="Bound">n</a> <a id="6681" href="README.Data.Wrap.html#6623" class="Bound">o</a> <a id="6683" href="README.Data.Wrap.html#6627" class="Bound">p</a> <a id="6685" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a> <a id="6687" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6689" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="6691" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="6696" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>

    <a id="6703" class="Comment">-- The difference is that now we have our basic lemma, the complex proof</a>
    <a id="6780" class="Comment">-- can work purely in terms of `Factor` trees. In particular,</a>
    <a id="6846" class="Comment">-- `Factor ? ? ?` now does unify with `Factor m no p`, so we don&#39;t have to</a>
    <a id="6925" class="Comment">-- give `no` explicitly again.</a>

    <a id="Unification.Wrapped.test"></a><a id="6961" href="README.Data.Wrap.html#6961" class="Function">test</a> <a id="6966" class="Symbol">:</a> <a id="6968" class="Symbol">∀</a> <a id="6970" class="Symbol">{</a><a id="6971" href="README.Data.Wrap.html#6971" class="Bound">m</a> <a id="6973" href="README.Data.Wrap.html#6973" class="Bound">n</a> <a id="6975" href="README.Data.Wrap.html#6975" class="Bound">o</a> <a id="6977" href="README.Data.Wrap.html#6977" class="Bound">p</a> <a id="6979" href="README.Data.Wrap.html#6979" class="Bound">q</a><a id="6980" class="Symbol">}</a> <a id="6982" class="Symbol">→</a>
           <a id="6995" class="Symbol">(</a><a id="6996" href="Data.Product.Base.html#907" class="Function">∃₂</a> <a id="6999" class="Symbol">λ</a> <a id="7001" href="README.Data.Wrap.html#7001" class="Bound">no</a> <a id="7004" href="README.Data.Wrap.html#7004" class="Bound">nop</a> <a id="7008" class="Symbol">→</a> <a id="7010" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="7017" href="README.Data.Wrap.html#6971" class="Bound">m</a> <a id="7019" href="README.Data.Wrap.html#7004" class="Bound">nop</a> <a id="7023" href="README.Data.Wrap.html#6979" class="Bound">q</a> <a id="7025" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7027" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="7034" href="README.Data.Wrap.html#7004" class="Bound">nop</a> <a id="7038" href="README.Data.Wrap.html#7001" class="Bound">no</a> <a id="7041" href="README.Data.Wrap.html#6977" class="Bound">p</a> <a id="7043" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7045" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="7052" href="README.Data.Wrap.html#7001" class="Bound">no</a> <a id="7055" href="README.Data.Wrap.html#6973" class="Bound">n</a> <a id="7057" href="README.Data.Wrap.html#6975" class="Bound">o</a><a id="7058" class="Symbol">)</a> <a id="7060" class="Symbol">→</a>
           <a id="7073" class="Symbol">(</a><a id="7074" href="Data.Product.Base.html#907" class="Function">∃₂</a> <a id="7077" class="Symbol">λ</a> <a id="7079" href="README.Data.Wrap.html#7079" class="Bound">pq</a> <a id="7082" href="README.Data.Wrap.html#7082" class="Bound">opq</a> <a id="7086" class="Symbol">→</a> <a id="7088" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="7095" href="README.Data.Wrap.html#6971" class="Bound">m</a> <a id="7097" href="README.Data.Wrap.html#6973" class="Bound">n</a> <a id="7099" href="README.Data.Wrap.html#7082" class="Bound">opq</a> <a id="7103" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7105" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="7112" href="README.Data.Wrap.html#7082" class="Bound">opq</a> <a id="7116" href="README.Data.Wrap.html#6975" class="Bound">o</a> <a id="7118" href="README.Data.Wrap.html#7079" class="Bound">pq</a> <a id="7121" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7123" href="README.Data.Wrap.html#6241" class="Function">Factor</a> <a id="7130" href="README.Data.Wrap.html#7079" class="Bound">pq</a> <a id="7133" href="README.Data.Wrap.html#6977" class="Bound">p</a> <a id="7135" href="README.Data.Wrap.html#6979" class="Bound">q</a><a id="7136" class="Symbol">)</a>
    <a id="7142" href="README.Data.Wrap.html#6961" class="Function">test</a> <a id="7147" class="Symbol">(_</a> <a id="7150" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7152" class="Symbol">_</a> <a id="7154" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7156" href="README.Data.Wrap.html#7156" class="Bound">fm</a> <a id="7159" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7161" href="README.Data.Wrap.html#7161" class="Bound">fnop</a> <a id="7166" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7168" href="README.Data.Wrap.html#7168" class="Bound">fno</a><a id="7171" class="Symbol">)</a> <a id="7173" class="Symbol">=</a>
      <a id="7181" class="Keyword">let</a> <a id="7185" class="Symbol">_</a> <a id="7187" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7189" href="README.Data.Wrap.html#7189" class="Bound">fm</a> <a id="7192" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7194" href="README.Data.Wrap.html#7194" class="Bound">fpq</a> <a id="7198" class="Symbol">=</a> <a id="7200" href="README.Data.Wrap.html#6466" class="Function">assoc-→</a> <a id="7208" class="Symbol">(_</a> <a id="7211" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7213" href="README.Data.Wrap.html#7156" class="Bound">fm</a> <a id="7216" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7218" href="README.Data.Wrap.html#7161" class="Bound">fnop</a><a id="7222" class="Symbol">)</a> <a id="7224" class="Keyword">in</a>
      <a id="7233" class="Keyword">let</a> <a id="7237" class="Symbol">_</a> <a id="7239" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7241" href="README.Data.Wrap.html#7241" class="Bound">fm</a> <a id="7244" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7246" href="README.Data.Wrap.html#7246" class="Bound">fopq</a> <a id="7251" class="Symbol">=</a> <a id="7253" href="README.Data.Wrap.html#6466" class="Function">assoc-→</a> <a id="7261" class="Symbol">(_</a> <a id="7264" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7266" href="README.Data.Wrap.html#7189" class="Bound">fm</a> <a id="7269" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7271" href="README.Data.Wrap.html#7168" class="Bound">fno</a><a id="7274" class="Symbol">)</a> <a id="7276" class="Keyword">in</a>
      <a id="7285" class="Symbol">_</a> <a id="7287" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7289" class="Symbol">_</a> <a id="7291" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7293" href="README.Data.Wrap.html#7241" class="Bound">fm</a> <a id="7296" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7298" href="README.Data.Wrap.html#7246" class="Bound">fopq</a> <a id="7303" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7305" href="README.Data.Wrap.html#7194" class="Bound">fpq</a>
</pre></body></html>