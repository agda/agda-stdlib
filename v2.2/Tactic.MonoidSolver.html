<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.MonoidSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Reflection-based solver for monoid equalities</a>
<a id="155" class="Comment">------------------------------------------------------------------------</a>
<a id="228" class="Comment">--</a>
<a id="231" class="Comment">-- This solver automates the construction of proofs of equivalences</a>
<a id="299" class="Comment">-- between monoid expressions.</a>
<a id="330" class="Comment">-- When called like so:</a>
<a id="354" class="Comment">--</a>
<a id="357" class="Comment">--   proof : ∀ x y z → (x ∙ y) ∙ z ≈ x ∙ (y ∙ z) ∙ ε</a>
<a id="410" class="Comment">--   proof x y z = solve mon</a>
<a id="439" class="Comment">--</a>
<a id="442" class="Comment">-- The following diagram describes what happens under the hood:</a>
<a id="506" class="Comment">--</a>
<a id="509" class="Comment">--            ┌▸x ∙ (y ∙ (z ∙ ε)) ════ x ∙ (y ∙ (z ∙ ε))◂┐</a>
<a id="568" class="Comment">--            │         ║                      ║         │</a>
<a id="627" class="Comment">--            │         ║                      ║         │</a>
<a id="686" class="Comment">--          [_⇓]        ║                      ║        [_⇓]</a>
<a id="747" class="Comment">--          ╱           ║                      ║          ╲</a>
<a id="807" class="Comment">--         ╱            ║                      ║           ╲</a>
<a id="868" class="Comment">-- (x ∙′ y) ∙′ z      homo                   homo    x ∙′ (y ∙′ z) ∙′ ε′</a>
<a id="941" class="Comment">--   ▴     ╲            ║                      ║           ╱       ▴</a>
<a id="1010" class="Comment">--   │      ╲           ║                      ║          ╱        │</a>
<a id="1079" class="Comment">--   │       [_↓]       ║                      ║        [_↓]       │</a>
<a id="1148" class="Comment">--   │        │         ║                      ║         │         │</a>
<a id="1217" class="Comment">--   │        │         ║                      ║         │         │</a>
<a id="1286" class="Comment">--   │        └───▸(x ∙ y) ∙ z          x ∙ (y ∙ z) ∙ ε◂─┘         │</a>
<a id="1355" class="Comment">--   │                  │                      │                   │</a>
<a id="1424" class="Comment">--   │                  │                      │                   │</a>
<a id="1493" class="Comment">--   └────reflection────┘                      └───reflection──────┘</a>
<a id="1562" class="Comment">--</a>
<a id="1565" class="Comment">-- The actual output—the proof constructed by the solver—is represented</a>
<a id="1637" class="Comment">-- by the double-lined path (══).</a>
<a id="1671" class="Comment">--</a>
<a id="1674" class="Comment">-- We start at the bottom, with our two expressions.</a>
<a id="1727" class="Comment">-- Through reflection, we convert these two expressions to their AST</a>
<a id="1796" class="Comment">-- representations, in the Expr type.</a>
<a id="1834" class="Comment">-- We then can evaluate the AST in two ways: one simply gives us back</a>
<a id="1904" class="Comment">-- the two expressions we put in ([_↓]), and the other normalises</a>
<a id="1970" class="Comment">-- ([_⇓]).</a>
<a id="1981" class="Comment">-- We use the homo function to prove equivalence between these two</a>
<a id="2048" class="Comment">-- forms: joining up these two proofs gives us the desired overall</a>
<a id="2115" class="Comment">-- proof.</a>

<a id="2126" class="Comment">-- Note: What&#39;s going on with the Monoid parameter?</a>
<a id="2178" class="Comment">--</a>
<a id="2181" class="Comment">-- This module is not parameterised over a monoid, which is contrary</a>
<a id="2250" class="Comment">-- to what you might expect. Instead, we take the monoid record as an</a>
<a id="2320" class="Comment">-- argument to the solve macro, and then pass it around as an</a>
<a id="2382" class="Comment">-- argument wherever we need it.</a>
<a id="2415" class="Comment">--</a>
<a id="2418" class="Comment">-- We need to get the monoid record at the call site, not the import</a>
<a id="2487" class="Comment">-- site, to ensure that it&#39;s consistent with the rest of the context.</a>
<a id="2557" class="Comment">-- For instance, if we wanted to produce `x ∙ y` using the monoid record</a>
<a id="2630" class="Comment">-- as imported, we would run into problems:</a>
<a id="2674" class="Comment">-- * If we tried to just reflect on the expression itself</a>
<a id="2732" class="Comment">--   (quoteTerm (x ∙ y)) we would likely get some de Bruijn indices</a>
<a id="2800" class="Comment">--   wrong (in x and y), and ∙ might not even be in scope where the</a>
<a id="2868" class="Comment">--   user wants us to solve! If they&#39;re solving an expression like</a>
<a id="2935" class="Comment">--   x + (y + z), they can pass in the +-0-monoid, but don&#39;t have to</a>
<a id="3004" class="Comment">--   open it themselves.</a>
<a id="3029" class="Comment">-- * If instead we tried to construct a term which accesses the _∙_</a>
<a id="3097" class="Comment">--   field on the reflection of the record, we&#39;d run into similar</a>
<a id="3163" class="Comment">--   problems again. While the record is a parameter for us, it might</a>
<a id="3233" class="Comment">--   not be for the user.</a>
<a id="3259" class="Comment">-- Basically, we need the Monoid we&#39;re looking at to be exactly the</a>
<a id="3327" class="Comment">-- same as the one the user is looking at, and in order to do that we</a>
<a id="3397" class="Comment">-- quote it at the call site.</a>

<a id="3428" class="Symbol">{-#</a> <a id="3432" class="Keyword">OPTIONS</a> <a id="3440" class="Pragma">--cubical-compatible</a> <a id="3461" class="Pragma">--safe</a> <a id="3468" class="Symbol">#-}</a>

<a id="3473" class="Keyword">module</a> <a id="3480" href="Tactic.MonoidSolver.html" class="Module">Tactic.MonoidSolver</a> <a id="3500" class="Keyword">where</a>

<a id="3507" class="Keyword">open</a> <a id="3512" class="Keyword">import</a> <a id="3519" href="Algebra.html" class="Module">Algebra</a>
<a id="3527" class="Keyword">open</a> <a id="3532" class="Keyword">import</a> <a id="3539" href="Function.Base.html" class="Module">Function.Base</a> <a id="3553" class="Keyword">using</a> <a id="3559" class="Symbol">(</a><a id="3560" href="Function.Base.html#4322" class="Function Operator">_⟨_⟩_</a><a id="3565" class="Symbol">)</a>

<a id="3568" class="Keyword">open</a> <a id="3573" class="Keyword">import</a> <a id="3580" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>    <a id="3598" class="Symbol">as</a> <a id="3601" class="Module">Bool</a>    <a id="3609" class="Keyword">using</a> <a id="3615" class="Symbol">(</a><a id="3616" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="3620" class="Symbol">;</a> <a id="3622" href="Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="3625" class="Symbol">;</a> <a id="3627" href="Data.Bool.Base.html#1505" class="Function Operator">if_then_else_</a><a id="3640" class="Symbol">)</a>
<a id="3642" class="Keyword">open</a> <a id="3647" class="Keyword">import</a> <a id="3654" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>   <a id="3672" class="Symbol">as</a> <a id="3675" class="Module">Maybe</a>   <a id="3683" class="Keyword">using</a> <a id="3689" class="Symbol">(</a><a id="3690" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a><a id="3695" class="Symbol">;</a> <a id="3697" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a><a id="3701" class="Symbol">;</a> <a id="3703" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="3710" class="Symbol">;</a> <a id="3712" href="Data.Maybe.Base.html#1276" class="Function">maybe</a><a id="3717" class="Symbol">)</a>
<a id="3719" class="Keyword">open</a> <a id="3724" class="Keyword">import</a> <a id="3731" href="Data.List.Base.html" class="Module">Data.List.Base</a>    <a id="3749" class="Symbol">as</a> <a id="3752" class="Module">List</a>    <a id="3760" class="Keyword">using</a> <a id="3766" class="Symbol">(</a><a id="3767" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="3771" class="Symbol">;</a> <a id="3773" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="3776" class="Symbol">;</a> <a id="3778" href="Data.List.Base.html#7599" class="InductiveConstructor">[]</a><a id="3780" class="Symbol">)</a>
<a id="3782" class="Keyword">open</a> <a id="3787" class="Keyword">import</a> <a id="3794" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>     <a id="3812" class="Symbol">as</a> <a id="3815" class="Module">ℕ</a>       <a id="3823" class="Keyword">using</a> <a id="3829" class="Symbol">(</a><a id="3830" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3831" class="Symbol">;</a> <a id="3833" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="3836" class="Symbol">;</a> <a id="3838" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="3842" class="Symbol">)</a>
<a id="3844" class="Keyword">open</a> <a id="3849" class="Keyword">import</a> <a id="3856" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="3874" class="Symbol">as</a> <a id="3877" class="Module">Product</a> <a id="3885" class="Keyword">using</a> <a id="3891" class="Symbol">(</a><a id="3892" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="3895" class="Symbol">;</a> <a id="3897" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="3900" class="Symbol">)</a>

<a id="3903" class="Keyword">open</a> <a id="3908" class="Keyword">import</a> <a id="3915" href="Reflection.AST.html" class="Module">Reflection.AST</a>
<a id="3930" class="Keyword">open</a> <a id="3935" class="Keyword">import</a> <a id="3942" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a>
<a id="3962" class="Keyword">open</a> <a id="3967" class="Keyword">import</a> <a id="3974" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="3998" class="Keyword">import</a> <a id="4005" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="4025" class="Symbol">as</a> <a id="4028" class="Module">Name</a>
<a id="4033" class="Keyword">open</a> <a id="4038" class="Keyword">import</a> <a id="4045" href="Reflection.TCM.html" class="Module">Reflection.TCM</a>
<a id="4060" class="Keyword">open</a> <a id="4065" class="Keyword">import</a> <a id="4072" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>

<a id="4095" class="Keyword">import</a> <a id="4102" href="Relation.Binary.Reasoning.Setoid.html" class="Module">Relation.Binary.Reasoning.Setoid</a> <a id="4135" class="Symbol">as</a> <a id="4138" class="Module">≈-Reasoning</a>

<a id="4151" class="Comment">------------------------------------------------------------------------</a>
<a id="4224" class="Comment">-- The Expr type with homomorphism proofs</a>
<a id="4266" class="Comment">------------------------------------------------------------------------</a>

<a id="4340" class="Keyword">infixl</a> <a id="4347" class="Number">7</a> <a id="4349" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">_∙′_</a>
<a id="4354" class="Keyword">data</a> <a id="Expr"></a><a id="4359" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4364" class="Symbol">{</a><a id="4365" href="Tactic.MonoidSolver.html#4365" class="Bound">a</a><a id="4366" class="Symbol">}</a> <a id="4368" class="Symbol">(</a><a id="4369" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a> <a id="4371" class="Symbol">:</a> <a id="4373" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="4377" href="Tactic.MonoidSolver.html#4365" class="Bound">a</a><a id="4378" class="Symbol">)</a> <a id="4380" class="Symbol">:</a> <a id="4382" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="4386" href="Tactic.MonoidSolver.html#4365" class="Bound">a</a> <a id="4388" class="Keyword">where</a>
  <a id="Expr._∙′_"></a><a id="4396" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">_∙′_</a>  <a id="4402" class="Symbol">:</a> <a id="4404" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4409" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a> <a id="4411" class="Symbol">→</a> <a id="4413" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4418" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a> <a id="4420" class="Symbol">→</a> <a id="4422" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4427" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a>
  <a id="Expr.ε′"></a><a id="4431" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a>    <a id="4437" class="Symbol">:</a> <a id="4439" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4444" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a>
  <a id="Expr.[_↑]"></a><a id="4448" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[_↑]</a>  <a id="4454" class="Symbol">:</a> <a id="4456" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a> <a id="4458" class="Symbol">→</a> <a id="4460" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4465" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a>

<a id="4468" class="Keyword">module</a> <a id="4475" href="Tactic.MonoidSolver.html#4475" class="Module">_</a> <a id="4477" class="Symbol">{</a><a id="4478" href="Tactic.MonoidSolver.html#4478" class="Bound">m₁</a> <a id="4481" href="Tactic.MonoidSolver.html#4481" class="Bound">m₂</a><a id="4483" class="Symbol">}</a> <a id="4485" class="Symbol">(</a><a id="4486" href="Tactic.MonoidSolver.html#4486" class="Bound">monoid</a> <a id="4493" class="Symbol">:</a> <a id="4495" href="Algebra.Bundles.html#7315" class="Record">Monoid</a> <a id="4502" href="Tactic.MonoidSolver.html#4478" class="Bound">m₁</a> <a id="4505" href="Tactic.MonoidSolver.html#4481" class="Bound">m₂</a><a id="4507" class="Symbol">)</a> <a id="4509" class="Keyword">where</a>

  <a id="4518" class="Keyword">open</a> <a id="4523" href="Algebra.Bundles.html#7315" class="Module">Monoid</a> <a id="4530" href="Tactic.MonoidSolver.html#4486" class="Bound">monoid</a>
  <a id="4539" class="Keyword">open</a> <a id="4544" href="Relation.Binary.Reasoning.Setoid.html" class="Module">≈-Reasoning</a> <a id="4556" href="Algebra.Structures.html#1873" class="Function">setoid</a>

  <a id="4566" class="Comment">-- Convert the AST to an expression (i.e. evaluate it) without</a>
  <a id="4631" class="Comment">-- normalising.</a>
  <a id="4649" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[_↓]</a> <a id="4654" class="Symbol">:</a> <a id="4656" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4661" href="Algebra.Bundles.html#7394" class="Field">Carrier</a> <a id="4669" class="Symbol">→</a> <a id="4671" href="Algebra.Bundles.html#7394" class="Field">Carrier</a>
  <a id="4681" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[</a> <a id="4683" href="Tactic.MonoidSolver.html#4683" class="Bound">x</a> <a id="4685" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="4688" href="Tactic.MonoidSolver.html#4688" class="Bound">y</a>  <a id="4691" href="Tactic.MonoidSolver.html#4649" class="Function Operator">↓]</a> <a id="4694" class="Symbol">=</a> <a id="4696" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[</a> <a id="4698" href="Tactic.MonoidSolver.html#4683" class="Bound">x</a> <a id="4700" href="Tactic.MonoidSolver.html#4649" class="Function Operator">↓]</a> <a id="4703" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="4705" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[</a> <a id="4707" href="Tactic.MonoidSolver.html#4688" class="Bound">y</a> <a id="4709" href="Tactic.MonoidSolver.html#4649" class="Function Operator">↓]</a>
  <a id="4714" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[</a> <a id="4716" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a>      <a id="4724" href="Tactic.MonoidSolver.html#4649" class="Function Operator">↓]</a> <a id="4727" class="Symbol">=</a> <a id="4729" href="Algebra.Bundles.html#7471" class="Field">ε</a>
  <a id="4733" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[</a> <a id="4735" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[</a> <a id="4737" href="Tactic.MonoidSolver.html#4737" class="Bound">x</a> <a id="4739" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">↑]</a>  <a id="4743" href="Tactic.MonoidSolver.html#4649" class="Function Operator">↓]</a> <a id="4746" class="Symbol">=</a> <a id="4748" href="Tactic.MonoidSolver.html#4737" class="Bound">x</a>

  <a id="4753" class="Comment">-- Convert an AST to an expression (i.e. evaluate it) while</a>
  <a id="4815" class="Comment">-- normalising.</a>
  <a id="4833" class="Comment">--</a>
  <a id="4838" class="Comment">-- This first function actually converts an AST to the Cayley</a>
  <a id="4902" class="Comment">-- representation of the underlying monoid.</a>
  <a id="4948" class="Comment">-- This obeys the monoid laws up to beta-eta equality, which is the</a>
  <a id="5018" class="Comment">-- property which gives us the &quot;normalising&quot; behaviour we want.</a>
  <a id="5084" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[_⇓]′</a> <a id="5090" class="Symbol">:</a> <a id="5092" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="5097" href="Algebra.Bundles.html#7394" class="Field">Carrier</a> <a id="5105" class="Symbol">→</a> <a id="5107" href="Algebra.Bundles.html#7394" class="Field">Carrier</a> <a id="5115" class="Symbol">→</a> <a id="5117" href="Algebra.Bundles.html#7394" class="Field">Carrier</a>
  <a id="5127" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5129" href="Tactic.MonoidSolver.html#5129" class="Bound">x</a> <a id="5131" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5134" href="Tactic.MonoidSolver.html#5134" class="Bound">y</a>  <a id="5137" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5141" href="Tactic.MonoidSolver.html#5141" class="Bound">z</a> <a id="5143" class="Symbol">=</a> <a id="5145" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5147" href="Tactic.MonoidSolver.html#5129" class="Bound">x</a> <a id="5149" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5153" class="Symbol">(</a><a id="5154" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5156" href="Tactic.MonoidSolver.html#5134" class="Bound">y</a> <a id="5158" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5162" href="Tactic.MonoidSolver.html#5141" class="Bound">z</a><a id="5163" class="Symbol">)</a>
  <a id="5167" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5169" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a>      <a id="5177" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5181" href="Tactic.MonoidSolver.html#5181" class="Bound">y</a> <a id="5183" class="Symbol">=</a> <a id="5185" href="Tactic.MonoidSolver.html#5181" class="Bound">y</a>
  <a id="5189" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5191" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[</a> <a id="5193" href="Tactic.MonoidSolver.html#5193" class="Bound">x</a> <a id="5195" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">↑]</a>  <a id="5199" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5203" href="Tactic.MonoidSolver.html#5203" class="Bound">y</a> <a id="5205" class="Symbol">=</a> <a id="5207" href="Tactic.MonoidSolver.html#5193" class="Bound">x</a> <a id="5209" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5211" href="Tactic.MonoidSolver.html#5203" class="Bound">y</a>

  <a id="5216" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[_⇓]</a> <a id="5221" class="Symbol">:</a> <a id="5223" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="5228" href="Algebra.Bundles.html#7394" class="Field">Carrier</a> <a id="5236" class="Symbol">→</a> <a id="5238" href="Algebra.Bundles.html#7394" class="Field">Carrier</a>
  <a id="5248" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5250" href="Tactic.MonoidSolver.html#5250" class="Bound">x</a> <a id="5252" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5255" class="Symbol">=</a> <a id="5257" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5259" href="Tactic.MonoidSolver.html#5250" class="Bound">x</a> <a id="5261" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5265" href="Algebra.Bundles.html#7471" class="Field">ε</a>

  <a id="5270" href="Tactic.MonoidSolver.html#5270" class="Function">homo′</a> <a id="5276" class="Symbol">:</a> <a id="5278" class="Symbol">∀</a> <a id="5280" href="Tactic.MonoidSolver.html#5280" class="Bound">x</a> <a id="5282" href="Tactic.MonoidSolver.html#5282" class="Bound">y</a> <a id="5284" class="Symbol">→</a> <a id="5286" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5288" href="Tactic.MonoidSolver.html#5280" class="Bound">x</a> <a id="5290" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5293" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5295" href="Tactic.MonoidSolver.html#5282" class="Bound">y</a> <a id="5297" href="Algebra.Bundles.html#7415" class="Field Operator">≈</a> <a id="5299" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5301" href="Tactic.MonoidSolver.html#5280" class="Bound">x</a> <a id="5303" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5307" href="Tactic.MonoidSolver.html#5282" class="Bound">y</a>
  <a id="5311" href="Tactic.MonoidSolver.html#5270" class="Function">homo′</a> <a id="5317" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a> <a id="5320" href="Tactic.MonoidSolver.html#5320" class="Bound">y</a>       <a id="5328" class="Symbol">=</a> <a id="5330" href="Algebra.Structures.html#4987" class="Function">identityˡ</a> <a id="5340" href="Tactic.MonoidSolver.html#5320" class="Bound">y</a>
  <a id="5344" href="Tactic.MonoidSolver.html#5270" class="Function">homo′</a> <a id="5350" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[</a> <a id="5352" href="Tactic.MonoidSolver.html#5352" class="Bound">x</a> <a id="5354" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">↑]</a> <a id="5357" href="Tactic.MonoidSolver.html#5357" class="Bound">y</a>   <a id="5361" class="Symbol">=</a> <a id="5363" href="Algebra.Structures.html#2009" class="Function">∙-congʳ</a> <a id="5371" class="Symbol">(</a><a id="5372" href="Algebra.Structures.html#5048" class="Function">identityʳ</a> <a id="5382" href="Tactic.MonoidSolver.html#5352" class="Bound">x</a><a id="5383" class="Symbol">)</a>
  <a id="5387" href="Tactic.MonoidSolver.html#5270" class="Function">homo′</a> <a id="5393" class="Symbol">(</a><a id="5394" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5396" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5399" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a><a id="5400" class="Symbol">)</a> <a id="5402" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a> <a id="5404" class="Symbol">=</a> <a id="5406" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="5416" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5418" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5420" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5423" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5425" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5428" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5430" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a>       <a id="5438" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="5446" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5448" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5450" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5454" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5456" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5458" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5461" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5463" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a>    <a id="5468" href="Relation.Binary.Reasoning.Syntax.html#7136" class="Function">≈⟨</a> <a id="5471" href="Algebra.Structures.html#2009" class="Function">∙-congʳ</a> <a id="5479" class="Symbol">(</a><a id="5480" href="Tactic.MonoidSolver.html#5270" class="Function">homo′</a> <a id="5486" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5488" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5490" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5492" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a><a id="5494" class="Symbol">)</a> <a id="5496" href="Relation.Binary.Reasoning.Syntax.html#7136" class="Function">⟨</a>
    <a id="5502" class="Symbol">(</a><a id="5503" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5505" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5507" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5510" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5512" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5514" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5516" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a><a id="5518" class="Symbol">)</a> <a id="5520" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5522" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a> <a id="5524" href="Relation.Binary.Reasoning.Syntax.html#7111" class="Function">≈⟨</a> <a id="5527" href="Algebra.Structures.html#3460" class="Function">assoc</a> <a id="5533" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5535" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5537" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5540" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5542" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5544" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5547" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a> <a id="5549" href="Relation.Binary.Reasoning.Syntax.html#7111" class="Function">⟩</a>
    <a id="5555" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5557" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5559" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5562" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5564" class="Symbol">(</a><a id="5565" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5567" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5569" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5572" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5574" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a><a id="5575" class="Symbol">)</a> <a id="5577" href="Relation.Binary.Reasoning.Syntax.html#7111" class="Function">≈⟨</a> <a id="5580" href="Algebra.Structures.html#1948" class="Function">∙-congˡ</a> <a id="5588" class="Symbol">(</a><a id="5589" href="Tactic.MonoidSolver.html#5270" class="Function">homo′</a> <a id="5595" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5597" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a><a id="5598" class="Symbol">)</a> <a id="5600" href="Relation.Binary.Reasoning.Syntax.html#7111" class="Function">⟩</a>
    <a id="5606" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5608" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5610" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5613" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5615" class="Symbol">(</a><a id="5616" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5618" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5620" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5624" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a><a id="5625" class="Symbol">)</a>  <a id="5628" href="Relation.Binary.Reasoning.Syntax.html#7111" class="Function">≈⟨</a> <a id="5631" href="Tactic.MonoidSolver.html#5270" class="Function">homo′</a> <a id="5637" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5639" class="Symbol">(</a><a id="5640" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5642" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5644" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5648" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a><a id="5649" class="Symbol">)</a> <a id="5651" href="Relation.Binary.Reasoning.Syntax.html#7111" class="Function">⟩</a>
    <a id="5657" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5659" href="Tactic.MonoidSolver.html#5394" class="Bound">x</a> <a id="5661" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5665" class="Symbol">(</a><a id="5666" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5668" href="Tactic.MonoidSolver.html#5399" class="Bound">y</a> <a id="5670" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5674" href="Tactic.MonoidSolver.html#5402" class="Bound">z</a><a id="5675" class="Symbol">)</a>   <a id="5679" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>

  <a id="5684" href="Tactic.MonoidSolver.html#5684" class="Function">homo</a> <a id="5689" class="Symbol">:</a> <a id="5691" class="Symbol">∀</a> <a id="5693" href="Tactic.MonoidSolver.html#5693" class="Bound">x</a> <a id="5695" class="Symbol">→</a> <a id="5697" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5699" href="Tactic.MonoidSolver.html#5693" class="Bound">x</a> <a id="5701" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5704" href="Algebra.Bundles.html#7415" class="Field Operator">≈</a> <a id="5706" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[</a> <a id="5708" href="Tactic.MonoidSolver.html#5693" class="Bound">x</a> <a id="5710" href="Tactic.MonoidSolver.html#4649" class="Function Operator">↓]</a>
  <a id="5715" href="Tactic.MonoidSolver.html#5684" class="Function">homo</a> <a id="5720" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a>       <a id="5729" class="Symbol">=</a> <a id="5731" href="Relation.Binary.Structures.html#1596" class="Function">refl</a>
  <a id="5738" href="Tactic.MonoidSolver.html#5684" class="Function">homo</a> <a id="5743" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[</a> <a id="5745" href="Tactic.MonoidSolver.html#5745" class="Bound">x</a> <a id="5747" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">↑]</a>   <a id="5752" class="Symbol">=</a> <a id="5754" href="Algebra.Structures.html#5048" class="Function">identityʳ</a> <a id="5764" href="Tactic.MonoidSolver.html#5745" class="Bound">x</a>
  <a id="5768" href="Tactic.MonoidSolver.html#5684" class="Function">homo</a> <a id="5773" class="Symbol">(</a><a id="5774" href="Tactic.MonoidSolver.html#5774" class="Bound">x</a> <a id="5776" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5779" href="Tactic.MonoidSolver.html#5779" class="Bound">y</a><a id="5780" class="Symbol">)</a> <a id="5782" class="Symbol">=</a> <a id="5784" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="5794" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5796" href="Tactic.MonoidSolver.html#5774" class="Bound">x</a> <a id="5798" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5801" href="Tactic.MonoidSolver.html#5779" class="Bound">y</a> <a id="5803" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a>     <a id="5810" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="5818" href="Tactic.MonoidSolver.html#5084" class="Function Operator">[</a> <a id="5820" href="Tactic.MonoidSolver.html#5774" class="Bound">x</a> <a id="5822" href="Tactic.MonoidSolver.html#5084" class="Function Operator">⇓]′</a> <a id="5826" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5828" href="Tactic.MonoidSolver.html#5779" class="Bound">y</a> <a id="5830" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a>  <a id="5834" href="Relation.Binary.Reasoning.Syntax.html#7136" class="Function">≈⟨</a> <a id="5837" href="Tactic.MonoidSolver.html#5270" class="Function">homo′</a> <a id="5843" href="Tactic.MonoidSolver.html#5774" class="Bound">x</a> <a id="5845" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5847" href="Tactic.MonoidSolver.html#5779" class="Bound">y</a> <a id="5849" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5852" href="Relation.Binary.Reasoning.Syntax.html#7136" class="Function">⟨</a>
    <a id="5858" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5860" href="Tactic.MonoidSolver.html#5774" class="Bound">x</a> <a id="5862" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5865" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5867" href="Tactic.MonoidSolver.html#5216" class="Function Operator">[</a> <a id="5869" href="Tactic.MonoidSolver.html#5779" class="Bound">y</a> <a id="5871" href="Tactic.MonoidSolver.html#5216" class="Function Operator">⇓]</a> <a id="5874" href="Relation.Binary.Reasoning.Syntax.html#7111" class="Function">≈⟨</a> <a id="5877" href="Algebra.Structures.html#1798" class="Function">∙-cong</a> <a id="5884" class="Symbol">(</a><a id="5885" href="Tactic.MonoidSolver.html#5684" class="Function">homo</a> <a id="5890" href="Tactic.MonoidSolver.html#5774" class="Bound">x</a><a id="5891" class="Symbol">)</a> <a id="5893" class="Symbol">(</a><a id="5894" href="Tactic.MonoidSolver.html#5684" class="Function">homo</a> <a id="5899" href="Tactic.MonoidSolver.html#5779" class="Bound">y</a><a id="5900" class="Symbol">)</a> <a id="5902" href="Relation.Binary.Reasoning.Syntax.html#7111" class="Function">⟩</a>
    <a id="5908" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[</a> <a id="5910" href="Tactic.MonoidSolver.html#5774" class="Bound">x</a> <a id="5912" href="Tactic.MonoidSolver.html#4649" class="Function Operator">↓]</a> <a id="5915" href="Algebra.Bundles.html#7444" class="Field Operator">∙</a> <a id="5917" href="Tactic.MonoidSolver.html#4649" class="Function Operator">[</a> <a id="5919" href="Tactic.MonoidSolver.html#5779" class="Bound">y</a> <a id="5921" href="Tactic.MonoidSolver.html#4649" class="Function Operator">↓]</a> <a id="5924" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>

<a id="5927" class="Comment">------------------------------------------------------------------------</a>
<a id="6000" class="Comment">-- Helpers for reflection</a>
<a id="6026" class="Comment">------------------------------------------------------------------------</a>

<a id="getArgs"></a><a id="6100" href="Tactic.MonoidSolver.html#6100" class="Function">getArgs</a> <a id="6108" class="Symbol">:</a> <a id="6110" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6115" class="Symbol">→</a> <a id="6117" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="6123" class="Symbol">(</a><a id="6124" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6129" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6131" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="6135" class="Symbol">)</a>
<a id="6137" href="Tactic.MonoidSolver.html#6100" class="Function">getArgs</a> <a id="6145" class="Symbol">(</a><a id="6146" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6150" class="Symbol">_</a> <a id="6152" href="Tactic.MonoidSolver.html#6152" class="Bound">xs</a><a id="6154" class="Symbol">)</a> <a id="6156" class="Symbol">=</a> <a id="6158" href="Tactic.MonoidSolver.html#6174" class="Function">go</a> <a id="6161" href="Tactic.MonoidSolver.html#6152" class="Bound">xs</a>
  <a id="6166" class="Keyword">where</a>
  <a id="6174" href="Tactic.MonoidSolver.html#6174" class="Function">go</a> <a id="6177" class="Symbol">:</a> <a id="6179" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6184" class="Symbol">(</a><a id="6185" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="6189" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="6193" class="Symbol">)</a> <a id="6195" class="Symbol">→</a> <a id="6197" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="6203" class="Symbol">(</a><a id="6204" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6209" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6211" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="6215" class="Symbol">)</a>
  <a id="6219" href="Tactic.MonoidSolver.html#6174" class="Function">go</a> <a id="6222" class="Symbol">(</a><a id="6223" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="6228" href="Tactic.MonoidSolver.html#6228" class="Bound">x</a> <a id="6230" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6232" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="6237" href="Tactic.MonoidSolver.html#6237" class="Bound">y</a> <a id="6239" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6241" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6243" class="Symbol">)</a> <a id="6245" class="Symbol">=</a> <a id="6247" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6252" class="Symbol">(</a><a id="6253" href="Tactic.MonoidSolver.html#6228" class="Bound">x</a> <a id="6255" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6257" href="Tactic.MonoidSolver.html#6237" class="Bound">y</a><a id="6258" class="Symbol">)</a>
  <a id="6262" href="Tactic.MonoidSolver.html#6174" class="CatchallClause Function">go</a><a id="6264" class="CatchallClause"> </a><a id="6265" class="CatchallClause Symbol">(</a><a id="6266" href="Tactic.MonoidSolver.html#6266" class="CatchallClause Bound">x</a><a id="6267" class="CatchallClause"> </a><a id="6268" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="6269" class="CatchallClause"> </a><a id="6270" href="Tactic.MonoidSolver.html#6270" class="CatchallClause Bound">xs</a><a id="6272" class="CatchallClause Symbol">)</a>               <a id="6288" class="Symbol">=</a> <a id="6290" href="Tactic.MonoidSolver.html#6174" class="Function">go</a> <a id="6293" href="Tactic.MonoidSolver.html#6270" class="Bound">xs</a>
  <a id="6298" href="Tactic.MonoidSolver.html#6174" class="CatchallClause Function">go</a><a id="6300" class="CatchallClause"> </a><a id="6301" class="CatchallClause Symbol">_</a>                      <a id="6324" class="Symbol">=</a> <a id="6326" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
<a id="6334" href="Tactic.MonoidSolver.html#6100" class="CatchallClause Function">getArgs</a><a id="6341" class="CatchallClause"> </a><a id="6342" class="CatchallClause Symbol">_</a> <a id="6344" class="Symbol">=</a> <a id="6346" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

<a id="6355" class="Comment">------------------------------------------------------------------------</a>
<a id="6428" class="Comment">-- Getting monoid names</a>
<a id="6452" class="Comment">------------------------------------------------------------------------</a>

<a id="6526" class="Comment">-- We try to be flexible here, by matching two kinds of names.</a>
<a id="6589" class="Comment">-- The first is the field accessor for the monoid record itself.</a>
<a id="6654" class="Comment">-- However, users will likely want to use the solver with</a>
<a id="6712" class="Comment">-- expressions like:</a>
<a id="6733" class="Comment">--</a>
<a id="6736" class="Comment">--   xs ++ (ys ++ zs) ≡ (xs ++ ys) ++ zs</a>
<a id="6777" class="Comment">--</a>
<a id="6780" class="Comment">-- So we also evaluate the field accessor to find functions like ++.</a>

<a id="6850" class="Keyword">record</a> <a id="MonoidNames"></a><a id="6857" href="Tactic.MonoidSolver.html#6857" class="Record">MonoidNames</a> <a id="6869" class="Symbol">:</a> <a id="6871" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="6875" class="Keyword">where</a>
  <a id="6883" class="Keyword">field</a>
    <a id="MonoidNames.is-∙"></a><a id="6893" href="Tactic.MonoidSolver.html#6893" class="Field">is-∙</a> <a id="6898" class="Symbol">:</a> <a id="6900" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6905" class="Symbol">→</a> <a id="6907" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
    <a id="MonoidNames.is-ε"></a><a id="6916" href="Tactic.MonoidSolver.html#6916" class="Field">is-ε</a> <a id="6921" class="Symbol">:</a> <a id="6923" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6928" class="Symbol">→</a> <a id="6930" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>

<a id="buildMatcher"></a><a id="6936" href="Tactic.MonoidSolver.html#6936" class="Function">buildMatcher</a> <a id="6949" class="Symbol">:</a> <a id="6951" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6956" class="Symbol">→</a> <a id="6958" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="6964" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6969" class="Symbol">→</a> <a id="6971" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6976" class="Symbol">→</a> <a id="6978" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
<a id="6983" href="Tactic.MonoidSolver.html#6936" class="Function">buildMatcher</a> <a id="6996" href="Tactic.MonoidSolver.html#6996" class="Bound">n</a> <a id="6998" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>  <a id="7007" href="Tactic.MonoidSolver.html#7007" class="Bound">x</a> <a id="7009" class="Symbol">=</a> <a id="7011" href="Tactic.MonoidSolver.html#6996" class="Bound">n</a> <a id="7013" href="Agda.Builtin.Reflection.html#539" class="Primitive Operator">Name.≡ᵇ</a> <a id="7021" href="Tactic.MonoidSolver.html#7007" class="Bound">x</a>
<a id="7023" href="Tactic.MonoidSolver.html#6936" class="Function">buildMatcher</a> <a id="7036" href="Tactic.MonoidSolver.html#7036" class="Bound">n</a> <a id="7038" class="Symbol">(</a><a id="7039" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="7044" href="Tactic.MonoidSolver.html#7044" class="Bound">m</a><a id="7045" class="Symbol">)</a> <a id="7047" href="Tactic.MonoidSolver.html#7047" class="Bound">x</a> <a id="7049" class="Symbol">=</a> <a id="7051" href="Tactic.MonoidSolver.html#7036" class="Bound">n</a> <a id="7053" href="Agda.Builtin.Reflection.html#539" class="Primitive Operator">Name.≡ᵇ</a> <a id="7061" href="Tactic.MonoidSolver.html#7047" class="Bound">x</a> <a id="7063" href="Data.Bool.Base.html#1053" class="Function Operator">∨</a> <a id="7065" href="Tactic.MonoidSolver.html#7044" class="Bound">m</a> <a id="7067" href="Agda.Builtin.Reflection.html#539" class="Primitive Operator">Name.≡ᵇ</a> <a id="7075" href="Tactic.MonoidSolver.html#7047" class="Bound">x</a>

<a id="findMonoidNames"></a><a id="7078" href="Tactic.MonoidSolver.html#7078" class="Function">findMonoidNames</a> <a id="7094" class="Symbol">:</a> <a id="7096" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7101" class="Symbol">→</a> <a id="7103" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7106" href="Tactic.MonoidSolver.html#6857" class="Record">MonoidNames</a>
<a id="7118" href="Tactic.MonoidSolver.html#7078" class="Function">findMonoidNames</a> <a id="7134" href="Tactic.MonoidSolver.html#7134" class="Bound">mon</a> <a id="7138" class="Symbol">=</a> <a id="7140" class="Keyword">do</a>
  <a id="7145" href="Tactic.MonoidSolver.html#7145" class="Bound">∙-altName</a> <a id="7155" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7157" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="7167" class="Symbol">(</a><a id="7168" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="7172" class="Symbol">(</a><a id="7173" class="Keyword">quote</a> <a id="7179" href="Algebra.Bundles.html#7444" class="Field Operator">Monoid._∙_</a><a id="7189" class="Symbol">)</a> <a id="7191" class="Symbol">(</a><a id="7192" class="Number">2</a> <a id="7194" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="7199" href="Tactic.MonoidSolver.html#7134" class="Bound">mon</a> <a id="7203" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7207" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7209" class="Symbol">))</a>
  <a id="7214" href="Tactic.MonoidSolver.html#7214" class="Bound">ε-altName</a> <a id="7224" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7226" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="7236" class="Symbol">(</a><a id="7237" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="7241" class="Symbol">(</a><a id="7242" class="Keyword">quote</a> <a id="7248" href="Algebra.Bundles.html#7471" class="Field">Monoid.ε</a><a id="7256" class="Symbol">)</a>   <a id="7260" class="Symbol">(</a><a id="7261" class="Number">2</a> <a id="7263" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="7268" href="Tactic.MonoidSolver.html#7134" class="Bound">mon</a> <a id="7272" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7276" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7278" class="Symbol">))</a>
  <a id="7283" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7288" class="Keyword">record</a>
    <a id="7299" class="Symbol">{</a> <a id="7301" href="Tactic.MonoidSolver.html#6893" class="Field">is-∙</a> <a id="7306" class="Symbol">=</a> <a id="7308" href="Tactic.MonoidSolver.html#6936" class="Function">buildMatcher</a> <a id="7321" class="Symbol">(</a><a id="7322" class="Keyword">quote</a> <a id="7328" href="Algebra.Bundles.html#7444" class="Field Operator">Monoid._∙_</a><a id="7338" class="Symbol">)</a> <a id="7340" class="Symbol">(</a><a id="7341" href="Reflection.AST.Term.html#2566" class="Function">getName</a> <a id="7349" href="Tactic.MonoidSolver.html#7145" class="Bound">∙-altName</a><a id="7358" class="Symbol">)</a>
    <a id="7364" class="Symbol">;</a> <a id="7366" href="Tactic.MonoidSolver.html#6916" class="Field">is-ε</a> <a id="7371" class="Symbol">=</a> <a id="7373" href="Tactic.MonoidSolver.html#6936" class="Function">buildMatcher</a> <a id="7386" class="Symbol">(</a><a id="7387" class="Keyword">quote</a> <a id="7393" href="Algebra.Bundles.html#7471" class="Field">Monoid.ε</a><a id="7401" class="Symbol">)</a>   <a id="7405" class="Symbol">(</a><a id="7406" href="Reflection.AST.Term.html#2566" class="Function">getName</a> <a id="7414" href="Tactic.MonoidSolver.html#7214" class="Bound">ε-altName</a><a id="7423" class="Symbol">)</a>
    <a id="7429" class="Symbol">}</a>

<a id="7432" class="Comment">------------------------------------------------------------------------</a>
<a id="7505" class="Comment">-- Building Expr</a>
<a id="7522" class="Comment">------------------------------------------------------------------------</a>

<a id="7596" class="Comment">-- We now define a function that takes an AST representing the LHS</a>
<a id="7663" class="Comment">-- or RHS of the equation to solve and converts it into an AST</a>
<a id="7726" class="Comment">-- respresenting the corresponding Expr.</a>

<a id="″ε″"></a><a id="7768" href="Tactic.MonoidSolver.html#7768" class="Function">″ε″</a> <a id="7772" class="Symbol">:</a> <a id="7774" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="7779" href="Tactic.MonoidSolver.html#7768" class="Function">″ε″</a> <a id="7783" class="Symbol">=</a> <a id="7785" class="Keyword">quote</a> <a id="7791" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a> <a id="7794" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="7796" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="7800" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="7802" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="[_↑]′"></a><a id="7806" href="Tactic.MonoidSolver.html#7806" class="Function Operator">[_↑]′</a> <a id="7812" class="Symbol">:</a> <a id="7814" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7819" class="Symbol">→</a> <a id="7821" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="7826" href="Tactic.MonoidSolver.html#7806" class="Function Operator">[</a> <a id="7828" href="Tactic.MonoidSolver.html#7828" class="Bound">t</a> <a id="7830" href="Tactic.MonoidSolver.html#7806" class="Function Operator">↑]′</a> <a id="7834" class="Symbol">=</a> <a id="7836" class="Keyword">quote</a> <a id="7842" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[_↑]</a> <a id="7847" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="7849" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="7853" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="7855" class="Symbol">(</a><a id="7856" href="Tactic.MonoidSolver.html#7828" class="Bound">t</a> <a id="7858" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7862" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7864" class="Symbol">)</a>

<a id="7867" class="Keyword">module</a> <a id="7874" href="Tactic.MonoidSolver.html#7874" class="Module">_</a> <a id="7876" class="Symbol">(</a><a id="7877" href="Tactic.MonoidSolver.html#7877" class="Bound">names</a> <a id="7883" class="Symbol">:</a> <a id="7885" href="Tactic.MonoidSolver.html#6857" class="Record">MonoidNames</a><a id="7896" class="Symbol">)</a> <a id="7898" class="Keyword">where</a>

 <a id="7906" class="Keyword">open</a> <a id="7911" href="Tactic.MonoidSolver.html#6857" class="Module">MonoidNames</a> <a id="7923" href="Tactic.MonoidSolver.html#7877" class="Bound">names</a>

 <a id="7931" class="Keyword">mutual</a>
  <a id="7940" href="Tactic.MonoidSolver.html#7940" class="Function">″∙″</a> <a id="7944" class="Symbol">:</a> <a id="7946" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="7951" class="Symbol">(</a><a id="7952" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="7956" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="7960" class="Symbol">)</a> <a id="7962" class="Symbol">→</a> <a id="7964" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="7971" href="Tactic.MonoidSolver.html#7940" class="Function">″∙″</a> <a id="7975" class="Symbol">(</a><a id="7976" href="Tactic.MonoidSolver.html#7976" class="Bound">x</a> <a id="7978" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7982" href="Tactic.MonoidSolver.html#7982" class="Bound">y</a> <a id="7984" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7988" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7990" class="Symbol">)</a> <a id="7992" class="Symbol">=</a> <a id="7994" class="Keyword">quote</a> <a id="8000" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">_∙′_</a> <a id="8005" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="8007" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8011" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="8013" href="Tactic.MonoidSolver.html#8116" class="Function">buildExpr</a> <a id="8023" href="Tactic.MonoidSolver.html#7976" class="Bound">x</a> <a id="8025" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8029" href="Tactic.MonoidSolver.html#8116" class="Function">buildExpr</a> <a id="8039" href="Tactic.MonoidSolver.html#7982" class="Bound">y</a> <a id="8041" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8045" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="8050" href="Tactic.MonoidSolver.html#7940" class="CatchallClause Function">″∙″</a><a id="8053" class="CatchallClause"> </a><a id="8054" class="CatchallClause Symbol">(</a><a id="8055" href="Tactic.MonoidSolver.html#8055" class="CatchallClause Bound">x</a><a id="8056" class="CatchallClause"> </a><a id="8057" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8058" class="CatchallClause"> </a><a id="8059" href="Tactic.MonoidSolver.html#8059" class="CatchallClause Bound">xs</a><a id="8061" class="CatchallClause Symbol">)</a>         <a id="8071" class="Symbol">=</a> <a id="8073" href="Tactic.MonoidSolver.html#7940" class="Function">″∙″</a> <a id="8077" href="Tactic.MonoidSolver.html#8059" class="Bound">xs</a>
  <a id="8082" href="Tactic.MonoidSolver.html#7940" class="CatchallClause Function">″∙″</a><a id="8085" class="CatchallClause"> </a><a id="8086" class="CatchallClause Symbol">_</a>                <a id="8103" class="Symbol">=</a> <a id="8105" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

  <a id="8116" href="Tactic.MonoidSolver.html#8116" class="Function">buildExpr</a> <a id="8126" class="Symbol">:</a> <a id="8128" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8133" class="Symbol">→</a> <a id="8135" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="8142" href="Tactic.MonoidSolver.html#8116" class="Function">buildExpr</a> <a id="8152" href="Tactic.MonoidSolver.html#8152" class="Bound">t</a><a id="8153" class="Symbol">@(</a><a id="8155" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8159" href="Tactic.MonoidSolver.html#8159" class="Bound">n</a> <a id="8161" href="Tactic.MonoidSolver.html#8161" class="Bound">xs</a><a id="8163" class="Symbol">)</a> <a id="8165" class="Symbol">=</a>
    <a id="8171" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8174" href="Tactic.MonoidSolver.html#6893" class="Field">is-∙</a> <a id="8179" href="Tactic.MonoidSolver.html#8159" class="Bound">n</a>
      <a id="8187" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8192" href="Tactic.MonoidSolver.html#7940" class="Function">″∙″</a> <a id="8196" href="Tactic.MonoidSolver.html#8161" class="Bound">xs</a>
    <a id="8203" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="8208" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8211" href="Tactic.MonoidSolver.html#6916" class="Field">is-ε</a> <a id="8216" href="Tactic.MonoidSolver.html#8159" class="Bound">n</a>
      <a id="8224" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8229" href="Tactic.MonoidSolver.html#7768" class="Function">″ε″</a>
    <a id="8237" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
      <a id="8248" href="Tactic.MonoidSolver.html#7806" class="Function Operator">[</a> <a id="8250" href="Tactic.MonoidSolver.html#8152" class="Bound">t</a> <a id="8252" href="Tactic.MonoidSolver.html#7806" class="Function Operator">↑]′</a>
  <a id="8258" href="Tactic.MonoidSolver.html#8116" class="Function">buildExpr</a> <a id="8268" href="Tactic.MonoidSolver.html#8268" class="Bound">t</a><a id="8269" class="Symbol">@(</a><a id="8271" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8275" href="Tactic.MonoidSolver.html#8275" class="Bound">n</a> <a id="8277" href="Tactic.MonoidSolver.html#8277" class="Bound">xs</a><a id="8279" class="Symbol">)</a> <a id="8281" class="Symbol">=</a>
    <a id="8287" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8290" href="Tactic.MonoidSolver.html#6893" class="Field">is-∙</a> <a id="8295" href="Tactic.MonoidSolver.html#8275" class="Bound">n</a>
      <a id="8303" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8308" href="Tactic.MonoidSolver.html#7940" class="Function">″∙″</a> <a id="8312" href="Tactic.MonoidSolver.html#8277" class="Bound">xs</a>
    <a id="8319" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="8324" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8327" href="Tactic.MonoidSolver.html#6916" class="Field">is-ε</a> <a id="8332" href="Tactic.MonoidSolver.html#8275" class="Bound">n</a>
      <a id="8340" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8345" href="Tactic.MonoidSolver.html#7768" class="Function">″ε″</a>
    <a id="8353" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="8358" href="Tactic.MonoidSolver.html#7806" class="Function Operator">[</a> <a id="8360" href="Tactic.MonoidSolver.html#8268" class="Bound">t</a> <a id="8362" href="Tactic.MonoidSolver.html#7806" class="Function Operator">↑]′</a>
  <a id="8368" href="Tactic.MonoidSolver.html#8116" class="CatchallClause Function">buildExpr</a><a id="8377" class="CatchallClause"> </a><a id="8378" href="Tactic.MonoidSolver.html#8378" class="CatchallClause Bound">t</a> <a id="8380" class="Symbol">=</a> <a id="8382" class="Keyword">quote</a> <a id="8388" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[_↑]</a> <a id="8393" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="8395" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8399" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="8401" class="Symbol">(</a><a id="8402" href="Tactic.MonoidSolver.html#8378" class="Bound">t</a> <a id="8404" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8408" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8410" class="Symbol">)</a>

<a id="8413" class="Comment">------------------------------------------------------------------------</a>
<a id="8486" class="Comment">-- Constructing the solution</a>
<a id="8515" class="Comment">------------------------------------------------------------------------</a>

<a id="8589" class="Comment">-- This function joins up the two homomorphism proofs. It constructs</a>
<a id="8658" class="Comment">-- a proof of the following form:</a>
<a id="8692" class="Comment">--</a>
<a id="8695" class="Comment">--   trans (sym (homo x)) (homo y)</a>
<a id="8730" class="Comment">--</a>
<a id="8733" class="Comment">-- where x and y are the Expr representations of each side of the</a>
<a id="8799" class="Comment">-- goal equation.</a>

<a id="constructSoln"></a><a id="8818" href="Tactic.MonoidSolver.html#8818" class="Function">constructSoln</a> <a id="8832" class="Symbol">:</a> <a id="8834" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8839" class="Symbol">→</a> <a id="8841" href="Tactic.MonoidSolver.html#6857" class="Record">MonoidNames</a> <a id="8853" class="Symbol">→</a> <a id="8855" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8860" class="Symbol">→</a> <a id="8862" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8867" class="Symbol">→</a> <a id="8869" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="8874" href="Tactic.MonoidSolver.html#8818" class="Function">constructSoln</a> <a id="8888" href="Tactic.MonoidSolver.html#8888" class="Bound">mon</a> <a id="8892" href="Tactic.MonoidSolver.html#8892" class="Bound">names</a> <a id="8898" href="Tactic.MonoidSolver.html#8898" class="Bound">lhs</a> <a id="8902" href="Tactic.MonoidSolver.html#8902" class="Bound">rhs</a> <a id="8906" class="Symbol">=</a>
  <a id="8910" class="Keyword">quote</a> <a id="8916" href="Relation.Binary.Structures.html#1648" class="Function">Monoid.trans</a> <a id="8929" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="8931" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8935" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="8937" class="Number">2</a> <a id="8939" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="8944" href="Tactic.MonoidSolver.html#8888" class="Bound">mon</a> <a id="8948" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="8956" class="Symbol">(</a><a id="8957" class="Keyword">quote</a> <a id="8963" href="Relation.Binary.Structures.html#1622" class="Function">Monoid.sym</a> <a id="8974" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="8976" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8980" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="8982" class="Number">2</a> <a id="8984" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="8989" href="Tactic.MonoidSolver.html#8888" class="Bound">mon</a> <a id="8993" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
       <a id="9004" class="Symbol">(</a><a id="9005" class="Keyword">quote</a> <a id="9011" href="Tactic.MonoidSolver.html#5684" class="Function">homo</a> <a id="9016" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="9018" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="9022" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="9024" class="Number">2</a> <a id="9026" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="9031" href="Tactic.MonoidSolver.html#8888" class="Bound">mon</a> <a id="9035" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9039" href="Tactic.MonoidSolver.html#8116" class="Function">buildExpr</a> <a id="9049" href="Tactic.MonoidSolver.html#8892" class="Bound">names</a> <a id="9055" href="Tactic.MonoidSolver.html#8898" class="Bound">lhs</a> <a id="9059" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9063" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9065" class="Symbol">)</a> <a id="9067" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9071" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9073" class="Symbol">)</a>
    <a id="9079" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="9087" class="Symbol">(</a><a id="9088" class="Keyword">quote</a> <a id="9094" href="Tactic.MonoidSolver.html#5684" class="Function">homo</a> <a id="9099" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="9101" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="9105" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="9107" class="Number">2</a> <a id="9109" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="9114" href="Tactic.MonoidSolver.html#8888" class="Bound">mon</a> <a id="9118" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9122" href="Tactic.MonoidSolver.html#8116" class="Function">buildExpr</a> <a id="9132" href="Tactic.MonoidSolver.html#8892" class="Bound">names</a> <a id="9138" href="Tactic.MonoidSolver.html#8902" class="Bound">rhs</a> <a id="9142" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9146" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9148" class="Symbol">)</a> <a id="9150" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="9158" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="9162" class="Comment">------------------------------------------------------------------------</a>
<a id="9235" class="Comment">-- Macro</a>
<a id="9244" class="Comment">------------------------------------------------------------------------</a>

<a id="solve-macro"></a><a id="9318" href="Tactic.MonoidSolver.html#9318" class="Function">solve-macro</a> <a id="9330" class="Symbol">:</a> <a id="9332" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9337" class="Symbol">→</a> <a id="9339" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9344" class="Symbol">→</a> <a id="9346" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="9349" class="Symbol">_</a>
<a id="9351" href="Tactic.MonoidSolver.html#9318" class="Function">solve-macro</a> <a id="9363" href="Tactic.MonoidSolver.html#9363" class="Bound">mon</a> <a id="9367" href="Tactic.MonoidSolver.html#9367" class="Bound">hole</a> <a id="9372" class="Symbol">=</a> <a id="9374" class="Keyword">do</a>
  <a id="9379" href="Tactic.MonoidSolver.html#9379" class="Bound">hole′</a> <a id="9385" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9387" href="Agda.Builtin.Reflection.html#8893" class="Postulate">inferType</a> <a id="9397" href="Tactic.MonoidSolver.html#9367" class="Bound">hole</a> <a id="9402" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="9406" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a>
  <a id="9418" href="Tactic.MonoidSolver.html#9418" class="Bound">names</a> <a id="9424" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9426" href="Tactic.MonoidSolver.html#7078" class="Function">findMonoidNames</a> <a id="9442" href="Tactic.MonoidSolver.html#9363" class="Bound">mon</a>
  <a id="9448" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="9453" class="Symbol">(</a><a id="9454" href="Tactic.MonoidSolver.html#9454" class="Bound">lhs</a> <a id="9458" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9460" href="Tactic.MonoidSolver.html#9460" class="Bound">rhs</a><a id="9463" class="Symbol">)</a> <a id="9465" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9467" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="9472" class="Symbol">(</a><a id="9473" href="Tactic.MonoidSolver.html#6100" class="Function">getArgs</a> <a id="9481" href="Tactic.MonoidSolver.html#9379" class="Bound">hole′</a><a id="9486" class="Symbol">)</a>
    <a id="9492" class="Keyword">where</a> <a id="9498" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="9506" class="Symbol">→</a> <a id="9508" href="Agda.Builtin.Reflection.html#8830" class="Postulate">typeError</a> <a id="9518" class="Symbol">(</a><a id="9519" href="Agda.Builtin.Reflection.html#8269" class="InductiveConstructor">termErr</a> <a id="9527" href="Tactic.MonoidSolver.html#9379" class="Bound">hole′</a> <a id="9533" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9535" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9537" class="Symbol">)</a>
  <a id="9541" class="Keyword">let</a> <a id="9545" href="Tactic.MonoidSolver.html#9545" class="Bound">soln</a> <a id="9550" class="Symbol">=</a> <a id="9552" href="Tactic.MonoidSolver.html#8818" class="Function">constructSoln</a> <a id="9566" href="Tactic.MonoidSolver.html#9363" class="Bound">mon</a> <a id="9570" href="Tactic.MonoidSolver.html#9418" class="Bound">names</a> <a id="9576" href="Tactic.MonoidSolver.html#9454" class="Bound">lhs</a> <a id="9580" href="Tactic.MonoidSolver.html#9460" class="Bound">rhs</a>
  <a id="9586" href="Agda.Builtin.Reflection.html#8790" class="Postulate">unify</a> <a id="9592" href="Tactic.MonoidSolver.html#9367" class="Bound">hole</a> <a id="9597" href="Tactic.MonoidSolver.html#9545" class="Bound">soln</a>

<a id="9603" class="Keyword">macro</a>
  <a id="solve"></a><a id="9611" href="Tactic.MonoidSolver.html#9611" class="Function">solve</a> <a id="9617" class="Symbol">:</a> <a id="9619" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9624" class="Symbol">→</a> <a id="9626" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9631" class="Symbol">→</a> <a id="9633" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="9636" class="Symbol">_</a>
  <a id="9640" href="Tactic.MonoidSolver.html#9611" class="Function">solve</a> <a id="9646" class="Symbol">=</a> <a id="9648" href="Tactic.MonoidSolver.html#9318" class="Function">solve-macro</a>
</pre></body></html>