<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--cubical-compatible</a> <a id="305" class="Pragma">--safe</a> <a id="312" class="Symbol">#-}</a>

<a id="317" class="Keyword">module</a> <a id="324" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="342" class="Keyword">where</a>

<a id="349" class="Keyword">open</a> <a id="354" class="Keyword">import</a> <a id="361" href="Algebra.html" class="Module">Algebra</a>
<a id="369" class="Keyword">open</a> <a id="374" class="Keyword">import</a> <a id="381" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>   <a id="397" class="Symbol">as</a> <a id="400" class="Module">Fin</a>     <a id="408" class="Keyword">using</a> <a id="414" class="Symbol">(</a><a id="415" href="Data.Fin.Base.html#1159" class="Datatype">Fin</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>   <a id="448" class="Symbol">as</a> <a id="451" class="Module">Vec</a>     <a id="459" class="Keyword">using</a> <a id="465" class="Symbol">(</a><a id="466" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a><a id="469" class="Symbol">;</a> <a id="471" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">_∷_</a><a id="474" class="Symbol">;</a> <a id="476" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a><a id="478" class="Symbol">)</a>
<a id="480" class="Keyword">open</a> <a id="485" class="Keyword">import</a> <a id="492" href="Data.List.Base.html" class="Module">Data.List.Base</a>  <a id="508" class="Symbol">as</a> <a id="511" class="Module">List</a>    <a id="519" class="Keyword">using</a> <a id="525" class="Symbol">(</a><a id="526" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="530" class="Symbol">;</a> <a id="532" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="535" class="Symbol">;</a> <a id="537" href="Data.List.Base.html#7599" class="InductiveConstructor">[]</a><a id="539" class="Symbol">)</a>
<a id="541" class="Keyword">open</a> <a id="546" class="Keyword">import</a> <a id="553" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="569" class="Symbol">as</a> <a id="572" class="Module">Maybe</a>   <a id="580" class="Keyword">using</a> <a id="586" class="Symbol">(</a><a id="587" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a><a id="592" class="Symbol">;</a> <a id="594" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a><a id="598" class="Symbol">;</a> <a id="600" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="607" class="Symbol">;</a> <a id="609" href="Data.Maybe.Base.html#1546" class="Function">fromMaybe</a><a id="618" class="Symbol">)</a>
<a id="620" class="Keyword">open</a> <a id="625" class="Keyword">import</a> <a id="632" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>              <a id="659" class="Keyword">using</a> <a id="665" class="Symbol">(</a><a id="666" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="667" class="Symbol">;</a> <a id="669" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="672" class="Symbol">;</a> <a id="674" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="678" class="Symbol">;</a> <a id="680" href="Data.Nat.Base.html#1463" class="Primitive Operator">_&lt;ᵇ_</a><a id="684" class="Symbol">)</a>
<a id="686" class="Keyword">open</a> <a id="691" class="Keyword">import</a> <a id="698" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>             <a id="725" class="Keyword">using</a> <a id="731" class="Symbol">(</a><a id="732" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="736" class="Symbol">;</a> <a id="738" href="Data.Bool.Base.html#1505" class="Function Operator">if_then_else_</a><a id="751" class="Symbol">;</a> <a id="753" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="757" class="Symbol">;</a> <a id="759" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="764" class="Symbol">)</a>
<a id="766" class="Keyword">open</a> <a id="771" class="Keyword">import</a> <a id="778" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>             <a id="805" class="Keyword">using</a> <a id="811" class="Symbol">(</a><a id="812" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="813" class="Symbol">)</a>
<a id="815" class="Keyword">open</a> <a id="820" class="Keyword">import</a> <a id="827" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="844" class="Symbol">as</a> <a id="847" class="Module">String</a> <a id="854" class="Keyword">using</a> <a id="860" class="Symbol">(</a><a id="861" href="Agda.Builtin.String.html#335" class="Postulate">String</a><a id="867" class="Symbol">;</a> <a id="869" href="Data.String.Base.html#2425" class="Function Operator">_++_</a><a id="873" class="Symbol">;</a> <a id="875" href="Data.String.Base.html#2982" class="Function">parens</a><a id="881" class="Symbol">)</a>
<a id="883" class="Keyword">open</a> <a id="888" class="Keyword">import</a> <a id="895" href="Data.Product.Base.html" class="Module">Data.Product.Base</a>          <a id="922" class="Keyword">using</a> <a id="928" class="Symbol">(</a><a id="929" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="932" class="Symbol">;</a> <a id="934" href="Data.Product.Base.html#636" class="Field">proj₁</a><a id="939" class="Symbol">)</a>
<a id="941" class="Keyword">open</a> <a id="946" class="Keyword">import</a> <a id="953" href="Function.Base.html" class="Module">Function.Base</a>

<a id="968" class="Keyword">open</a> <a id="973" class="Keyword">import</a> <a id="980" href="Reflection.html" class="Module">Reflection</a>
<a id="991" class="Keyword">open</a> <a id="996" class="Keyword">import</a> <a id="1003" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="1027" class="Keyword">open</a> <a id="1032" class="Keyword">import</a> <a id="1039" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a> <a id="1059" class="Symbol">as</a> <a id="1062" class="Module">Term</a>
<a id="1067" class="Keyword">open</a> <a id="1072" class="Keyword">import</a> <a id="1079" href="Reflection.AST.AlphaEquality.html" class="Module">Reflection.AST.AlphaEquality</a>
<a id="1108" class="Keyword">open</a> <a id="1113" class="Keyword">import</a> <a id="1120" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="1140" class="Symbol">as</a> <a id="1143" class="Module">Name</a>
<a id="1148" class="Keyword">open</a> <a id="1153" class="Keyword">import</a> <a id="1160" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>
<a id="1182" class="Keyword">open</a> <a id="1187" class="Keyword">import</a> <a id="1194" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a>
<a id="1214" class="Keyword">open</a> <a id="1219" class="Keyword">import</a> <a id="1226" href="Data.List.Reflection.html" class="Module">Data.List.Reflection</a>
<a id="1247" class="Keyword">import</a> <a id="1254" href="Data.Vec.Reflection.html" class="Module">Data.Vec.Reflection</a> <a id="1274" class="Symbol">as</a> <a id="1277" class="Module">Vec</a>

<a id="1282" class="Keyword">open</a> <a id="1287" class="Keyword">import</a> <a id="1294" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1326" class="Keyword">renaming</a> <a id="1335" class="Symbol">(</a><a id="1336" href="Tactic.RingSolver.NonReflective.html#2981" class="Function">solve</a> <a id="1342" class="Symbol">to</a> <a id="1345" class="Function">solver</a><a id="1351" class="Symbol">)</a>
<a id="1353" class="Keyword">open</a> <a id="1358" class="Keyword">import</a> <a id="1365" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1410" class="Keyword">open</a> <a id="1415" class="Keyword">import</a> <a id="1422" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1452" class="Symbol">as</a> <a id="1455" class="Module">NatSet</a>

<a id="1463" class="Keyword">open</a> <a id="1468" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1288" class="Module">AlmostCommutativeRing</a>

<a id="1491" class="Comment">------------------------------------------------------------------------</a>
<a id="1564" class="Comment">-- Utilities</a>

<a id="1578" class="Keyword">private</a>
  <a id="VarMap"></a><a id="1588" href="Tactic.RingSolver.html#1588" class="Function">VarMap</a> <a id="1595" class="Symbol">:</a> <a id="1597" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="1603" href="Tactic.RingSolver.html#1588" class="Function">VarMap</a> <a id="1610" class="Symbol">=</a> <a id="1612" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1614" class="Symbol">→</a> <a id="1616" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1622" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>

  <a id="getVisible"></a><a id="1630" href="Tactic.RingSolver.html#1630" class="Function">getVisible</a> <a id="1641" class="Symbol">:</a> <a id="1643" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="1647" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1652" class="Symbol">→</a> <a id="1654" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1660" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="1667" href="Tactic.RingSolver.html#1630" class="Function">getVisible</a> <a id="1678" class="Symbol">(</a><a id="1679" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="1683" class="Symbol">(</a><a id="1684" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="1693" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="1701" class="Symbol">_)</a> <a id="1704" href="Tactic.RingSolver.html#1704" class="Bound">x</a><a id="1705" class="Symbol">)</a> <a id="1707" class="Symbol">=</a> <a id="1709" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="1714" href="Tactic.RingSolver.html#1704" class="Bound">x</a>
  <a id="1718" href="Tactic.RingSolver.html#1630" class="CatchallClause Function">getVisible</a><a id="1728" class="CatchallClause"> </a><a id="1729" class="CatchallClause Symbol">_</a>                            <a id="1758" class="Symbol">=</a> <a id="1760" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="getVisibleArgs"></a><a id="1771" href="Tactic.RingSolver.html#1771" class="Function">getVisibleArgs</a> <a id="1786" class="Symbol">:</a> <a id="1788" class="Symbol">∀</a> <a id="1790" href="Tactic.RingSolver.html#1790" class="Bound">n</a> <a id="1792" class="Symbol">→</a> <a id="1794" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1799" class="Symbol">→</a> <a id="1801" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1807" class="Symbol">(</a><a id="1808" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="1812" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1817" href="Tactic.RingSolver.html#1790" class="Bound">n</a><a id="1818" class="Symbol">)</a>
  <a id="1822" href="Tactic.RingSolver.html#1771" class="Function">getVisibleArgs</a> <a id="1837" href="Tactic.RingSolver.html#1837" class="Bound">n</a> <a id="1839" class="Symbol">(</a><a id="1840" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="1844" class="Symbol">_</a> <a id="1846" href="Tactic.RingSolver.html#1846" class="Bound">xs</a><a id="1848" class="Symbol">)</a> <a id="1850" class="Symbol">=</a> <a id="1852" href="Data.Maybe.Base.html#1934" class="Function">Maybe.map</a> <a id="1862" href="Data.Vec.Base.html#8862" class="Function">Vec.reverse</a>
    <a id="1878" class="Symbol">(</a><a id="1879" href="Data.List.Base.html#4249" class="Function">List.foldl</a> <a id="1890" href="Tactic.RingSolver.html#1941" class="Function">f</a> <a id="1892" href="Tactic.RingSolver.html#2085" class="Function">c</a> <a id="1894" class="Symbol">(</a><a id="1895" href="Data.List.Base.html#4628" class="Function">List.mapMaybe</a> <a id="1909" href="Tactic.RingSolver.html#1630" class="Function">getVisible</a> <a id="1920" href="Tactic.RingSolver.html#1846" class="Bound">xs</a><a id="1922" class="Symbol">)</a> <a id="1924" href="Tactic.RingSolver.html#1837" class="Bound">n</a><a id="1925" class="Symbol">)</a>
    <a id="1931" class="Keyword">where</a>
    <a id="1941" href="Tactic.RingSolver.html#1941" class="Function">f</a> <a id="1943" class="Symbol">:</a> <a id="1945" class="Symbol">(∀</a> <a id="1948" href="Tactic.RingSolver.html#1948" class="Bound">n</a> <a id="1950" class="Symbol">→</a> <a id="1952" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1958" class="Symbol">(</a><a id="1959" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="1963" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1968" href="Tactic.RingSolver.html#1948" class="Bound">n</a><a id="1969" class="Symbol">))</a> <a id="1972" class="Symbol">→</a> <a id="1974" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1979" class="Symbol">→</a> <a id="1981" class="Symbol">∀</a> <a id="1983" href="Tactic.RingSolver.html#1983" class="Bound">n</a> <a id="1985" class="Symbol">→</a> <a id="1987" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1993" class="Symbol">(</a><a id="1994" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="1998" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2003" href="Tactic.RingSolver.html#1983" class="Bound">n</a><a id="2004" class="Symbol">)</a>
    <a id="2010" href="Tactic.RingSolver.html#1941" class="Function">f</a> <a id="2012" href="Tactic.RingSolver.html#2012" class="Bound">xs</a> <a id="2015" href="Tactic.RingSolver.html#2015" class="Bound">x</a> <a id="2017" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="2025" class="Symbol">=</a> <a id="2027" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2032" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a>
    <a id="2039" href="Tactic.RingSolver.html#1941" class="Function">f</a> <a id="2041" href="Tactic.RingSolver.html#2041" class="Bound">xs</a> <a id="2044" href="Tactic.RingSolver.html#2044" class="Bound">x</a> <a id="2046" class="Symbol">(</a><a id="2047" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2051" href="Tactic.RingSolver.html#2051" class="Bound">n</a><a id="2052" class="Symbol">)</a> <a id="2054" class="Symbol">=</a> <a id="2056" href="Data.Maybe.Base.html#1934" class="Function">Maybe.map</a> <a id="2066" class="Symbol">(</a><a id="2067" href="Tactic.RingSolver.html#2044" class="Bound">x</a> <a id="2069" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷_</a><a id="2071" class="Symbol">)</a> <a id="2073" class="Symbol">(</a><a id="2074" href="Tactic.RingSolver.html#2041" class="Bound">xs</a> <a id="2077" href="Tactic.RingSolver.html#2051" class="Bound">n</a><a id="2078" class="Symbol">)</a>

    <a id="2085" href="Tactic.RingSolver.html#2085" class="Function">c</a> <a id="2087" class="Symbol">:</a> <a id="2089" class="Symbol">∀</a> <a id="2091" href="Tactic.RingSolver.html#2091" class="Bound">n</a> <a id="2093" class="Symbol">→</a> <a id="2095" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2101" class="Symbol">(</a><a id="2102" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="2106" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2111" href="Tactic.RingSolver.html#2091" class="Bound">n</a><a id="2112" class="Symbol">)</a>
    <a id="2118" href="Tactic.RingSolver.html#2085" class="Function">c</a> <a id="2120" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>     <a id="2129" class="Symbol">=</a> <a id="2131" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2136" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a>
    <a id="2143" href="Tactic.RingSolver.html#2085" class="Function">c</a> <a id="2145" class="Symbol">(</a><a id="2146" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2150" class="Symbol">_</a> <a id="2152" class="Symbol">)</a> <a id="2154" class="Symbol">=</a> <a id="2156" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
  <a id="2166" href="Tactic.RingSolver.html#1771" class="CatchallClause Function">getVisibleArgs</a><a id="2180" class="CatchallClause"> </a><a id="2181" class="CatchallClause Symbol">_</a><a id="2182" class="CatchallClause"> </a><a id="2183" class="CatchallClause Symbol">_</a> <a id="2185" class="Symbol">=</a> <a id="2187" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="curriedTerm"></a><a id="2198" href="Tactic.RingSolver.html#2198" class="Function">curriedTerm</a> <a id="2210" class="Symbol">:</a> <a id="2212" href="Tactic.RingSolver.Core.NatSet.html#2256" class="Function">NatSet</a> <a id="2219" class="Symbol">→</a> <a id="2221" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2228" href="Tactic.RingSolver.html#2198" class="Function">curriedTerm</a> <a id="2240" class="Symbol">=</a> <a id="2242" href="Data.List.Base.html#4148" class="Function">List.foldr</a> <a id="2253" href="Tactic.RingSolver.html#2294" class="Function">go</a> <a id="2256" href="Data.Vec.Reflection.html#684" class="Function">Vec.`[]</a> <a id="2264" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2266" href="Tactic.RingSolver.Core.NatSet.html#3430" class="Function">NatSet.toList</a>
    <a id="2284" class="Keyword">where</a>
    <a id="2294" href="Tactic.RingSolver.html#2294" class="Function">go</a> <a id="2297" class="Symbol">:</a> <a id="2299" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2301" class="Symbol">→</a> <a id="2303" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2308" class="Symbol">→</a> <a id="2310" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="2319" href="Tactic.RingSolver.html#2294" class="Function">go</a> <a id="2322" href="Tactic.RingSolver.html#2322" class="Bound">x</a> <a id="2324" href="Tactic.RingSolver.html#2324" class="Bound">xs</a> <a id="2327" class="Symbol">=</a> <a id="2329" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="2333" href="Tactic.RingSolver.html#2322" class="Bound">x</a> <a id="2335" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2338" href="Data.Vec.Reflection.html#749" class="Function Operator">Vec.`∷</a> <a id="2345" href="Tactic.RingSolver.html#2324" class="Bound">xs</a>

<a id="2349" class="Comment">------------------------------------------------------------------------</a>
<a id="2422" class="Comment">-- Reflection utilities for rings</a>

<a id="`AlmostCommutativeRing"></a><a id="2457" href="Tactic.RingSolver.html#2457" class="Function">`AlmostCommutativeRing</a> <a id="2480" class="Symbol">:</a> <a id="2482" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="2487" href="Tactic.RingSolver.html#2457" class="Function">`AlmostCommutativeRing</a> <a id="2510" class="Symbol">=</a> <a id="2512" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2516" class="Symbol">(</a><a id="2517" class="Keyword">quote</a> <a id="2523" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1288" class="Record">AlmostCommutativeRing</a><a id="2544" class="Symbol">)</a> <a id="2546" class="Symbol">(</a><a id="2547" class="Number">2</a> <a id="2549" href="Reflection.AST.Term.html#2885" class="Function Operator">⋯⟨∷⟩</a> <a id="2554" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2556" class="Symbol">)</a>

<a id="2559" class="Keyword">record</a> <a id="RingOperatorTerms"></a><a id="2566" href="Tactic.RingSolver.html#2566" class="Record">RingOperatorTerms</a> <a id="2584" class="Symbol">:</a> <a id="2586" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="2590" class="Keyword">where</a>
  <a id="2598" class="Keyword">constructor</a> <a id="add⇒_mul⇒_pow⇒_neg⇒_sub⇒_"></a><a id="2610" href="Tactic.RingSolver.html#2610" class="InductiveConstructor Operator">add⇒_mul⇒_pow⇒_neg⇒_sub⇒_</a>
  <a id="2638" class="Keyword">field</a>
    <a id="RingOperatorTerms.add"></a><a id="2648" href="Tactic.RingSolver.html#2648" class="Field">add</a> <a id="RingOperatorTerms.mul"></a><a id="2652" href="Tactic.RingSolver.html#2652" class="Field">mul</a> <a id="RingOperatorTerms.pow"></a><a id="2656" href="Tactic.RingSolver.html#2656" class="Field">pow</a> <a id="RingOperatorTerms.neg"></a><a id="2660" href="Tactic.RingSolver.html#2660" class="Field">neg</a> <a id="RingOperatorTerms.sub"></a><a id="2664" href="Tactic.RingSolver.html#2664" class="Field">sub</a> <a id="2668" class="Symbol">:</a> <a id="2670" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>

<a id="checkIsRing"></a><a id="2676" href="Tactic.RingSolver.html#2676" class="Function">checkIsRing</a> <a id="2688" class="Symbol">:</a> <a id="2690" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2695" class="Symbol">→</a> <a id="2697" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="2700" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="2705" href="Tactic.RingSolver.html#2676" class="Function">checkIsRing</a> <a id="2717" href="Tactic.RingSolver.html#2717" class="Bound">ring</a> <a id="2722" class="Symbol">=</a> <a id="2724" href="Agda.Builtin.Reflection.html#8929" class="Postulate">checkType</a> <a id="2734" href="Tactic.RingSolver.html#2717" class="Bound">ring</a> <a id="2739" href="Tactic.RingSolver.html#2457" class="Function">`AlmostCommutativeRing</a>

<a id="2763" class="Keyword">module</a> <a id="RingReflection"></a><a id="2770" href="Tactic.RingSolver.html#2770" class="Module">RingReflection</a> <a id="2785" class="Symbol">(</a><a id="2786" href="Tactic.RingSolver.html#2786" class="Bound">`ring</a> <a id="2792" class="Symbol">:</a> <a id="2794" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="2798" class="Symbol">)</a> <a id="2800" class="Keyword">where</a>

  <a id="2809" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
  <a id="2877" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
  <a id="2944" class="Comment">-- the required ring arguments</a>
  <a id="2977" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
  <a id="3025" class="Keyword">infixr</a> <a id="3032" class="Number">6</a> <a id="3034" href="Tactic.RingSolver.html#3041" class="Function Operator">_$ʳ_</a>
  <a id="RingReflection._$ʳ_"></a><a id="3041" href="Tactic.RingSolver.html#3041" class="Function Operator">_$ʳ_</a> <a id="3046" class="Symbol">:</a> <a id="3048" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="3053" class="Symbol">→</a> <a id="3055" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="3060" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3065" class="Symbol">→</a> <a id="3067" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3074" href="Tactic.RingSolver.html#3074" class="Bound">nm</a> <a id="3077" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3080" href="Tactic.RingSolver.html#3080" class="Bound">args</a> <a id="3085" class="Symbol">=</a> <a id="3087" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3091" href="Tactic.RingSolver.html#3074" class="Bound">nm</a> <a id="3094" class="Symbol">(</a><a id="3095" class="Number">2</a> <a id="3097" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="3102" href="Tactic.RingSolver.html#2786" class="Bound">`ring</a> <a id="3108" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3112" href="Tactic.RingSolver.html#3080" class="Bound">args</a><a id="3116" class="Symbol">)</a>

  <a id="RingReflection.`Carrier"></a><a id="3121" href="Tactic.RingSolver.html#3121" class="Function">`Carrier</a> <a id="3130" class="Symbol">:</a> <a id="3132" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3139" href="Tactic.RingSolver.html#3121" class="Function">`Carrier</a> <a id="3148" class="Symbol">=</a> <a id="3150" class="Keyword">quote</a> <a id="3156" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1426" class="Field">Carrier</a> <a id="3164" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3167" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

  <a id="RingReflection.`refl"></a><a id="3173" href="Tactic.RingSolver.html#3173" class="Function">`refl</a> <a id="3179" class="Symbol">:</a> <a id="3181" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3188" href="Tactic.RingSolver.html#3173" class="Function">`refl</a> <a id="3194" class="Symbol">=</a> <a id="3196" class="Keyword">quote</a> <a id="3202" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2589" class="Function">refl</a> <a id="3207" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3210" class="Symbol">(</a><a id="3211" class="Number">1</a> <a id="3213" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="3218" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3220" class="Symbol">)</a>

  <a id="RingReflection.`sym"></a><a id="3225" href="Tactic.RingSolver.html#3225" class="Function">`sym</a> <a id="3230" class="Symbol">:</a> <a id="3232" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3237" class="Symbol">→</a> <a id="3239" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3246" href="Tactic.RingSolver.html#3225" class="Function">`sym</a> <a id="3251" href="Tactic.RingSolver.html#3251" class="Bound">x≈y</a> <a id="3255" class="Symbol">=</a> <a id="3257" class="Keyword">quote</a> <a id="3263" href="Relation.Binary.Structures.html#1622" class="Function">sym</a> <a id="3267" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3270" class="Symbol">(</a><a id="3271" class="Number">2</a> <a id="3273" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="3278" href="Tactic.RingSolver.html#3251" class="Bound">x≈y</a> <a id="3282" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3286" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3288" class="Symbol">)</a>

  <a id="RingReflection.`trans"></a><a id="3293" href="Tactic.RingSolver.html#3293" class="Function">`trans</a> <a id="3300" class="Symbol">:</a> <a id="3302" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3307" class="Symbol">→</a> <a id="3309" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3314" class="Symbol">→</a> <a id="3316" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3323" href="Tactic.RingSolver.html#3293" class="Function">`trans</a> <a id="3330" href="Tactic.RingSolver.html#3330" class="Bound">x≈y</a> <a id="3334" href="Tactic.RingSolver.html#3334" class="Bound">y≈z</a> <a id="3338" class="Symbol">=</a> <a id="3340" class="Keyword">quote</a> <a id="3346" href="Relation.Binary.Structures.html#1648" class="Function">trans</a> <a id="3352" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3355" class="Symbol">(</a><a id="3356" class="Number">3</a> <a id="3358" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="3363" href="Tactic.RingSolver.html#3330" class="Bound">x≈y</a> <a id="3367" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3371" href="Tactic.RingSolver.html#3334" class="Bound">y≈z</a> <a id="3375" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3379" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3381" class="Symbol">)</a>

  <a id="3386" class="Comment">-- Normalises each of the fields of the ring operator so we can</a>
  <a id="3452" class="Comment">-- compare the result against the normalised definitions we come</a>
  <a id="3519" class="Comment">-- across when converting the term passed to the macro.</a>
  <a id="RingReflection.getRingOperatorTerms"></a><a id="3577" href="Tactic.RingSolver.html#3577" class="Function">getRingOperatorTerms</a> <a id="3598" class="Symbol">:</a> <a id="3600" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="3603" href="Tactic.RingSolver.html#2566" class="Record">RingOperatorTerms</a>
  <a id="3623" href="Tactic.RingSolver.html#3577" class="Function">getRingOperatorTerms</a> <a id="3644" class="Symbol">=</a> <a id="3646" class="Symbol">⦇</a>
    <a id="3652" href="Tactic.RingSolver.html#2610" class="InductiveConstructor Operator">add⇒</a> <a id="3657" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="3667" class="Symbol">(</a><a id="3668" class="Keyword">quote</a> <a id="3674" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1506" class="Field Operator">_+_</a>  <a id="3679" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3682" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3684" class="Symbol">)</a>
    <a id="3690" href="Tactic.RingSolver.html#2610" class="InductiveConstructor Operator">mul⇒</a> <a id="3695" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="3705" class="Symbol">(</a><a id="3706" class="Keyword">quote</a> <a id="3712" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1548" class="Field Operator">_*_</a>  <a id="3717" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3720" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3722" class="Symbol">)</a>
    <a id="3728" href="Tactic.RingSolver.html#2610" class="InductiveConstructor Operator">pow⇒</a> <a id="3733" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="3743" class="Symbol">(</a><a id="3744" class="Keyword">quote</a> <a id="3750" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2447" class="Function Operator">_^_</a>  <a id="3755" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3758" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3760" class="Symbol">)</a>
    <a id="3766" href="Tactic.RingSolver.html#2610" class="InductiveConstructor Operator">neg⇒</a> <a id="3771" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="3781" class="Symbol">(</a><a id="3782" class="Keyword">quote</a> <a id="3788" class="Symbol">(</a><a id="3789" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1590" class="Field Operator">-_</a><a id="3791" class="Symbol">)</a> <a id="3793" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3796" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3798" class="Symbol">)</a>
    <a id="3804" href="Tactic.RingSolver.html#2610" class="InductiveConstructor Operator">sub⇒</a> <a id="3809" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="3819" class="Symbol">(</a><a id="3820" class="Keyword">quote</a> <a id="3826" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2530" class="Function Operator">_-_</a>  <a id="3831" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="3834" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3836" class="Symbol">)</a>
    <a id="3842" class="Symbol">⦈</a>

<a id="3845" class="Comment">------------------------------------------------------------------------</a>
<a id="3918" class="Comment">-- Reflection utilities for ring solver</a>

<a id="3959" class="Keyword">module</a> <a id="RingSolverReflection"></a><a id="3966" href="Tactic.RingSolver.html#3966" class="Module">RingSolverReflection</a> <a id="3987" class="Symbol">(</a><a id="3988" href="Tactic.RingSolver.html#3988" class="Bound">ring</a> <a id="3993" class="Symbol">:</a> <a id="3995" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3999" class="Symbol">)</a> <a id="4001" class="Symbol">(</a><a id="4002" href="Tactic.RingSolver.html#4002" class="Bound">numberOfVariables</a> <a id="4020" class="Symbol">:</a> <a id="4022" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="4023" class="Symbol">)</a> <a id="4025" class="Keyword">where</a>
  <a id="4033" class="Keyword">open</a> <a id="4038" href="Tactic.RingSolver.html#2770" class="Module">RingReflection</a> <a id="4053" href="Tactic.RingSolver.html#3988" class="Bound">ring</a>

  <a id="RingSolverReflection.`numberOfVariables"></a><a id="4061" href="Tactic.RingSolver.html#4061" class="Function">`numberOfVariables</a> <a id="4080" class="Symbol">:</a> <a id="4082" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4089" href="Tactic.RingSolver.html#4061" class="Function">`numberOfVariables</a> <a id="4108" class="Symbol">=</a> <a id="4110" href="Data.Nat.Reflection.html#653" class="Function">toTerm</a> <a id="4117" href="Tactic.RingSolver.html#4002" class="Bound">numberOfVariables</a>

  <a id="4138" class="Comment">-- This function applies the hidden arguments that the constructors</a>
  <a id="4208" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
  <a id="4281" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
  <a id="4350" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
  <a id="4419" class="Comment">-- make things easier we supply the third because we know it.</a>
  <a id="4483" class="Keyword">infix</a> <a id="4489" class="Number">-1</a> <a id="4492" href="Tactic.RingSolver.html#4499" class="Function Operator">_$ᵉ_</a>
  <a id="RingSolverReflection._$ᵉ_"></a><a id="4499" href="Tactic.RingSolver.html#4499" class="Function Operator">_$ᵉ_</a> <a id="4504" class="Symbol">:</a> <a id="4506" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="4511" class="Symbol">→</a> <a id="4513" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4518" class="Symbol">(</a><a id="4519" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4523" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="4527" class="Symbol">)</a> <a id="4529" class="Symbol">→</a> <a id="4531" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4538" href="Tactic.RingSolver.html#4538" class="Bound">e</a> <a id="4540" href="Tactic.RingSolver.html#4499" class="Function Operator">$ᵉ</a> <a id="4543" href="Tactic.RingSolver.html#4543" class="Bound">xs</a> <a id="4546" class="Symbol">=</a> <a id="4548" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4552" href="Tactic.RingSolver.html#4538" class="Bound">e</a> <a id="4554" class="Symbol">(</a><a id="4555" class="Number">1</a> <a id="4557" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="4562" href="Tactic.RingSolver.html#3121" class="Function">`Carrier</a> <a id="4571" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4575" href="Tactic.RingSolver.html#4061" class="Function">`numberOfVariables</a> <a id="4594" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4598" href="Tactic.RingSolver.html#4543" class="Bound">xs</a><a id="4600" class="Symbol">)</a>

  <a id="4605" class="Comment">-- A constant expression.</a>
  <a id="RingSolverReflection.`Κ"></a><a id="4633" href="Tactic.RingSolver.html#4633" class="Function">`Κ</a> <a id="4636" class="Symbol">:</a> <a id="4638" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4643" class="Symbol">→</a> <a id="4645" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4652" href="Tactic.RingSolver.html#4633" class="Function">`Κ</a> <a id="4655" href="Tactic.RingSolver.html#4655" class="Bound">x</a> <a id="4657" class="Symbol">=</a> <a id="4659" class="Keyword">quote</a> <a id="4665" href="Tactic.RingSolver.Core.Expression.html#558" class="InductiveConstructor">Κ</a> <a id="4667" href="Tactic.RingSolver.html#4499" class="Function Operator">$ᵉ</a> <a id="4670" class="Symbol">(</a><a id="4671" href="Tactic.RingSolver.html#4655" class="Bound">x</a> <a id="4673" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4677" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4679" class="Symbol">)</a>

  <a id="RingSolverReflection.`I"></a><a id="4684" href="Tactic.RingSolver.html#4684" class="Function">`I</a> <a id="4687" class="Symbol">:</a> <a id="4689" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4694" class="Symbol">→</a> <a id="4696" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4703" href="Tactic.RingSolver.html#4684" class="Function">`I</a> <a id="4706" href="Tactic.RingSolver.html#4706" class="Bound">x</a> <a id="4708" class="Symbol">=</a> <a id="4710" class="Keyword">quote</a> <a id="4716" href="Tactic.RingSolver.Core.Expression.html#609" class="InductiveConstructor">Ι</a> <a id="4718" href="Tactic.RingSolver.html#4499" class="Function Operator">$ᵉ</a> <a id="4721" class="Symbol">(</a><a id="4722" href="Tactic.RingSolver.html#4706" class="Bound">x</a> <a id="4724" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4728" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4730" class="Symbol">)</a>

  <a id="4735" class="Keyword">infixl</a> <a id="4742" class="Number">6</a> <a id="4744" href="Tactic.RingSolver.html#4752" class="Function Operator">_`⊜_</a>

  <a id="RingSolverReflection._`⊜_"></a><a id="4752" href="Tactic.RingSolver.html#4752" class="Function Operator">_`⊜_</a> <a id="4757" class="Symbol">:</a> <a id="4759" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4764" class="Symbol">→</a> <a id="4766" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4771" class="Symbol">→</a> <a id="4773" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4780" href="Tactic.RingSolver.html#4780" class="Bound">x</a> <a id="4782" href="Tactic.RingSolver.html#4752" class="Function Operator">`⊜</a> <a id="4785" href="Tactic.RingSolver.html#4785" class="Bound">y</a> <a id="4787" class="Symbol">=</a> <a id="4789" class="Keyword">quote</a> <a id="4795" href="Tactic.RingSolver.NonReflective.html#3343" class="Function Operator">_⊜_</a>  <a id="4800" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="4803" class="Symbol">(</a><a id="4804" href="Tactic.RingSolver.html#4061" class="Function">`numberOfVariables</a> <a id="4823" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4827" href="Tactic.RingSolver.html#4780" class="Bound">x</a> <a id="4829" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4833" href="Tactic.RingSolver.html#4785" class="Bound">y</a> <a id="4835" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4839" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4841" class="Symbol">)</a>

  <a id="RingSolverReflection.`correct"></a><a id="4846" href="Tactic.RingSolver.html#4846" class="Function">`correct</a> <a id="4855" class="Symbol">:</a> <a id="4857" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4862" class="Symbol">→</a> <a id="4864" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4869" class="Symbol">→</a> <a id="4871" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4878" href="Tactic.RingSolver.html#4846" class="Function">`correct</a> <a id="4887" href="Tactic.RingSolver.html#4887" class="Bound">x</a> <a id="4889" href="Tactic.RingSolver.html#4889" class="Bound">ρ</a> <a id="4891" class="Symbol">=</a> <a id="4893" class="Keyword">quote</a> <a id="4899" href="Tactic.RingSolver.NonReflective.html#2317" class="Function">Ops.correct</a> <a id="4911" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="4914" class="Symbol">(</a><a id="4915" class="Number">1</a> <a id="4917" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="4922" href="Tactic.RingSolver.html#4887" class="Bound">x</a> <a id="4924" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4928" href="Tactic.RingSolver.html#4889" class="Bound">ρ</a> <a id="4930" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4934" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4936" class="Symbol">)</a>

  <a id="RingSolverReflection.`solver"></a><a id="4941" href="Tactic.RingSolver.html#4941" class="Function">`solver</a> <a id="4949" class="Symbol">:</a> <a id="4951" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4956" class="Symbol">→</a> <a id="4958" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4963" class="Symbol">→</a> <a id="4965" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4972" href="Tactic.RingSolver.html#4941" class="Function">`solver</a> <a id="4980" href="Tactic.RingSolver.html#4980" class="Bound">`f</a> <a id="4983" href="Tactic.RingSolver.html#4983" class="Bound">`eq</a> <a id="4987" class="Symbol">=</a> <a id="4989" class="Keyword">quote</a> <a id="4995" href="Tactic.RingSolver.html#1345" class="Function">solver</a> <a id="5002" href="Tactic.RingSolver.html#3041" class="Function Operator">$ʳ</a> <a id="5005" class="Symbol">(</a><a id="5006" href="Tactic.RingSolver.html#4061" class="Function">`numberOfVariables</a> <a id="5025" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5029" href="Tactic.RingSolver.html#4980" class="Bound">`f</a> <a id="5032" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5036" href="Tactic.RingSolver.html#4983" class="Bound">`eq</a> <a id="5040" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5044" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="5046" class="Symbol">)</a>

  <a id="5051" class="Comment">-- Converts the raw terms provided by the macro into the `Expr`s</a>
  <a id="5118" class="Comment">-- used internally by the solver.</a>
  <a id="5154" class="Comment">--</a>
  <a id="5159" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
  <a id="5225" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
  <a id="5288" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
  <a id="5354" class="Comment">-- might look for its constructors: however, we want to deal with</a>
  <a id="5422" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
  <a id="5489" class="Comment">-- Term type contained type information we might be able to</a>
  <a id="5551" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
  <a id="5592" class="Comment">--</a>
  <a id="5597" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
  <a id="5666" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
  <a id="5734" class="Comment">-- will just assume that it has a constant expression.</a>
  <a id="RingSolverReflection.convertTerm"></a><a id="5791" href="Tactic.RingSolver.html#5791" class="Function">convertTerm</a> <a id="5803" class="Symbol">:</a> <a id="5805" href="Tactic.RingSolver.html#2566" class="Record">RingOperatorTerms</a> <a id="5823" class="Symbol">→</a> <a id="5825" href="Tactic.RingSolver.html#1588" class="Function">VarMap</a> <a id="5832" class="Symbol">→</a> <a id="5834" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5839" class="Symbol">→</a> <a id="5841" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="5844" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5851" href="Tactic.RingSolver.html#5791" class="Function">convertTerm</a> <a id="5863" href="Tactic.RingSolver.html#5863" class="Bound">operatorTerms</a> <a id="5877" href="Tactic.RingSolver.html#5877" class="Bound">varMap</a> <a id="5884" class="Symbol">=</a> <a id="5886" href="Tactic.RingSolver.html#5963" class="Function">convert</a>
    <a id="5898" class="Keyword">where</a>
    <a id="5908" class="Keyword">open</a> <a id="5913" href="Tactic.RingSolver.html#2566" class="Module">RingOperatorTerms</a> <a id="5931" href="Tactic.RingSolver.html#5863" class="Bound">operatorTerms</a>

    <a id="5950" class="Keyword">mutual</a>
      <a id="5963" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="5971" class="Symbol">:</a> <a id="5973" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5978" class="Symbol">→</a> <a id="5980" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="5983" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="5994" class="Comment">-- First try and match directly against the fields</a>
      <a id="6051" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="6059" class="Symbol">(</a><a id="6060" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6064" class="Symbol">(</a><a id="6065" class="Keyword">quote</a> <a id="6071" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1506" class="Field Operator">_+_</a><a id="6074" class="Symbol">)</a> <a id="6076" href="Tactic.RingSolver.html#6076" class="Bound">xs</a><a id="6078" class="Symbol">)</a> <a id="6080" class="Symbol">=</a> <a id="6082" href="Tactic.RingSolver.html#7050" class="Function">convertOp₂</a> <a id="6093" class="Symbol">(</a><a id="6094" class="Keyword">quote</a> <a id="6100" href="Tactic.RingSolver.Core.Expression.html#660" class="InductiveConstructor Operator">_⊕_</a><a id="6103" class="Symbol">)</a> <a id="6105" href="Tactic.RingSolver.html#6076" class="Bound">xs</a>
      <a id="6114" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="6122" class="Symbol">(</a><a id="6123" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6127" class="Symbol">(</a><a id="6128" class="Keyword">quote</a> <a id="6134" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1548" class="Field Operator">_*_</a><a id="6137" class="Symbol">)</a> <a id="6139" href="Tactic.RingSolver.html#6139" class="Bound">xs</a><a id="6141" class="Symbol">)</a> <a id="6143" class="Symbol">=</a> <a id="6145" href="Tactic.RingSolver.html#7050" class="Function">convertOp₂</a> <a id="6156" class="Symbol">(</a><a id="6157" class="Keyword">quote</a> <a id="6163" href="Tactic.RingSolver.Core.Expression.html#711" class="InductiveConstructor Operator">_⊗_</a><a id="6166" class="Symbol">)</a> <a id="6168" href="Tactic.RingSolver.html#6139" class="Bound">xs</a>
      <a id="6177" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="6185" class="Symbol">(</a><a id="6186" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6190" class="Symbol">(</a><a id="6191" class="Keyword">quote</a>  <a id="6198" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1590" class="Field Operator">-_</a><a id="6200" class="Symbol">)</a> <a id="6202" href="Tactic.RingSolver.html#6202" class="Bound">xs</a><a id="6204" class="Symbol">)</a> <a id="6206" class="Symbol">=</a> <a id="6208" href="Tactic.RingSolver.html#7333" class="Function">convertOp₁</a> <a id="6219" class="Symbol">(</a><a id="6220" class="Keyword">quote</a>  <a id="6227" href="Tactic.RingSolver.Core.Expression.html#825" class="InductiveConstructor Operator">⊝_</a><a id="6229" class="Symbol">)</a> <a id="6231" href="Tactic.RingSolver.html#6202" class="Bound">xs</a>
      <a id="6240" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="6248" class="Symbol">(</a><a id="6249" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6253" class="Symbol">(</a><a id="6254" class="Keyword">quote</a> <a id="6260" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2447" class="Function Operator">_^_</a><a id="6263" class="Symbol">)</a> <a id="6265" href="Tactic.RingSolver.html#6265" class="Bound">xs</a><a id="6267" class="Symbol">)</a> <a id="6269" class="Symbol">=</a> <a id="6271" href="Tactic.RingSolver.html#7568" class="Function">convertExp</a> <a id="6282" href="Tactic.RingSolver.html#6265" class="Bound">xs</a>
      <a id="6291" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="6299" class="Symbol">(</a><a id="6300" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6304" class="Symbol">(</a><a id="6305" class="Keyword">quote</a> <a id="6311" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2530" class="Function Operator">_-_</a><a id="6314" class="Symbol">)</a> <a id="6316" href="Tactic.RingSolver.html#6316" class="Bound">xs</a><a id="6318" class="Symbol">)</a> <a id="6320" class="Symbol">=</a> <a id="6322" href="Tactic.RingSolver.html#7815" class="Function">convertSub</a> <a id="6333" href="Tactic.RingSolver.html#6316" class="Bound">xs</a>
      <a id="6342" class="Comment">-- Other definitions the underlying implementation of the ring&#39;s fields</a>
      <a id="6420" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="6428" class="Symbol">(</a><a id="6429" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6433" href="Tactic.RingSolver.html#6433" class="Bound">nm</a>          <a id="6445" href="Tactic.RingSolver.html#6445" class="Bound">xs</a><a id="6447" class="Symbol">)</a> <a id="6449" class="Symbol">=</a> <a id="6451" href="Tactic.RingSolver.html#8112" class="Function">convertUnknownName</a> <a id="6470" href="Tactic.RingSolver.html#6433" class="Bound">nm</a> <a id="6473" href="Tactic.RingSolver.html#6445" class="Bound">xs</a>
      <a id="6482" class="Comment">-- Variables</a>
      <a id="6501" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="6509" href="Tactic.RingSolver.html#6509" class="Bound">v</a><a id="6510" class="Symbol">@(</a><a id="6512" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="6516" href="Tactic.RingSolver.html#6516" class="Bound">x</a> <a id="6518" class="Symbol">_)</a>          <a id="6530" class="Symbol">=</a> <a id="6532" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="6537" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6539" href="Data.Maybe.Base.html#1546" class="Function">fromMaybe</a> <a id="6549" class="Symbol">(</a><a id="6550" href="Tactic.RingSolver.html#4633" class="Function">`Κ</a> <a id="6553" href="Tactic.RingSolver.html#6509" class="Bound">v</a><a id="6554" class="Symbol">)</a> <a id="6556" class="Symbol">(</a><a id="6557" href="Tactic.RingSolver.html#5877" class="Bound">varMap</a> <a id="6564" href="Tactic.RingSolver.html#6516" class="Bound">x</a><a id="6565" class="Symbol">)</a>
      <a id="6573" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
      <a id="6627" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="6635" class="Symbol">(</a><a id="6636" href="Data.Nat.Reflection.html#616" class="InductiveConstructor">`suc</a> <a id="6641" href="Tactic.RingSolver.html#6641" class="Bound">x</a><a id="6642" class="Symbol">)</a>             <a id="6656" class="Symbol">=</a> <a id="6658" href="Tactic.RingSolver.html#8633" class="Function">convertSuc</a> <a id="6669" href="Tactic.RingSolver.html#6641" class="Bound">x</a>
      <a id="6677" class="Comment">-- Otherwise we&#39;re forced to treat it as a constant</a>
      <a id="6735" href="Tactic.RingSolver.html#5963" class="CatchallClause Function">convert</a><a id="6742" class="CatchallClause"> </a><a id="6743" href="Tactic.RingSolver.html#6743" class="CatchallClause Bound">t</a>                    <a id="6764" class="Symbol">=</a> <a id="6766" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="6771" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6773" href="Tactic.RingSolver.html#4633" class="Function">`Κ</a> <a id="6776" href="Tactic.RingSolver.html#6743" class="Bound">t</a>

      <a id="6785" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
      <a id="6854" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
      <a id="6924" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
      <a id="6993" class="Comment">-- by just taking the last two explicit arguments.</a>
      <a id="7050" href="Tactic.RingSolver.html#7050" class="Function">convertOp₂</a> <a id="7061" class="Symbol">:</a> <a id="7063" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="7068" class="Symbol">→</a> <a id="7070" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7075" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7080" class="Symbol">→</a> <a id="7082" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7085" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="7096" href="Tactic.RingSolver.html#7050" class="Function">convertOp₂</a> <a id="7107" href="Tactic.RingSolver.html#7107" class="Bound">nm</a> <a id="7110" class="Symbol">(</a><a id="7111" href="Tactic.RingSolver.html#7111" class="Bound">x</a> <a id="7113" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7117" href="Tactic.RingSolver.html#7117" class="Bound">y</a> <a id="7119" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7123" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7125" class="Symbol">)</a> <a id="7127" class="Symbol">=</a> <a id="7129" class="Keyword">do</a>
        <a id="7140" href="Tactic.RingSolver.html#7140" class="Bound">x&#39;</a> <a id="7143" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7145" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="7153" href="Tactic.RingSolver.html#7111" class="Bound">x</a>
        <a id="7163" href="Tactic.RingSolver.html#7163" class="Bound">y&#39;</a> <a id="7166" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7168" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="7176" href="Tactic.RingSolver.html#7117" class="Bound">y</a>
        <a id="7186" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7191" class="Symbol">(</a><a id="7192" href="Tactic.RingSolver.html#7107" class="Bound">nm</a> <a id="7195" href="Tactic.RingSolver.html#4499" class="Function Operator">$ᵉ</a> <a id="7198" class="Symbol">(</a><a id="7199" href="Tactic.RingSolver.html#7140" class="Bound">x&#39;</a> <a id="7202" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7206" href="Tactic.RingSolver.html#7163" class="Bound">y&#39;</a> <a id="7209" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7213" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7215" class="Symbol">))</a>
      <a id="7224" href="Tactic.RingSolver.html#7050" class="CatchallClause Function">convertOp₂</a><a id="7234" class="CatchallClause"> </a><a id="7235" href="Tactic.RingSolver.html#7235" class="CatchallClause Bound">nm</a><a id="7237" class="CatchallClause"> </a><a id="7238" class="CatchallClause Symbol">(</a><a id="7239" href="Tactic.RingSolver.html#7239" class="CatchallClause Bound">x</a><a id="7240" class="CatchallClause"> </a><a id="7241" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7242" class="CatchallClause"> </a><a id="7243" href="Tactic.RingSolver.html#7243" class="CatchallClause Bound">xs</a><a id="7245" class="CatchallClause Symbol">)</a>         <a id="7255" class="Symbol">=</a> <a id="7257" href="Tactic.RingSolver.html#7050" class="Function">convertOp₂</a> <a id="7268" href="Tactic.RingSolver.html#7235" class="Bound">nm</a> <a id="7271" href="Tactic.RingSolver.html#7243" class="Bound">xs</a>
      <a id="7280" href="Tactic.RingSolver.html#7050" class="CatchallClause Function">convertOp₂</a><a id="7290" class="CatchallClause"> </a><a id="7291" class="CatchallClause Symbol">_</a><a id="7292" class="CatchallClause">  </a><a id="7294" class="CatchallClause Symbol">_</a>                <a id="7311" class="Symbol">=</a> <a id="7313" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7318" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

      <a id="7333" href="Tactic.RingSolver.html#7333" class="Function">convertOp₁</a> <a id="7344" class="Symbol">:</a> <a id="7346" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="7351" class="Symbol">→</a> <a id="7353" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7358" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7363" class="Symbol">→</a> <a id="7365" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7368" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="7379" href="Tactic.RingSolver.html#7333" class="Function">convertOp₁</a> <a id="7390" href="Tactic.RingSolver.html#7390" class="Bound">nm</a> <a id="7393" class="Symbol">(</a><a id="7394" href="Tactic.RingSolver.html#7394" class="Bound">x</a> <a id="7396" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7400" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7402" class="Symbol">)</a> <a id="7404" class="Symbol">=</a> <a id="7406" class="Keyword">do</a>
        <a id="7417" href="Tactic.RingSolver.html#7417" class="Bound">x&#39;</a> <a id="7420" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7422" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="7430" href="Tactic.RingSolver.html#7394" class="Bound">x</a>
        <a id="7440" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7445" class="Symbol">(</a><a id="7446" href="Tactic.RingSolver.html#7390" class="Bound">nm</a> <a id="7449" href="Tactic.RingSolver.html#4499" class="Function Operator">$ᵉ</a> <a id="7452" class="Symbol">(</a><a id="7453" href="Tactic.RingSolver.html#7417" class="Bound">x&#39;</a> <a id="7456" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7460" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7462" class="Symbol">))</a>
      <a id="7471" href="Tactic.RingSolver.html#7333" class="CatchallClause Function">convertOp₁</a><a id="7481" class="CatchallClause"> </a><a id="7482" href="Tactic.RingSolver.html#7482" class="CatchallClause Bound">nm</a><a id="7484" class="CatchallClause"> </a><a id="7485" class="CatchallClause Symbol">(</a><a id="7486" href="Tactic.RingSolver.html#7486" class="CatchallClause Bound">x</a><a id="7487" class="CatchallClause"> </a><a id="7488" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7489" class="CatchallClause"> </a><a id="7490" href="Tactic.RingSolver.html#7490" class="CatchallClause Bound">xs</a><a id="7492" class="CatchallClause Symbol">)</a>   <a id="7496" class="Symbol">=</a> <a id="7498" href="Tactic.RingSolver.html#7333" class="Function">convertOp₁</a> <a id="7509" href="Tactic.RingSolver.html#7482" class="Bound">nm</a> <a id="7512" href="Tactic.RingSolver.html#7490" class="Bound">xs</a>
      <a id="7521" href="Tactic.RingSolver.html#7333" class="CatchallClause Function">convertOp₁</a><a id="7531" class="CatchallClause"> </a><a id="7532" class="CatchallClause Symbol">_</a><a id="7533" class="CatchallClause">  </a><a id="7535" class="CatchallClause Symbol">_</a>          <a id="7546" class="Symbol">=</a> <a id="7548" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7553" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

      <a id="7568" href="Tactic.RingSolver.html#7568" class="Function">convertExp</a> <a id="7579" class="Symbol">:</a> <a id="7581" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7586" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7591" class="Symbol">→</a> <a id="7593" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7596" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="7607" href="Tactic.RingSolver.html#7568" class="Function">convertExp</a> <a id="7618" class="Symbol">(</a><a id="7619" href="Tactic.RingSolver.html#7619" class="Bound">x</a> <a id="7621" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7625" href="Tactic.RingSolver.html#7625" class="Bound">y</a> <a id="7627" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7631" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7633" class="Symbol">)</a> <a id="7635" class="Symbol">=</a> <a id="7637" class="Keyword">do</a>
        <a id="7648" href="Tactic.RingSolver.html#7648" class="Bound">x&#39;</a> <a id="7651" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7653" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="7661" href="Tactic.RingSolver.html#7619" class="Bound">x</a>
        <a id="7671" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7676" class="Symbol">(</a><a id="7677" class="Keyword">quote</a> <a id="7683" href="Tactic.RingSolver.Core.Expression.html#768" class="InductiveConstructor Operator">_⊛_</a> <a id="7687" href="Tactic.RingSolver.html#4499" class="Function Operator">$ᵉ</a> <a id="7690" class="Symbol">(</a><a id="7691" href="Tactic.RingSolver.html#7648" class="Bound">x&#39;</a> <a id="7694" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7698" href="Tactic.RingSolver.html#7625" class="Bound">y</a> <a id="7700" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7704" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7706" class="Symbol">))</a>
      <a id="7715" href="Tactic.RingSolver.html#7568" class="CatchallClause Function">convertExp</a><a id="7725" class="CatchallClause"> </a><a id="7726" class="CatchallClause Symbol">(</a><a id="7727" href="Tactic.RingSolver.html#7727" class="CatchallClause Bound">x</a><a id="7728" class="CatchallClause"> </a><a id="7729" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7730" class="CatchallClause"> </a><a id="7731" href="Tactic.RingSolver.html#7731" class="CatchallClause Bound">xs</a><a id="7733" class="CatchallClause Symbol">)</a>         <a id="7743" class="Symbol">=</a> <a id="7745" href="Tactic.RingSolver.html#7568" class="Function">convertExp</a> <a id="7756" href="Tactic.RingSolver.html#7731" class="Bound">xs</a>
      <a id="7765" href="Tactic.RingSolver.html#7568" class="CatchallClause Function">convertExp</a><a id="7775" class="CatchallClause"> </a><a id="7776" class="CatchallClause Symbol">_</a>                <a id="7793" class="Symbol">=</a> <a id="7795" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7800" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

      <a id="7815" href="Tactic.RingSolver.html#7815" class="Function">convertSub</a> <a id="7826" class="Symbol">:</a> <a id="7828" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7833" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7838" class="Symbol">→</a> <a id="7840" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7843" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="7854" href="Tactic.RingSolver.html#7815" class="Function">convertSub</a> <a id="7865" class="Symbol">(</a><a id="7866" href="Tactic.RingSolver.html#7866" class="Bound">x</a> <a id="7868" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7872" href="Tactic.RingSolver.html#7872" class="Bound">y</a> <a id="7874" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7878" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7880" class="Symbol">)</a> <a id="7882" class="Symbol">=</a> <a id="7884" class="Keyword">do</a>
        <a id="7895" href="Tactic.RingSolver.html#7895" class="Bound">x&#39;</a>  <a id="7899" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7901" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="7909" href="Tactic.RingSolver.html#7866" class="Bound">x</a>
        <a id="7919" href="Tactic.RingSolver.html#7919" class="Bound">-y&#39;</a> <a id="7923" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7925" href="Tactic.RingSolver.html#7333" class="Function">convertOp₁</a> <a id="7936" class="Symbol">(</a><a id="7937" class="Keyword">quote</a> <a id="7943" class="Symbol">(</a><a id="7944" href="Tactic.RingSolver.Core.Expression.html#825" class="InductiveConstructor Operator">⊝_</a><a id="7946" class="Symbol">))</a> <a id="7949" class="Symbol">(</a><a id="7950" href="Tactic.RingSolver.html#7872" class="Bound">y</a> <a id="7952" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7956" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7958" class="Symbol">)</a>
        <a id="7968" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7973" class="Symbol">(</a><a id="7974" class="Keyword">quote</a> <a id="7980" href="Tactic.RingSolver.Core.Expression.html#660" class="InductiveConstructor Operator">_⊕_</a> <a id="7984" href="Tactic.RingSolver.html#4499" class="Function Operator">$ᵉ</a> <a id="7987" href="Tactic.RingSolver.html#7895" class="Bound">x&#39;</a> <a id="7990" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7994" href="Tactic.RingSolver.html#7919" class="Bound">-y&#39;</a> <a id="7998" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8002" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8004" class="Symbol">)</a>
      <a id="8012" href="Tactic.RingSolver.html#7815" class="CatchallClause Function">convertSub</a><a id="8022" class="CatchallClause"> </a><a id="8023" class="CatchallClause Symbol">(</a><a id="8024" href="Tactic.RingSolver.html#8024" class="CatchallClause Bound">x</a><a id="8025" class="CatchallClause"> </a><a id="8026" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8027" class="CatchallClause"> </a><a id="8028" href="Tactic.RingSolver.html#8028" class="CatchallClause Bound">xs</a><a id="8030" class="CatchallClause Symbol">)</a>         <a id="8040" class="Symbol">=</a> <a id="8042" href="Tactic.RingSolver.html#7815" class="Function">convertSub</a> <a id="8053" href="Tactic.RingSolver.html#8028" class="Bound">xs</a>
      <a id="8062" href="Tactic.RingSolver.html#7815" class="CatchallClause Function">convertSub</a><a id="8072" class="CatchallClause"> </a><a id="8073" class="CatchallClause Symbol">_</a>                <a id="8090" class="Symbol">=</a> <a id="8092" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="8097" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

      <a id="8112" href="Tactic.RingSolver.html#8112" class="Function">convertUnknownName</a> <a id="8131" class="Symbol">:</a> <a id="8133" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="8138" class="Symbol">→</a> <a id="8140" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="8145" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8150" class="Symbol">→</a> <a id="8152" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="8155" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="8166" href="Tactic.RingSolver.html#8112" class="Function">convertUnknownName</a> <a id="8185" href="Tactic.RingSolver.html#8185" class="Bound">nm</a> <a id="8188" href="Tactic.RingSolver.html#8188" class="Bound">xs</a> <a id="8191" class="Symbol">=</a> <a id="8193" class="Keyword">do</a>
        <a id="8204" href="Tactic.RingSolver.html#8204" class="Bound">nameTerm</a> <a id="8213" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="8215" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="8225" class="Symbol">(</a><a id="8226" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8230" href="Tactic.RingSolver.html#8185" class="Bound">nm</a> <a id="8233" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8235" class="Symbol">)</a>
        <a id="8245" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8248" class="Symbol">(</a><a id="8249" href="Tactic.RingSolver.html#8204" class="Bound">nameTerm</a> <a id="8258" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8262" href="Tactic.RingSolver.html#2648" class="Function">add</a><a id="8265" class="Symbol">)</a> <a id="8267" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8272" href="Tactic.RingSolver.html#7050" class="Function">convertOp₂</a> <a id="8283" class="Symbol">(</a><a id="8284" class="Keyword">quote</a> <a id="8290" href="Tactic.RingSolver.Core.Expression.html#660" class="InductiveConstructor Operator">_⊕_</a><a id="8293" class="Symbol">)</a> <a id="8295" href="Tactic.RingSolver.html#8188" class="Bound">xs</a> <a id="8298" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
          <a id="8313" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8316" class="Symbol">(</a><a id="8317" href="Tactic.RingSolver.html#8204" class="Bound">nameTerm</a> <a id="8326" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8330" href="Tactic.RingSolver.html#2652" class="Function">mul</a><a id="8333" class="Symbol">)</a> <a id="8335" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8340" href="Tactic.RingSolver.html#7050" class="Function">convertOp₂</a> <a id="8351" class="Symbol">(</a><a id="8352" class="Keyword">quote</a> <a id="8358" href="Tactic.RingSolver.Core.Expression.html#711" class="InductiveConstructor Operator">_⊗_</a><a id="8361" class="Symbol">)</a> <a id="8363" href="Tactic.RingSolver.html#8188" class="Bound">xs</a> <a id="8366" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
            <a id="8383" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8386" class="Symbol">(</a><a id="8387" href="Tactic.RingSolver.html#8204" class="Bound">nameTerm</a> <a id="8396" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8400" href="Tactic.RingSolver.html#2660" class="Function">neg</a><a id="8403" class="Symbol">)</a> <a id="8405" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8410" href="Tactic.RingSolver.html#7333" class="Function">convertOp₁</a> <a id="8421" class="Symbol">(</a><a id="8422" class="Keyword">quote</a> <a id="8428" href="Tactic.RingSolver.Core.Expression.html#825" class="InductiveConstructor Operator">⊝_</a><a id="8430" class="Symbol">)</a>  <a id="8433" href="Tactic.RingSolver.html#8188" class="Bound">xs</a> <a id="8436" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
              <a id="8455" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8458" class="Symbol">(</a><a id="8459" href="Tactic.RingSolver.html#8204" class="Bound">nameTerm</a> <a id="8468" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8472" href="Tactic.RingSolver.html#2656" class="Function">pow</a><a id="8475" class="Symbol">)</a> <a id="8477" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8482" href="Tactic.RingSolver.html#7568" class="Function">convertExp</a>             <a id="8505" href="Tactic.RingSolver.html#8188" class="Bound">xs</a> <a id="8508" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
                <a id="8529" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8532" class="Symbol">(</a><a id="8533" href="Tactic.RingSolver.html#8204" class="Bound">nameTerm</a> <a id="8542" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8546" href="Tactic.RingSolver.html#2664" class="Function">sub</a><a id="8549" class="Symbol">)</a> <a id="8551" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8556" href="Tactic.RingSolver.html#7815" class="Function">convertSub</a>            <a id="8578" href="Tactic.RingSolver.html#8188" class="Bound">xs</a> <a id="8581" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
                  <a id="8604" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="8609" class="Symbol">(</a><a id="8610" href="Tactic.RingSolver.html#4633" class="Function">`Κ</a> <a id="8613" class="Symbol">(</a><a id="8614" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8618" href="Tactic.RingSolver.html#8185" class="Bound">nm</a> <a id="8621" href="Tactic.RingSolver.html#8188" class="Bound">xs</a><a id="8623" class="Symbol">))</a>

      <a id="8633" href="Tactic.RingSolver.html#8633" class="Function">convertSuc</a> <a id="8644" class="Symbol">:</a> <a id="8646" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8651" class="Symbol">→</a> <a id="8653" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="8656" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="8667" href="Tactic.RingSolver.html#8633" class="Function">convertSuc</a> <a id="8678" href="Tactic.RingSolver.html#8678" class="Bound">x</a> <a id="8680" class="Symbol">=</a> <a id="8682" class="Keyword">do</a> <a id="8685" href="Tactic.RingSolver.html#8685" class="Bound">x&#39;</a> <a id="8688" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="8690" href="Tactic.RingSolver.html#5963" class="Function">convert</a> <a id="8698" href="Tactic.RingSolver.html#8678" class="Bound">x</a><a id="8699" class="Symbol">;</a> <a id="8701" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="8706" class="Symbol">(</a><a id="8707" class="Keyword">quote</a> <a id="8713" href="Tactic.RingSolver.Core.Expression.html#660" class="InductiveConstructor Operator">_⊕_</a> <a id="8717" href="Tactic.RingSolver.html#4499" class="Function Operator">$ᵉ</a> <a id="8720" class="Symbol">(</a><a id="8721" href="Tactic.RingSolver.html#4633" class="Function">`Κ</a> <a id="8724" class="Symbol">(</a><a id="8725" href="Data.Nat.Reflection.html#653" class="Function">toTerm</a> <a id="8732" class="Number">1</a><a id="8733" class="Symbol">)</a> <a id="8735" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8739" href="Tactic.RingSolver.html#8685" class="Bound">x&#39;</a> <a id="8742" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8746" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8748" class="Symbol">))</a>

<a id="8752" class="Comment">------------------------------------------------------------------------</a>
<a id="8825" class="Comment">-- Macros</a>
<a id="8835" class="Comment">------------------------------------------------------------------------</a>
<a id="8908" class="Comment">-- Quantified macro</a>

<a id="8929" class="Keyword">open</a> <a id="8934" href="Tactic.RingSolver.html#2770" class="Module">RingReflection</a>
<a id="8949" class="Keyword">open</a> <a id="8954" href="Tactic.RingSolver.html#3966" class="Module">RingSolverReflection</a>

<a id="malformedForallTypeError"></a><a id="8976" href="Tactic.RingSolver.html#8976" class="Function">malformedForallTypeError</a> <a id="9001" class="Symbol">:</a> <a id="9003" class="Symbol">∀</a> <a id="9005" class="Symbol">{</a><a id="9006" href="Tactic.RingSolver.html#9006" class="Bound">a</a><a id="9007" class="Symbol">}</a> <a id="9009" class="Symbol">{</a><a id="9010" href="Tactic.RingSolver.html#9010" class="Bound">A</a> <a id="9012" class="Symbol">:</a> <a id="9014" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="9018" href="Tactic.RingSolver.html#9006" class="Bound">a</a><a id="9019" class="Symbol">}</a> <a id="9021" class="Symbol">→</a> <a id="9023" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9028" class="Symbol">→</a> <a id="9030" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="9033" href="Tactic.RingSolver.html#9010" class="Bound">A</a>
<a id="9035" href="Tactic.RingSolver.html#8976" class="Function">malformedForallTypeError</a> <a id="9060" href="Tactic.RingSolver.html#9060" class="Bound">found</a> <a id="9066" class="Symbol">=</a> <a id="9068" href="Agda.Builtin.Reflection.html#8830" class="Postulate">typeError</a>
  <a id="9080" class="Symbol">(</a> <a id="9082" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="9089" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="9118" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9120" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="9127" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a>
  <a id="9187" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9189" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="9196" class="String">&quot;Instead: &quot;</a>
  <a id="9210" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9212" href="Agda.Builtin.Reflection.html#8269" class="InductiveConstructor">termErr</a> <a id="9220" href="Tactic.RingSolver.html#9060" class="Bound">found</a>
  <a id="9228" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9230" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9232" class="Symbol">)</a>

<a id="quantifiedVarMap"></a><a id="9235" href="Tactic.RingSolver.html#9235" class="Function">quantifiedVarMap</a> <a id="9252" class="Symbol">:</a> <a id="9254" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="9256" class="Symbol">→</a> <a id="9258" href="Tactic.RingSolver.html#1588" class="Function">VarMap</a>
<a id="9265" href="Tactic.RingSolver.html#9235" class="Function">quantifiedVarMap</a> <a id="9282" href="Tactic.RingSolver.html#9282" class="Bound">numVars</a> <a id="9290" href="Tactic.RingSolver.html#9290" class="Bound">i</a> <a id="9292" class="Symbol">=</a>
  <a id="9296" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="9299" href="Tactic.RingSolver.html#9290" class="Bound">i</a> <a id="9301" href="Data.Nat.Base.html#1463" class="Primitive Operator">&lt;ᵇ</a> <a id="9304" href="Tactic.RingSolver.html#9282" class="Bound">numVars</a>
    <a id="9316" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="9321" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="9326" class="Symbol">(</a><a id="9327" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="9331" href="Tactic.RingSolver.html#9290" class="Bound">i</a> <a id="9333" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9335" class="Symbol">)</a>
    <a id="9341" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="9346" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

<a id="constructCallToSolver"></a><a id="9355" href="Tactic.RingSolver.html#9355" class="Function">constructCallToSolver</a> <a id="9377" class="Symbol">:</a> <a id="9379" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9384" class="Symbol">→</a> <a id="9386" href="Tactic.RingSolver.html#2566" class="Record">RingOperatorTerms</a> <a id="9404" class="Symbol">→</a> <a id="9406" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="9411" href="Agda.Builtin.String.html#335" class="Postulate">String</a> <a id="9418" class="Symbol">→</a> <a id="9420" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9425" class="Symbol">→</a> <a id="9427" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9432" class="Symbol">→</a> <a id="9434" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="9437" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="9442" href="Tactic.RingSolver.html#9355" class="Function">constructCallToSolver</a> <a id="9464" href="Tactic.RingSolver.html#9464" class="Bound">`ring</a> <a id="9470" href="Tactic.RingSolver.html#9470" class="Bound">opNames</a> <a id="9478" href="Tactic.RingSolver.html#9478" class="Bound">variables</a> <a id="9488" href="Tactic.RingSolver.html#9488" class="Bound">`lhs</a> <a id="9493" href="Tactic.RingSolver.html#9493" class="Bound">`rhs</a> <a id="9498" class="Symbol">=</a> <a id="9500" class="Keyword">do</a>
  <a id="9505" href="Tactic.RingSolver.html#9505" class="Bound">`lhsExpr</a> <a id="9514" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9516" href="Tactic.RingSolver.html#9783" class="Function">conv</a> <a id="9521" href="Tactic.RingSolver.html#9488" class="Bound">`lhs</a>
  <a id="9528" href="Tactic.RingSolver.html#9528" class="Bound">`rhsExpr</a> <a id="9537" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9539" href="Tactic.RingSolver.html#9783" class="Function">conv</a> <a id="9544" href="Tactic.RingSolver.html#9493" class="Bound">`rhs</a>

  <a id="9552" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="9557" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="9559" href="Tactic.RingSolver.html#4941" class="Function">`solver</a> <a id="9567" href="Tactic.RingSolver.html#9464" class="Bound">`ring</a> <a id="9573" href="Tactic.RingSolver.html#9734" class="Function">numVars</a>
                    <a id="9601" class="Symbol">(</a><a id="9602" href="Reflection.AST.Term.html#3860" class="Function">prependVLams</a> <a id="9615" href="Tactic.RingSolver.html#9478" class="Bound">variables</a> <a id="9625" class="Symbol">(</a><a id="9626" href="Tactic.RingSolver.html#4752" class="Function Operator">_`⊜_</a> <a id="9631" href="Tactic.RingSolver.html#9464" class="Bound">`ring</a> <a id="9637" href="Tactic.RingSolver.html#9734" class="Function">numVars</a> <a id="9645" href="Tactic.RingSolver.html#9505" class="Bound">`lhsExpr</a> <a id="9654" href="Tactic.RingSolver.html#9528" class="Bound">`rhsExpr</a><a id="9662" class="Symbol">))</a>
                    <a id="9685" class="Symbol">(</a><a id="9686" href="Reflection.AST.Term.html#3762" class="Function">prependHLams</a> <a id="9699" href="Tactic.RingSolver.html#9478" class="Bound">variables</a> <a id="9709" class="Symbol">(</a><a id="9710" href="Tactic.RingSolver.html#3173" class="Function">`refl</a> <a id="9716" href="Tactic.RingSolver.html#9464" class="Bound">`ring</a><a id="9721" class="Symbol">))</a>
  <a id="9726" class="Keyword">where</a>
  <a id="9734" href="Tactic.RingSolver.html#9734" class="Function">numVars</a> <a id="9742" class="Symbol">:</a> <a id="9744" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="9748" href="Tactic.RingSolver.html#9734" class="Function">numVars</a> <a id="9756" class="Symbol">=</a> <a id="9758" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="9770" href="Tactic.RingSolver.html#9478" class="Bound">variables</a>

  <a id="9783" href="Tactic.RingSolver.html#9783" class="Function">conv</a> <a id="9788" class="Symbol">:</a> <a id="9790" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9795" class="Symbol">→</a> <a id="9797" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="9800" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="9807" href="Tactic.RingSolver.html#9783" class="Function">conv</a> <a id="9812" class="Symbol">=</a> <a id="9814" href="Tactic.RingSolver.html#5791" class="Function">convertTerm</a> <a id="9826" href="Tactic.RingSolver.html#9464" class="Bound">`ring</a> <a id="9832" href="Tactic.RingSolver.html#9734" class="Function">numVars</a> <a id="9840" href="Tactic.RingSolver.html#9470" class="Bound">opNames</a> <a id="9848" class="Symbol">(</a><a id="9849" href="Tactic.RingSolver.html#9235" class="Function">quantifiedVarMap</a> <a id="9866" href="Tactic.RingSolver.html#9734" class="Function">numVars</a><a id="9873" class="Symbol">)</a>

<a id="9876" class="Comment">-- This is the main macro which solves for equations in which the</a>
<a id="9942" class="Comment">-- variables are universally quantified over:</a>
<a id="9988" class="Comment">--</a>
<a id="9991" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="10026" class="Comment">--   lemma = solve-∀ ring</a>
<a id="10052" class="Comment">--</a>
<a id="10055" class="Comment">-- where ring is your implementation of AlmostCommutativeRing.</a>
<a id="10118" class="Comment">-- (Find some example implementations in</a>
<a id="10159" class="Comment">-- Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>
<a id="solve-∀-macro"></a><a id="10219" href="Tactic.RingSolver.html#10219" class="Function">solve-∀-macro</a> <a id="10233" class="Symbol">:</a> <a id="10235" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="10240" class="Symbol">→</a> <a id="10242" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="10247" class="Symbol">→</a> <a id="10249" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="10252" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="10254" href="Tactic.RingSolver.html#10219" class="Function">solve-∀-macro</a> <a id="10268" href="Tactic.RingSolver.html#10268" class="Bound">ring</a> <a id="10273" href="Tactic.RingSolver.html#10273" class="Bound">hole</a> <a id="10278" class="Symbol">=</a> <a id="10280" class="Keyword">do</a>
  <a id="10285" href="Tactic.RingSolver.html#10285" class="Bound">`ring</a> <a id="10291" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10293" href="Tactic.RingSolver.html#2676" class="Function">checkIsRing</a> <a id="10305" class="Symbol">(</a><a id="10306" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="10310" href="Tactic.RingSolver.html#10268" class="Bound">ring</a> <a id="10315" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10317" class="Symbol">)</a>
  <a id="10321" href="Agda.Builtin.Reflection.html#9864" class="Postulate">commitTC</a>
  <a id="10332" href="Tactic.RingSolver.html#10332" class="Bound">operatorTerms</a> <a id="10346" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10348" href="Tactic.RingSolver.html#3577" class="Function">getRingOperatorTerms</a> <a id="10369" href="Tactic.RingSolver.html#10285" class="Bound">`ring</a>

  <a id="10378" class="Comment">-- Obtain and sanitise the goal type</a>
  <a id="10417" href="Tactic.RingSolver.html#10417" class="Bound">`hole</a> <a id="10423" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10425" href="Agda.Builtin.Reflection.html#8893" class="Postulate">inferType</a> <a id="10435" href="Tactic.RingSolver.html#10273" class="Bound">hole</a> <a id="10440" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="10444" href="Agda.Builtin.Reflection.html#9008" class="Postulate">reduce</a>
  <a id="10453" class="Keyword">let</a> <a id="10457" href="Tactic.RingSolver.html#10457" class="Bound">variablesAndTypes</a> <a id="10475" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10477" href="Tactic.RingSolver.html#10477" class="Bound">equation</a> <a id="10486" class="Symbol">=</a> <a id="10488" href="Reflection.AST.Term.html#3491" class="Function">stripPis</a> <a id="10497" href="Tactic.RingSolver.html#10417" class="Bound">`hole</a>

  <a id="10506" class="Keyword">let</a> <a id="10510" href="Tactic.RingSolver.html#10510" class="Bound">variables</a> <a id="10520" class="Symbol">=</a> <a id="10522" href="Data.List.Base.html#1634" class="Function">List.map</a> <a id="10531" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="10537" href="Tactic.RingSolver.html#10457" class="Bound">variablesAndTypes</a>
  <a id="10557" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="10562" class="Symbol">(</a><a id="10563" href="Tactic.RingSolver.html#10563" class="Bound">lhs</a> <a id="10567" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="10569" href="Tactic.RingSolver.html#10569" class="Bound">rhs</a> <a id="10573" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="10575" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a><a id="10577" class="Symbol">)</a> <a id="10579" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10581" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="10586" class="Symbol">(</a><a id="10587" href="Tactic.RingSolver.html#1771" class="Function">getVisibleArgs</a> <a id="10602" class="Number">2</a> <a id="10604" href="Tactic.RingSolver.html#10477" class="Bound">equation</a><a id="10612" class="Symbol">)</a>
    <a id="10618" class="Keyword">where</a> <a id="10624" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="10632" class="Symbol">→</a> <a id="10634" href="Tactic.RingSolver.html#8976" class="Function">malformedForallTypeError</a> <a id="10659" href="Tactic.RingSolver.html#10417" class="Bound">`hole</a>

  <a id="10668" href="Tactic.RingSolver.html#10668" class="Bound">solverCall</a> <a id="10679" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10681" href="Tactic.RingSolver.html#9355" class="Function">constructCallToSolver</a> <a id="10703" href="Tactic.RingSolver.html#10285" class="Bound">`ring</a> <a id="10709" href="Tactic.RingSolver.html#10332" class="Bound">operatorTerms</a> <a id="10723" href="Tactic.RingSolver.html#10510" class="Bound">variables</a> <a id="10733" href="Tactic.RingSolver.html#10563" class="Bound">lhs</a> <a id="10737" href="Tactic.RingSolver.html#10569" class="Bound">rhs</a>
  <a id="10743" href="Agda.Builtin.Reflection.html#8790" class="Postulate">unify</a> <a id="10749" href="Tactic.RingSolver.html#10273" class="Bound">hole</a> <a id="10754" href="Tactic.RingSolver.html#10668" class="Bound">solverCall</a>

<a id="10766" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="10774" href="Tactic.RingSolver.html#10774" class="Function">solve-∀</a> <a id="10782" class="Symbol">:</a> <a id="10784" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="10789" class="Symbol">→</a> <a id="10791" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="10796" class="Symbol">→</a> <a id="10798" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="10801" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="10805" href="Tactic.RingSolver.html#10774" class="Function">solve-∀</a> <a id="10813" class="Symbol">=</a> <a id="10815" href="Tactic.RingSolver.html#10219" class="Function">solve-∀-macro</a>

<a id="10830" class="Comment">------------------------------------------------------------------------</a>
<a id="10903" class="Comment">-- Unquantified macro</a>

<a id="malformedArgumentListError"></a><a id="10926" href="Tactic.RingSolver.html#10926" class="Function">malformedArgumentListError</a> <a id="10953" class="Symbol">:</a> <a id="10955" class="Symbol">∀</a> <a id="10957" class="Symbol">{</a><a id="10958" href="Tactic.RingSolver.html#10958" class="Bound">a</a><a id="10959" class="Symbol">}</a> <a id="10961" class="Symbol">{</a><a id="10962" href="Tactic.RingSolver.html#10962" class="Bound">A</a> <a id="10964" class="Symbol">:</a> <a id="10966" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="10970" href="Tactic.RingSolver.html#10958" class="Bound">a</a><a id="10971" class="Symbol">}</a> <a id="10973" class="Symbol">→</a> <a id="10975" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="10980" class="Symbol">→</a> <a id="10982" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="10985" href="Tactic.RingSolver.html#10962" class="Bound">A</a>
<a id="10987" href="Tactic.RingSolver.html#10926" class="Function">malformedArgumentListError</a> <a id="11014" href="Tactic.RingSolver.html#11014" class="Bound">found</a> <a id="11020" class="Symbol">=</a> <a id="11022" href="Agda.Builtin.Reflection.html#8830" class="Postulate">typeError</a>
  <a id="11034" class="Symbol">(</a> <a id="11036" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="11043" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11072" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11074" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="11081" class="String">&quot;First argument should be a list of free variables.&quot;</a>
  <a id="11136" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11138" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="11145" class="String">&quot;Instead: &quot;</a>
  <a id="11159" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11161" href="Agda.Builtin.Reflection.html#8269" class="InductiveConstructor">termErr</a> <a id="11169" href="Tactic.RingSolver.html#11014" class="Bound">found</a>
  <a id="11177" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11179" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11181" class="Symbol">)</a>

<a id="malformedGoalError"></a><a id="11184" href="Tactic.RingSolver.html#11184" class="Function">malformedGoalError</a> <a id="11203" class="Symbol">:</a> <a id="11205" class="Symbol">∀</a> <a id="11207" class="Symbol">{</a><a id="11208" href="Tactic.RingSolver.html#11208" class="Bound">a</a><a id="11209" class="Symbol">}</a> <a id="11211" class="Symbol">{</a><a id="11212" href="Tactic.RingSolver.html#11212" class="Bound">A</a> <a id="11214" class="Symbol">:</a> <a id="11216" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="11220" href="Tactic.RingSolver.html#11208" class="Bound">a</a><a id="11221" class="Symbol">}</a> <a id="11223" class="Symbol">→</a> <a id="11225" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11230" class="Symbol">→</a> <a id="11232" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="11235" href="Tactic.RingSolver.html#11212" class="Bound">A</a>
<a id="11237" href="Tactic.RingSolver.html#11184" class="Function">malformedGoalError</a> <a id="11256" href="Tactic.RingSolver.html#11256" class="Bound">found</a> <a id="11262" class="Symbol">=</a> <a id="11264" href="Agda.Builtin.Reflection.html#8830" class="Postulate">typeError</a>
  <a id="11276" class="Symbol">(</a> <a id="11278" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="11285" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11314" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11316" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="11323" class="String">&quot;Goal type should be of the form: LHS ≈ RHS&quot;</a>
  <a id="11370" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11372" href="Agda.Builtin.Reflection.html#8238" class="InductiveConstructor">strErr</a> <a id="11379" class="String">&quot;Instead: &quot;</a>
  <a id="11393" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11395" href="Agda.Builtin.Reflection.html#8269" class="InductiveConstructor">termErr</a> <a id="11403" href="Tactic.RingSolver.html#11256" class="Bound">found</a>
  <a id="11411" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11413" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11415" class="Symbol">)</a>

<a id="checkIsListOfVariables"></a><a id="11418" href="Tactic.RingSolver.html#11418" class="Function">checkIsListOfVariables</a> <a id="11441" class="Symbol">:</a> <a id="11443" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11448" class="Symbol">→</a> <a id="11450" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11455" class="Symbol">→</a> <a id="11457" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="11460" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="11465" href="Tactic.RingSolver.html#11418" class="Function">checkIsListOfVariables</a> <a id="11488" href="Tactic.RingSolver.html#11488" class="Bound">`ring</a> <a id="11494" href="Tactic.RingSolver.html#11494" class="Bound">`xs</a> <a id="11498" class="Symbol">=</a> <a id="11500" href="Agda.Builtin.Reflection.html#8929" class="Postulate">checkType</a> <a id="11510" href="Tactic.RingSolver.html#11494" class="Bound">`xs</a> <a id="11514" class="Symbol">(</a><a id="11515" href="Data.List.Reflection.html#471" class="Function">`List</a> <a id="11521" class="Symbol">(</a><a id="11522" href="Tactic.RingSolver.html#3121" class="Function">`Carrier</a> <a id="11531" href="Tactic.RingSolver.html#11488" class="Bound">`ring</a><a id="11536" class="Symbol">))</a> <a id="11539" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="11543" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a>

<a id="11554" class="Comment">-- Extracts the deBruijn indices from a list of variables</a>
<a id="getVariableIndices"></a><a id="11612" href="Tactic.RingSolver.html#11612" class="Function">getVariableIndices</a> <a id="11631" class="Symbol">:</a> <a id="11633" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11638" class="Symbol">→</a> <a id="11640" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="11646" href="Tactic.RingSolver.Core.NatSet.html#2256" class="Function">NatSet</a>
<a id="11653" href="Tactic.RingSolver.html#11612" class="Function">getVariableIndices</a> <a id="11672" class="Symbol">=</a> <a id="11674" href="Tactic.RingSolver.html#11690" class="Function">go</a> <a id="11677" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="11682" class="Keyword">where</a>
  <a id="11690" href="Tactic.RingSolver.html#11690" class="Function">go</a> <a id="11693" class="Symbol">:</a> <a id="11695" href="Tactic.RingSolver.Core.NatSet.html#2256" class="Function">NatSet</a> <a id="11702" class="Symbol">→</a> <a id="11704" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11709" class="Symbol">→</a> <a id="11711" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="11717" href="Tactic.RingSolver.Core.NatSet.html#2256" class="Function">NatSet</a>
  <a id="11726" href="Tactic.RingSolver.html#11690" class="Function">go</a> <a id="11729" href="Tactic.RingSolver.html#11729" class="Bound">t</a> <a id="11731" class="Symbol">(</a><a id="11732" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="11736" href="Tactic.RingSolver.html#11736" class="Bound">i</a> <a id="11738" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="11741" href="Data.List.Reflection.html#980" class="InductiveConstructor Operator">`∷`</a> <a id="11745" href="Tactic.RingSolver.html#11745" class="Bound">xs</a><a id="11747" class="Symbol">)</a> <a id="11749" class="Symbol">=</a> <a id="11751" href="Tactic.RingSolver.html#11690" class="Function">go</a> <a id="11754" class="Symbol">(</a><a id="11755" href="Tactic.RingSolver.Core.NatSet.html#2373" class="Function">insert</a> <a id="11762" href="Tactic.RingSolver.html#11736" class="Bound">i</a> <a id="11764" href="Tactic.RingSolver.html#11729" class="Bound">t</a><a id="11765" class="Symbol">)</a> <a id="11767" href="Tactic.RingSolver.html#11745" class="Bound">xs</a>
  <a id="11772" href="Tactic.RingSolver.html#11690" class="Function">go</a> <a id="11775" href="Tactic.RingSolver.html#11775" class="Bound">t</a> <a id="11777" href="Data.List.Reflection.html#936" class="InductiveConstructor">`[]`</a>              <a id="11795" class="Symbol">=</a> <a id="11797" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="11802" href="Tactic.RingSolver.html#11775" class="Bound">t</a>
  <a id="11806" href="Tactic.RingSolver.html#11690" class="CatchallClause Function">go</a><a id="11808" class="CatchallClause"> </a><a id="11809" class="CatchallClause Symbol">_</a><a id="11810" class="CatchallClause"> </a><a id="11811" class="CatchallClause Symbol">_</a>                 <a id="11829" class="Symbol">=</a> <a id="11831" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

<a id="constructSolution"></a><a id="11840" href="Tactic.RingSolver.html#11840" class="Function">constructSolution</a> <a id="11858" class="Symbol">:</a> <a id="11860" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11865" class="Symbol">→</a> <a id="11867" href="Tactic.RingSolver.html#2566" class="Record">RingOperatorTerms</a> <a id="11885" class="Symbol">→</a> <a id="11887" href="Tactic.RingSolver.Core.NatSet.html#2256" class="Function">NatSet</a> <a id="11894" class="Symbol">→</a> <a id="11896" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11901" class="Symbol">→</a> <a id="11903" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11908" class="Symbol">→</a> <a id="11910" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="11913" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="11918" href="Tactic.RingSolver.html#11840" class="Function">constructSolution</a> <a id="11936" href="Tactic.RingSolver.html#11936" class="Bound">`ring</a> <a id="11942" href="Tactic.RingSolver.html#11942" class="Bound">opTerms</a> <a id="11950" href="Tactic.RingSolver.html#11950" class="Bound">variables</a> <a id="11960" href="Tactic.RingSolver.html#11960" class="Bound">`lhs</a> <a id="11965" href="Tactic.RingSolver.html#11965" class="Bound">`rhs</a> <a id="11970" class="Symbol">=</a> <a id="11972" class="Keyword">do</a>
  <a id="11977" href="Tactic.RingSolver.html#11977" class="Bound">`lhsExpr</a> <a id="11986" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="11988" href="Tactic.RingSolver.html#12261" class="Function">conv</a> <a id="11993" href="Tactic.RingSolver.html#11960" class="Bound">`lhs</a>
  <a id="12000" href="Tactic.RingSolver.html#12000" class="Bound">`rhsExpr</a> <a id="12009" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="12011" href="Tactic.RingSolver.html#12261" class="Function">conv</a> <a id="12016" href="Tactic.RingSolver.html#11965" class="Bound">`rhs</a>
  <a id="12023" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="12028" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="12030" href="Tactic.RingSolver.html#3293" class="Function">`trans</a> <a id="12037" href="Tactic.RingSolver.html#11936" class="Bound">`ring</a> <a id="12043" class="Symbol">(</a><a id="12044" href="Tactic.RingSolver.html#3225" class="Function">`sym</a> <a id="12049" href="Tactic.RingSolver.html#11936" class="Bound">`ring</a> <a id="12055" href="Tactic.RingSolver.html#11977" class="Bound">`lhsExpr</a><a id="12063" class="Symbol">)</a> <a id="12065" href="Tactic.RingSolver.html#12000" class="Bound">`rhsExpr</a>
  <a id="12076" class="Keyword">where</a>
  <a id="12084" href="Tactic.RingSolver.html#12084" class="Function">numVars</a> <a id="12092" class="Symbol">=</a> <a id="12094" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="12106" href="Tactic.RingSolver.html#11950" class="Bound">variables</a>

  <a id="12119" href="Tactic.RingSolver.html#12119" class="Function">varMap</a> <a id="12126" class="Symbol">:</a> <a id="12128" href="Tactic.RingSolver.html#1588" class="Function">VarMap</a>
  <a id="12137" href="Tactic.RingSolver.html#12119" class="Function">varMap</a> <a id="12144" href="Tactic.RingSolver.html#12144" class="Bound">i</a> <a id="12146" class="Symbol">=</a> <a id="12148" href="Data.Maybe.Base.html#1934" class="Function">Maybe.map</a> <a id="12158" class="Symbol">(λ</a> <a id="12161" href="Tactic.RingSolver.html#12161" class="Bound">x</a> <a id="12163" class="Symbol">→</a> <a id="12165" href="Tactic.RingSolver.html#4684" class="Function">`I</a> <a id="12168" href="Tactic.RingSolver.html#11936" class="Bound">`ring</a> <a id="12174" href="Tactic.RingSolver.html#12084" class="Function">numVars</a> <a id="12182" class="Symbol">(</a><a id="12183" href="Data.Nat.Reflection.html#728" class="Function">toFinTerm</a> <a id="12193" href="Tactic.RingSolver.html#12161" class="Bound">x</a><a id="12194" class="Symbol">))</a> <a id="12197" class="Symbol">(</a><a id="12198" href="Tactic.RingSolver.Core.NatSet.html#3021" class="Function">lookup</a> <a id="12205" href="Tactic.RingSolver.html#11950" class="Bound">variables</a> <a id="12215" href="Tactic.RingSolver.html#12144" class="Bound">i</a><a id="12216" class="Symbol">)</a>

  <a id="12221" href="Tactic.RingSolver.html#12221" class="Function">ρ</a> <a id="12223" class="Symbol">:</a> <a id="12225" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="12232" href="Tactic.RingSolver.html#12221" class="Function">ρ</a> <a id="12234" class="Symbol">=</a> <a id="12236" href="Tactic.RingSolver.html#2198" class="Function">curriedTerm</a> <a id="12248" href="Tactic.RingSolver.html#11950" class="Bound">variables</a>

  <a id="12261" href="Tactic.RingSolver.html#12261" class="Function">conv</a> <a id="12266" class="Symbol">=</a> <a id="12268" class="Symbol">λ</a> <a id="12270" href="Tactic.RingSolver.html#12270" class="Bound">t</a> <a id="12272" class="Symbol">→</a> <a id="12274" class="Keyword">do</a>
    <a id="12281" href="Tactic.RingSolver.html#12281" class="Bound">t&#39;</a> <a id="12284" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="12286" href="Tactic.RingSolver.html#5791" class="Function">convertTerm</a> <a id="12298" href="Tactic.RingSolver.html#11936" class="Bound">`ring</a> <a id="12304" href="Tactic.RingSolver.html#12084" class="Function">numVars</a> <a id="12312" href="Tactic.RingSolver.html#11942" class="Bound">opTerms</a> <a id="12320" href="Tactic.RingSolver.html#12119" class="Function">varMap</a> <a id="12327" href="Tactic.RingSolver.html#12270" class="Bound">t</a>
    <a id="12333" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="12338" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="12340" href="Tactic.RingSolver.html#4846" class="Function">`correct</a> <a id="12349" href="Tactic.RingSolver.html#11936" class="Bound">`ring</a> <a id="12355" href="Tactic.RingSolver.html#12084" class="Function">numVars</a> <a id="12363" href="Tactic.RingSolver.html#12281" class="Bound">t&#39;</a> <a id="12366" href="Tactic.RingSolver.html#12221" class="Function">ρ</a>

<a id="12369" class="Comment">-- Use this macro when you want to solve something *under* a lambda.</a>
<a id="12438" class="Comment">-- For example: say you have a long proof, and you just want the solver</a>
<a id="12510" class="Comment">-- to deal with an intermediate step. Call it like so:</a>
<a id="12565" class="Comment">--</a>
<a id="12568" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="12620" class="Comment">--   lemma₃ x y = begin</a>
<a id="12644" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="12703" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="12757" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="12788" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="12811" class="Comment">--</a>
<a id="12814" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="12881" class="Comment">-- ring implementation (as before).</a>
<a id="solve-macro"></a><a id="12917" href="Tactic.RingSolver.html#12917" class="Function">solve-macro</a> <a id="12929" class="Symbol">:</a> <a id="12931" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="12936" class="Symbol">→</a> <a id="12938" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="12943" class="Symbol">→</a> <a id="12945" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="12950" class="Symbol">→</a> <a id="12952" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="12955" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="12957" href="Tactic.RingSolver.html#12917" class="Function">solve-macro</a> <a id="12969" href="Tactic.RingSolver.html#12969" class="Bound">variables</a> <a id="12979" href="Tactic.RingSolver.html#12979" class="Bound">ring</a> <a id="12984" href="Tactic.RingSolver.html#12984" class="Bound">hole</a> <a id="12989" class="Symbol">=</a> <a id="12991" class="Keyword">do</a>
  <a id="12996" href="Tactic.RingSolver.html#12996" class="Bound">`ring</a> <a id="13002" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13004" href="Tactic.RingSolver.html#2676" class="Function">checkIsRing</a> <a id="13016" class="Symbol">(</a><a id="13017" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="13021" href="Tactic.RingSolver.html#12979" class="Bound">ring</a> <a id="13026" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13028" class="Symbol">)</a>
  <a id="13032" href="Agda.Builtin.Reflection.html#9864" class="Postulate">commitTC</a>
  <a id="13043" href="Tactic.RingSolver.html#13043" class="Bound">operatorTerms</a> <a id="13057" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13059" href="Tactic.RingSolver.html#3577" class="Function">getRingOperatorTerms</a> <a id="13080" href="Tactic.RingSolver.html#12996" class="Bound">`ring</a>

  <a id="13089" class="Comment">-- Obtain and sanitise the list of variables</a>
  <a id="13136" href="Tactic.RingSolver.html#13136" class="Bound">listOfVariables′</a> <a id="13153" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13155" href="Tactic.RingSolver.html#11418" class="Function">checkIsListOfVariables</a> <a id="13178" href="Tactic.RingSolver.html#12996" class="Bound">`ring</a> <a id="13184" href="Tactic.RingSolver.html#12969" class="Bound">variables</a>
  <a id="13196" href="Agda.Builtin.Reflection.html#9864" class="Postulate">commitTC</a>
  <a id="13207" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="13212" href="Tactic.RingSolver.html#13212" class="Bound">variableIndices</a> <a id="13228" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13230" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="13235" class="Symbol">(</a><a id="13236" href="Tactic.RingSolver.html#11612" class="Function">getVariableIndices</a> <a id="13255" href="Tactic.RingSolver.html#13136" class="Bound">listOfVariables′</a><a id="13271" class="Symbol">)</a>
    <a id="13277" class="Keyword">where</a> <a id="13283" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="13291" class="Symbol">→</a> <a id="13293" href="Tactic.RingSolver.html#10926" class="Function">malformedArgumentListError</a> <a id="13320" href="Tactic.RingSolver.html#13136" class="Bound">listOfVariables′</a>

  <a id="13340" class="Comment">-- Obtain and santise the goal type</a>
  <a id="13378" href="Tactic.RingSolver.html#13378" class="Bound">hole′</a> <a id="13384" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13386" href="Agda.Builtin.Reflection.html#8893" class="Postulate">inferType</a> <a id="13396" href="Tactic.RingSolver.html#12984" class="Bound">hole</a> <a id="13401" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="13405" href="Agda.Builtin.Reflection.html#9008" class="Postulate">reduce</a>
  <a id="13414" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="13419" class="Symbol">(</a><a id="13420" href="Tactic.RingSolver.html#13420" class="Bound">lhs</a> <a id="13424" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="13426" href="Tactic.RingSolver.html#13426" class="Bound">rhs</a> <a id="13430" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="13432" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a><a id="13434" class="Symbol">)</a> <a id="13436" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13438" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="13443" class="Symbol">(</a><a id="13444" href="Tactic.RingSolver.html#1771" class="Function">getVisibleArgs</a> <a id="13459" class="Number">2</a> <a id="13461" href="Tactic.RingSolver.html#13378" class="Bound">hole′</a><a id="13466" class="Symbol">)</a>
    <a id="13472" class="Keyword">where</a> <a id="13478" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="13486" class="Symbol">→</a> <a id="13488" href="Tactic.RingSolver.html#11184" class="Function">malformedGoalError</a> <a id="13507" href="Tactic.RingSolver.html#13378" class="Bound">hole′</a>

  <a id="13516" href="Tactic.RingSolver.html#13516" class="Bound">solution</a> <a id="13525" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13527" href="Tactic.RingSolver.html#11840" class="Function">constructSolution</a> <a id="13545" href="Tactic.RingSolver.html#12996" class="Bound">`ring</a> <a id="13551" href="Tactic.RingSolver.html#13043" class="Bound">operatorTerms</a> <a id="13565" href="Tactic.RingSolver.html#13212" class="Bound">variableIndices</a> <a id="13581" href="Tactic.RingSolver.html#13420" class="Bound">lhs</a> <a id="13585" href="Tactic.RingSolver.html#13426" class="Bound">rhs</a>
  <a id="13591" href="Agda.Builtin.Reflection.html#8790" class="Postulate">unify</a> <a id="13597" href="Tactic.RingSolver.html#12984" class="Bound">hole</a> <a id="13602" href="Tactic.RingSolver.html#13516" class="Bound">solution</a>

<a id="13612" class="Keyword">macro</a>
  <a id="solve"></a><a id="13620" href="Tactic.RingSolver.html#13620" class="Function">solve</a> <a id="13626" class="Symbol">:</a> <a id="13628" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="13633" class="Symbol">→</a> <a id="13635" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="13640" class="Symbol">→</a> <a id="13642" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="13647" class="Symbol">→</a> <a id="13649" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="13652" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="13656" href="Tactic.RingSolver.html#13620" class="Function">solve</a> <a id="13662" class="Symbol">=</a> <a id="13664" href="Tactic.RingSolver.html#12917" class="Function">solve-macro</a>
</pre></body></html>