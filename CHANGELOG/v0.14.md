Version 0.14
============

The library has been tested using Agda version 2.5.3.

Non-backwards compatible changes
--------------------------------

#### 1st stage of overhaul of list membership

* The current setup for list membership is difficult to work with as both setoid membership
  and propositional membership exist as internal modules of `Data.Any`. Furthermore the
  top-level module `Data.List.Any.Membership` actually contains properties of propositional
  membership rather than the membership relation itself as its name would suggest.
  Consequently this leaves no place to reason about the properties of setoid membership.

  Therefore the two internal modules `Membership` and `Membership-â‰¡` have been moved out
  of `Data.List.Any` into top-level `Data.List.Any.Membership` and
  `Data.List.Any.Membership.Propositional` respectively. The previous module
  `Data.List.Any.Membership` has been renamed
  `Data.List.Any.Membership.Propositional.Properties`.

  Accordingly some lemmas have been moved to more logical locations:
  - `lift-resp` has been moved from `Data.List.Any.Membership` to `Data.List.Any.Properties`
  - `âˆˆ-resp-â‰ˆ`, `âŠ†-preorder` and `âŠ†-Reasoning` have been moved from `Data.List.Any.Membership`
  to `Data.List.Any.Membership.Properties`.
  - `âˆˆ-resp-list-â‰ˆ` has been moved from `Data.List.Any.Membership` to
  `Data.List.Any.Membership.Properties` and renamed `âˆˆ-resp-â‰‹`.
  - `swap` in `Data.List.Any.Properties` has been renamed `swapâ†”` and made more generic with
  respect to levels.

#### Moving `decTotalOrder` and `decSetoid` from `Data.X` to `Data.X.Properties`

* Currently the library does not directly expose proofs of basic properties such as reflexivity,
  transitivity etc. for `_â‰¤_` in numeric datatypes such as `Nat`, `Integer` etc. In order to use these
  properties it was necessary to first import the `decTotalOrder` proof from `Data.X` and then
  separately open it, often having to rename the proofs as well. This adds unneccessary lines of
  code to the import statements for what are very commonly used properties.

  These basic proofs have now been added in `Data.X.Properties` along with proofs that they form
  pre-orders, partial orders and total orders. This should make them considerably easier to work with
  and simplify files' import preambles. However consequently the records `decTotalOrder` and
  `decSetoid` have been moved from `Data.X` to `â‰¤-decTotalOrder` and `â‰¡-decSetoid` in
  `Data.X.Properties`.

  The numeric datatypes for which this has been done are `Nat`, `Integer`, `Rational` and `Bin`.

  As a consequence the module `â‰¤-Reasoning` has also had to have been moved from `Data.Nat` to
  `Data.Nat.Properties`.

#### New well-founded induction proofs for `Data.Nat`

* Currently `Induction.Nat` only proves that the non-standard `_<â€²_`relation over `â„•` is
  well-founded. Unfortunately these existing proofs are named `<-Rec` and `<-well-founded`
  which clash with the sensible names for new proofs over the standard `_<_` relation.

  Therefore `<-Rec` and `<-well-founded` have been renamed to `<â€²-Rec` and `<â€²-well-founded`
  respectively. The original names `<-Rec` and `<-well-founded` now refer to new
  corresponding proofs for `_<_`.

#### Other

* Changed the implementation of `map` and `zipWith` in `Data.Vec` to use native
  (pattern-matching) definitions. Previously they were defined using the
  `applicative` operations of `Vec`. The new definitions can be converted back
  to the old using the new proofs `âŠ›-is-zipWith`, `map-is-âŠ›` and `zipWith-is-âŠ›`
  in `Data.Vec.Properties`. It has been argued that `zipWith` is fundamental than `_âŠ›_`
  and this change allows better printing of goals involving `map` or `zipWith`.

* Changed the implementation of `Allâ‚‚` in `Data.Vec.All` to a native datatype. This
  improved improves pattern matching on terms and allows the new datatype to be more
  generic with respect to types and levels.

* Changed the implementation of `downFrom` in `Data.List` to a native
  (pattern-matching) definition. Previously it was defined using a private
  internal module which made pattern matching difficult.

* The arguments of `â‰¤predâ‡’â‰¤` and `â‰¤â‡’predâ‰¤` in `Data.Nat.Properties` are now implicit
  rather than explicit (was `âˆ€ m n â†’ m â‰¤ pred n â†’ m â‰¤ n` and is now
  `âˆ€ {m n} â†’ m â‰¤ pred n â†’ m â‰¤ n`). This makes it consistent with `<â‡’â‰¤pred` which
  already used implicit arguments, and shouldn't introduce any significant problems
  as both parameters can be inferred by Agda.

* Moved `Â¬âˆ€âŸ¶âˆƒÂ¬` from `Relation.Nullary.Negation` to `Data.Fin.Dec`. Its old
  location was causing dependency cyles to form between `Data.Fin.Dec`,
  `Relation.Nullary.Negation` and `Data.Fin`.

* Moved `fold`, `add` and `mul` from `Data.Nat` to new module `Data.Nat.GeneralisedArithmetic`.

* Changed type of second parameter of `Relation.Binary.StrictPartialOrderReasoning._<âŸ¨_âŸ©_`
  from `x < y âŠ x â‰ˆ y` to `x < y`. `_â‰ˆâŸ¨_âŸ©_` is left unchanged to take a value with type `x â‰ˆ y`.
  Old code may be fixed by prefixing the contents of `_<âŸ¨_âŸ©_` with `injâ‚`.

Deprecated features
-------------------

Deprecated features still exist and therefore existing code should still work
but they may be removed in some future release of the library.

* The module `Data.Nat.Properties.Simple` is now deprecated. All proofs
  have been moved to `Data.Nat.Properties` where they should be used directly.
  The `Simple` file still exists for backwards compatability reasons and
  re-exports the proofs from `Data.Nat.Properties` but will be removed in some
  future release.

* The modules `Data.Integer.Addition.Properties` and
  `Data.Integer.Multiplication.Properties` are now deprecated. All proofs
  have been moved to `Data.Integer.Properties` where they should be used
  directly. The `Addition.Properties` and `Multiplication.Properties` files
  still exist for backwards compatability reasons and re-exports the proofs from
  `Data.Integer.Properties` but will be removed in some future release.

* The following renaming has occured in `Data.Nat.Properties`
  ```agda
  _+-mono_          â†¦  +-mono-â‰¤
  _*-mono_          â†¦  *-mono-â‰¤

  +-right-identity  â†¦  +-identityÊ³
  *-right-zero      â†¦  *-zeroÊ³
  distribÊ³-*-+      â†¦  *-distribÊ³-+
  *-distrib-âˆ¸Ê³      â†¦  *-distribÊ³-âˆ¸
  cancel-+-left     â†¦  +-cancelË¡-â‰¡
  cancel-+-left-â‰¤   â†¦  +-cancelË¡-â‰¤
  cancel-*-right    â†¦  *-cancelÊ³-â‰¡
  cancel-*-right-â‰¤  â†¦  *-cancelÊ³-â‰¤

  strictTotalOrder                      â†¦  <-strictTotalOrder
  isCommutativeSemiring                 â†¦  *-+-isCommutativeSemiring
  commutativeSemiring                   â†¦  *-+-commutativeSemiring
  isDistributiveLattice                 â†¦  âŠ“-âŠ”-isDistributiveLattice
  distributiveLattice                   â†¦  âŠ“-âŠ”-distributiveLattice
  âŠ”-âŠ“-0-isSemiringWithoutOne            â†¦  âŠ”-âŠ“-isSemiringWithoutOne
  âŠ”-âŠ“-0-isCommutativeSemiringWithoutOne â†¦  âŠ”-âŠ“-isCommutativeSemiringWithoutOne
  âŠ”-âŠ“-0-commutativeSemiringWithoutOne   â†¦  âŠ”-âŠ“-commutativeSemiringWithoutOne
  ```

* The following renaming has occurred in `Data.Nat.Divisibility`:
  ```agda
  âˆ£-*   â†¦   n|m*n
  âˆ£-+   â†¦   âˆ£mâˆ£nâ‡’âˆ£m+n
  âˆ£-âˆ¸   â†¦   âˆ£m+n|mâ‡’|n
  ```

Backwards compatible changes
----------------------------

* Added support for GHC 8.0.2 and 8.2.1.

* Removed the empty `Irrelevance` module

* Added `Category.Functor.Morphism` and module `Category.Functor.Identity`.

* `Data.Container` and `Data.Container.Indexed` now allow for different
  levels in the container and in the data it contains.

* Made `Data.BoundedVec` polymorphic with respect to levels.

* Access to `primForce` and `primForceLemma` has been provided via the new
  top-level module `Strict`.

* New call-by-value application combinator `_$!_` in `Function`.

* Added properties to `Algebra.FunctionProperties`:
  ```agda
  LeftCancellative  _â€¢_ = âˆ€ x {y z} â†’ (x â€¢ y) â‰ˆ (x â€¢ z) â†’ y â‰ˆ z
  RightCancellative _â€¢_ = âˆ€ {x} y z â†’ (y â€¢ x) â‰ˆ (z â€¢ x) â†’ y â‰ˆ z
  Cancellative      _â€¢_ = LeftCancellative _â€¢_ Ã— RightCancellative _â€¢_
  ```

* Added new module `Algebra.FunctionProperties.Consequences` for basic causal relationships between
  properties, containing:
  ```agda
  comm+idË¡â‡’idÊ³         : Commutative _â€¢_ â†’ LeftIdentity e _â€¢_ â†’ RightIdentity e _â€¢_
  comm+idÊ³â‡’idË¡         : Commutative _â€¢_ â†’ RightIdentity e _â€¢_ â†’ LeftIdentity e _â€¢_
  comm+zeË¡â‡’zeÊ³         : Commutative _â€¢_ â†’ LeftZero e _â€¢_ â†’ RightZero e _â€¢_
  comm+zeÊ³â‡’zeË¡         : Commutative _â€¢_ â†’ RightZero e _â€¢_ â†’ LeftZero e _â€¢_
  comm+invË¡â‡’invÊ³       : Commutative _â€¢_ â†’ LeftInverse e _â»Â¹ _â€¢_ â†’ RightInverse e _â»Â¹ _â€¢_
  comm+invÊ³â‡’invË¡       : Commutative _â€¢_ â†’ RightInverse e _â»Â¹ _â€¢_ â†’ LeftInverse e _â»Â¹ _â€¢_
  comm+distrË¡â‡’distrÊ³   : Commutative _â€¢_ â†’ _â€¢_ DistributesOverË¡ _â—¦_ â†’ _â€¢_ DistributesOverÊ³ _â—¦_
  comm+distrÊ³â‡’distrË¡   : Commutative _â€¢_ â†’ _â€¢_ DistributesOverÊ³ _â—¦_ â†’ _â€¢_ DistributesOverË¡ _â—¦_
  comm+cancelË¡â‡’cancelÊ³ : Commutative _â€¢_ â†’ LeftCancellative _â€¢_ â†’ RightCancellative _â€¢_
  comm+cancelË¡â‡’cancelÊ³ : Commutative _â€¢_ â†’ LeftCancellative _â€¢_ â†’ RightCancellative _â€¢_
  selâ‡’idem           : Selective _â€¢_ â†’ Idempotent _â€¢_
  ```

* Added proofs to `Algebra.Properties.BooleanAlgebra`:
  ```agda
  âˆ¨-complementË¡ : LeftInverse âŠ¤ Â¬_ _âˆ¨_
  âˆ§-complementË¡ : LeftInverse âŠ¥ Â¬_ _âˆ§_

  âˆ§-identityÊ³   : RightIdentity âŠ¤ _âˆ§_
  âˆ§-identityË¡   : LeftIdentity âŠ¤ _âˆ§_
  âˆ§-identity    : Identity âŠ¤ _âˆ§_

  âˆ¨-identityÊ³   : RightIdentity âŠ¥ _âˆ¨_
  âˆ¨-identityË¡   : LeftIdentity âŠ¥ _âˆ¨_
  âˆ¨-identity    : Identity âŠ¥ _âˆ¨_

  âˆ§-zeroÊ³       : RightZero âŠ¥ _âˆ§_
  âˆ§-zeroË¡       : LeftZero âŠ¥ _âˆ§_
  âˆ§-zero        : Zero âŠ¥ _âˆ§_

  âˆ¨-zeroÊ³       : RightZero âŠ¤ _âˆ¨_
  âˆ¨-zeroË¡       : LeftZero âŠ¤ _âˆ¨_
  âˆ¨-zero        : Zero âŠ¤ _âˆ¨_

  âŠ•-identityË¡   : LeftIdentity âŠ¥ _âŠ•_
  âŠ•-identityÊ³   : RightIdentity âŠ¥ _âŠ•_
  âŠ•-identity    : Identity âŠ¥ _âŠ•_

  âŠ•-inverseË¡    : LeftInverse âŠ¥ id _âŠ•_
  âŠ•-inverseÊ³    : RightInverse âŠ¥ id _âŠ•_
  âŠ•-inverse     : Inverse âŠ¥ id _âŠ•_

  âŠ•-cong        : Congruentâ‚‚ _âŠ•_
  âŠ•-comm        : Commutative _âŠ•_
  âŠ•-assoc       : Associative _âŠ•_

  âˆ§-distribË¡-âŠ•  : _âˆ§_ DistributesOverË¡ _âŠ•_
  âˆ§-distribÊ³-âŠ•  : _âˆ§_ DistributesOverÊ³ _âŠ•_
  âˆ§-distrib-âŠ•   : _âˆ§_ DistributesOver _âŠ•_

  âˆ¨-isSemigroup           : IsSemigroup _â‰ˆ_ _âˆ¨_
  âˆ§-isSemigroup           : IsSemigroup _â‰ˆ_ _âˆ§_
  âˆ¨-âŠ¥-isMonoid            : IsMonoid _â‰ˆ_ _âˆ¨_ âŠ¥
  âˆ§-âŠ¤-isMonoid            : IsMonoid _â‰ˆ_ _âˆ§_ âŠ¤
  âˆ¨-âŠ¥-isCommutativeMonoid : IsCommutativeMonoid _â‰ˆ_ _âˆ¨_ âŠ¥
  âˆ§-âŠ¤-isCommutativeMonoid : IsCommutativeMonoid _â‰ˆ_ _âˆ§_ âŠ¤

  âŠ•-isSemigroup           : IsSemigroup _â‰ˆ_ _âŠ•_
  âŠ•-âŠ¥-isMonoid            : IsMonoid _â‰ˆ_ _âŠ•_ âŠ¥
  âŠ•-âŠ¥-isGroup             : IsGroup _â‰ˆ_ _âŠ•_ âŠ¥ id
  âŠ•-âŠ¥-isAbelianGroup      : IsAbelianGroup _â‰ˆ_ _âŠ•_ âŠ¥ id
  âŠ•-âˆ§-isRing              : IsRing _â‰ˆ_ _âŠ•_ _âˆ§_ id âŠ¥ âŠ¤
  ```

* Added proofs to `Algebra.Properties.DistributiveLattice`:
  ```agda
  âˆ¨-âˆ§-distribË¡ : _âˆ¨_ DistributesOverË¡ _âˆ§_
  âˆ§-âˆ¨-distribË¡ : _âˆ§_ DistributesOverË¡ _âˆ¨_
  âˆ§-âˆ¨-distribÊ³ : _âˆ§_ DistributesOverÊ³ _âˆ¨_
  ```

* Added pattern synonyms to `Data.Bin` to improve readability:
  ```agda
  pattern 0b = zero
  pattern 1b = 1+ zero
  pattern âŠ¥b = 1+ 1+ ()
  ```

* A new module `Data.Bin.Properties` has been added, containing proofs:
  ```agda
  1#-injective         : as 1# â‰¡ bs 1# â†’ as â‰¡ bs
  _â‰Ÿ_                  : Decidable {A = Bin} _â‰¡_
  â‰¡-isDecEquivalence   : IsDecEquivalence _â‰¡_
  â‰¡-decSetoid          : DecSetoid _ _

  <-trans              : Transitive _<_
  <-asym               : Asymmetric _<_
  <-irrefl             : Irreflexive _â‰¡_ _<_
  <-cmp                : Trichotomous _â‰¡_ _<_
  <-isStrictTotalOrder : IsStrictTotalOrder _â‰¡_ _<_

  <â‡’â‰¢                  : a < b â†’ a â‰¢ b
  1<[23]               : [] 1# < (b âˆ· []) 1#
  1<2+                 : [] 1# < (b âˆ· bs) 1#
  0<1+                 : 0# < bs 1#
  ```

* Added functions to `Data.BoundedVec`:
  ```agda
  toInefficient   : BoundedVec A n â†’ Ineff.BoundedVec A n
  fromInefficient : Ineff.BoundedVec A n â†’ BoundedVec A n
  ```

* Added the following to `Data.Digit`:
  ```agda
  Expansion : â„• â†’ Set
  Expansion base = List (Fin base)
  ```

* Added new module `Data.Empty.Irrelevant` containing an irrelevant version of `âŠ¥-elim`.

* Added functions to `Data.Fin`:
  ```agda
  punchIn  i j â‰ˆ if jâ‰¥i then j+1 else j
  punchOut i j â‰ˆ if j>i then j-1 else j
  ```

* Added proofs to `Data.Fin.Properties`:
  ```agda
  isDecEquivalence     : âˆ€ {n} â†’ IsDecEquivalence (_â‰¡_ {A = Fin n})

  â‰¤-reflexive          : âˆ€ {n} â†’ _â‰¡_ â‡’ (_â‰¤_ {n})
  â‰¤-refl               : âˆ€ {n} â†’ Reflexive (_â‰¤_ {n})
  â‰¤-trans              : âˆ€ {n} â†’ Transitive (_â‰¤_ {n})
  â‰¤-antisymmetric      : âˆ€ {n} â†’ Antisymmetric _â‰¡_ (_â‰¤_ {n})
  â‰¤-total              : âˆ€ {n} â†’ Total (_â‰¤_ {n})
  â‰¤-isPreorder         : âˆ€ {n} â†’ IsPreorder _â‰¡_ (_â‰¤_ {n})
  â‰¤-isPartialOrder     : âˆ€ {n} â†’ IsPartialOrder _â‰¡_ (_â‰¤_ {n})
  â‰¤-isTotalOrder       : âˆ€ {n} â†’ IsTotalOrder _â‰¡_ (_â‰¤_ {n})

  _<?_                 : âˆ€ {n} â†’ Decidable (_<_ {n})
  <-trans              : âˆ€ {n} â†’ Transitive (_<_ {n})
  <-isStrictTotalOrder : âˆ€ {n} â†’ IsStrictTotalOrder _â‰¡_ (_<_ {n})

  punchOut-injective   : punchOut iâ‰¢j â‰¡ punchOut iâ‰¢k â†’ j â‰¡ k
  punchIn-injective    : punchIn i j â‰¡ punchIn i k â†’ j â‰¡ k
  punchIn-punchOut     : punchIn i (punchOut iâ‰¢j) â‰¡ j
  punchInáµ¢â‰¢i           : punchIn i j â‰¢ i
  ```

* Added proofs to `Data.Fin.Subset.Properties`:
  ```agda
  xâˆˆâ…xâ†     : x âˆˆ â… x â†
  xâˆˆâ…yâ†â‡’xâ‰¡y : x âˆˆ â… y â† â†’ x â‰¡ y

  âˆª-assoc   : Associative _â‰¡_ _âˆª_
  âˆ©-assoc   : Associative _â‰¡_ _âˆ©_
  âˆª-comm    : Commutative _â‰¡_ _âˆª_
  âˆ©-comm    : Commutative _â‰¡_ _âˆ©_

  pâŠ†pâˆªq     : p âŠ† p âˆª q
  qâŠ†pâˆªq     : q âŠ† p âˆª q
  xâˆˆpâˆªqâ»    : x âˆˆ p âˆª q â†’ x âˆˆ p âŠ x âˆˆ q
  xâˆˆpâˆªqâº    : x âˆˆ p âŠ x âˆˆ q â†’ x âˆˆ p âˆª q

  pâˆ©qâŠ†p     : p âˆ© q âŠ† p
  pâˆ©qâŠ†q     : p âˆ© q âŠ† q
  xâˆˆpâˆ©qâº    : x âˆˆ p Ã— x âˆˆ q â†’ x âˆˆ p âˆ© q
  xâˆˆpâˆ©qâ»    : x âˆˆ p âˆ© q â†’ x âˆˆ p Ã— x âˆˆ q
  âˆ©â‡”Ã—       : x âˆˆ p âˆ© q â‡” (x âˆˆ p Ã— x âˆˆ q)
  ```

* Added relations to `Data.Integer`
  ```agda
  _â‰¥_ : Rel â„¤ _
  _<_ : Rel â„¤ _
  _>_ : Rel â„¤ _
  _â‰°_ : Rel â„¤ _
  _â‰±_ : Rel â„¤ _
  _â‰®_ : Rel â„¤ _
  _â‰¯_ : Rel â„¤ _
  ```

* Added proofs to `Data.Integer.Properties`
  ```agda
  +-injective           : + m â‰¡ + n â†’ m â‰¡ n
  -[1+-injective        : -[1+ m ] â‰¡ -[1+ n ] â†’ m â‰¡ n

  doubleNeg             : - - n â‰¡ n
  neg-injective         : - m â‰¡ - n â†’ m â‰¡ n

  âˆ£nâˆ£â‰¡0â‡’nâ‰¡0             : âˆ£ n âˆ£ â‰¡ 0 â†’ n â‰¡ + 0
  âˆ£-nâˆ£â‰¡âˆ£nâˆ£              : âˆ£ - n âˆ£ â‰¡ âˆ£ n âˆ£

  +â—ƒnâ‰¡+n                : Sign.+ â—ƒ n â‰¡ + n
  -â—ƒnâ‰¡-n                : Sign.- â—ƒ n â‰¡ - + n
  signâ‚™â—ƒâˆ£nâˆ£â‰¡n           : sign n â—ƒ âˆ£ n âˆ£ â‰¡ n
  âˆ£sâ—ƒmâˆ£*âˆ£tâ—ƒnâˆ£â‰¡m*n       : âˆ£ s â—ƒ m âˆ£ â„•* âˆ£ t â—ƒ n âˆ£ â‰¡ m â„•* n

  âŠ–-â‰°                   : n â‰° m â†’ m âŠ– n â‰¡ - + (n âˆ¸ m)
  âˆ£âŠ–âˆ£-â‰°                 : n â‰° m â†’ âˆ£ m âŠ– n âˆ£ â‰¡ n âˆ¸ m
  sign-âŠ–-â‰°              : n â‰° m â†’ sign (m âŠ– n) â‰¡ Sign.-
  -[nâŠ–m]â‰¡-m+n           : - (m âŠ– n) â‰¡ (- (+ m)) + (+ n)

  +-identity            : Identity (+ 0) _+_
  +-inverse             : Inverse (+ 0) -_ _+_
  +-0-isMonoid          : IsMonoid _â‰¡_ _+_ (+ 0)
  +-0-isGroup           : IsGroup _â‰¡_ _+_ (+ 0) (-_)
  +-0-abelianGroup      : AbelianGroup _ _

  nâ‰¢1+n                 : n â‰¢ suc n
  1-[1+n]â‰¡-n            : suc -[1+ n ] â‰¡ - (+ n)
  neg-distrib-+         : - (m + n) â‰¡ (- m) + (- n)
  â—ƒ-distrib-+           : s â—ƒ (m + n) â‰¡ (s â—ƒ m) + (s â—ƒ n)

  *-identityÊ³           : RightIdentity (+ 1) _*_
  *-identity            : Identity (+ 1) _*_
  *-zeroË¡               : LeftZero (+ 0) _*_
  *-zeroÊ³               : RightZero (+ 0) _*_
  *-zero                : Zero (+ 0) _*_
  *-1-isMonoid          : IsMonoid _â‰¡_ _*_ (+ 1)
  -1*nâ‰¡-n               : -[1+ 0 ] * n â‰¡ - n
  â—ƒ-distrib-*           : (s ğ•Š* t) â—ƒ (m â„•* n) â‰¡ (s â—ƒ m) * (t â—ƒ n)

  +-*-isRing            : IsRing _â‰¡_ _+_ _*_ -_ (+ 0) (+ 1)
  +-*-isCommutativeRing : IsCommutativeRing _â‰¡_ _+_ _*_ -_ (+ 0) (+ 1)

  â‰¤-reflexive           : _â‰¡_ â‡’ _â‰¤_
  â‰¤-refl                : Reflexive _â‰¤_
  â‰¤-trans               : Transitive _â‰¤_
  â‰¤-antisym             : Antisymmetric _â‰¡_ _â‰¤_
  â‰¤-total               : Total _â‰¤_

  â‰¤-isPreorder          : IsPreorder _â‰¡_ _â‰¤_
  â‰¤-isPartialOrder      : IsPartialOrder _â‰¡_ _â‰¤_
  â‰¤-isTotalOrder        : IsTotalOrder _â‰¡_ _â‰¤_
  â‰¤-isDecTotalOrder     : IsDecTotalOrder _â‰¡_ _â‰¤_

  â‰¤-step                : n â‰¤ m â†’ n â‰¤ suc m
  nâ‰¤1+n                 : n â‰¤ + 1 + n

  <-irrefl              : Irreflexive _â‰¡_ _<_
  <-asym                : Asymmetric _<_
  <-trans               : Transitive _<_
  <-cmp                 : Trichotomous _â‰¡_ _<_
  <-isStrictTotalOrder  : IsStrictTotalOrder _â‰¡_ _<_

  nâ‰®n                   : n â‰® n
  -<+                   : -[1+ m ] < + n
  <â‡’â‰¤                   : m < n â†’ m â‰¤ n
  â‰°â†’>                   : x â‰° y â†’ x > y
  ```

* Added functions to `Data.List`
  ```agda
  applyUpTo f n     â‰ˆ f[0]   âˆ· f[1]   âˆ· ... âˆ· f[n-1] âˆ· []
  upTo n            â‰ˆ 0      âˆ· 1      âˆ· ... âˆ· n-1    âˆ· []
  applyDownFrom f n â‰ˆ f[n-1] âˆ· f[n-2] âˆ· ... âˆ· f[0]   âˆ· []
  tabulate f        â‰ˆ f[0]   âˆ· f[1]   âˆ· ... âˆ· f[n-1] âˆ· []
  allFin n          â‰ˆ 0f     âˆ· 1f     âˆ· ... âˆ· n-1f   âˆ· []
  ```

* Added proofs to `Data.List.Properties`
  ```agda
  map-idâ‚‚        : All (Î» x â†’ f x â‰¡ x) xs â†’ map f xs â‰¡ xs
  map-congâ‚‚      : All (Î» x â†’ f x â‰¡ g x) xs â†’ map f xs â‰¡ map g xs
  foldr-++       : foldr f x (ys ++ zs) â‰¡ foldr f (foldr f x zs) ys
  foldl-++       : foldl f x (ys ++ zs) â‰¡ foldl f (foldl f x ys) zs
  foldr-âˆ·Ê³       : foldr f x (ys âˆ·Ê³ y) â‰¡ foldr f (f y x) ys
  foldl-âˆ·Ê³       : foldl f x (ys âˆ·Ê³ y) â‰¡ f (foldl f x ys) y
  reverse-foldr  : foldr f x (reverse ys) â‰¡ foldl (flip f) x ys
  reverse-foldr  : foldl f x (reverse ys) â‰¡ foldr (flip f) x ys
  length-reverse : length (reverse xs) â‰¡ length xs
  ```

* Added proofs to `Data.List.All.Properties`
  ```agda
  All-universal : Universal P â†’ All P xs

  Â¬Anyâ‡’AllÂ¬     : Â¬ Any P xs â†’ All (Â¬_ âˆ˜ P) xs
  AllÂ¬â‡’Â¬Any     : All (Â¬_ âˆ˜ P) xs â†’ Â¬ Any P xs
  Â¬Allâ‡’AnyÂ¬     : Decidable P â†’ Â¬ All P xs â†’ Any (Â¬_ âˆ˜ P) xs

  ++âº           : All P xs â†’ All P ys â†’ All P (xs ++ ys)
  ++â»Ë¡          : All P (xs ++ ys) â†’ All P xs
  ++â»Ê³          : All P (xs ++ ys) â†’ All P ys
  ++â»           : All P (xs ++ ys) â†’ All P xs Ã— All P ys

  concatâº       : All (All P) xss â†’ All P (concat xss)
  concatâ»       : All P (concat xss) â†’ All (All P) xss

  dropâº         : All P xs â†’ All P (drop n xs)
  takeâº         : All P xs â†’ All P (take n xs)

  tabulateâº     : (âˆ€ i â†’ P (f i)) â†’ All P (tabulate f)
  tabulateâ»     : All P (tabulate f) â†’ (âˆ€ i â†’ P (f i))

  applyUpToâºâ‚   : (âˆ€ {i} â†’ i < n â†’ P (f i)) â†’ All P (applyUpTo f n)
  applyUpToâºâ‚‚   : (âˆ€ i â†’ P (f i)) â†’ All P (applyUpTo f n)
  applyUpToâ»    : All P (applyUpTo f n) â†’ âˆ€ {i} â†’ i < n â†’ P (f i)
  ```

* Added proofs to `Data.List.Any.Properties`
  ```agda
  loseâˆ˜find   : uncurryâ€² lose (projâ‚‚ (find p)) â‰¡ p
  findâˆ˜lose   : find (lose xâˆˆxs pp) â‰¡ (x , xâˆˆxs , pp)

  swap        : Any (Î» x â†’ Any (P x) ys) xs â†’ Any (Î» y â†’ Any (flip P y) xs) ys
  swap-invol  : swap (swap any) â‰¡ any

  âˆƒâˆˆ-Any      : (âˆƒ Î» x â†’ x âˆˆ xs Ã— P x) â†’ Any P xs

  Any-âŠâº      : Any P xs âŠ Any Q xs â†’ Any (Î» x â†’ P x âŠ Q x) xs
  Any-âŠâ»      : Any (Î» x â†’ P x âŠ Q x) xs â†’ Any P xs âŠ Any Q xs
  Any-Ã—âº      : Any P xs Ã— Any Q ys â†’ Any (Î» x â†’ Any (Î» y â†’ P x Ã— Q y) ys) xs
  Any-Ã—â»      : Any (Î» x â†’ Any (Î» y â†’ P x Ã— Q y) ys) xs â†’ Any P xs Ã— Any Q ys

  mapâº        : Any (P âˆ˜ f) xs â†’ Any P (map f xs)
  mapâ»        : Any P (map f xs) â†’ Any (P âˆ˜ f) xs

  ++âºË¡        : Any P xs â†’ Any P (xs ++ ys)
  ++âºÊ³        : Any P ys â†’ Any P (xs ++ ys)
  ++â»         : Any P (xs ++ ys) â†’ Any P xs âŠ Any P ys

  concatâº     : Any (Any P) xss â†’ Any P (concat xss)
  concatâ»     : Any P (concat xss) â†’ Any (Any P) xss

  applyUpToâº  : P (f i) â†’ i < n â†’ Any P (applyUpTo f n)
  applyUpToâ»  : Any P (applyUpTo f n) â†’ âˆƒ Î» i â†’ i < n Ã— P (f i)

  tabulateâº   : P (f i) â†’ Any P (tabulate f)
  tabulateâ»   : Any P (tabulate f) â†’ âˆƒ Î» i â†’ P (f i)

  map-with-âˆˆâº : (âˆƒâ‚‚ Î» x (xâˆˆxs : x âˆˆ xs) â†’ P (f xâˆˆxs)) â†’ Any P (map-with-âˆˆ xs f)
  map-with-âˆˆâ» : Any P (map-with-âˆˆ xs f) â†’ âˆƒâ‚‚ Î» x (xâˆˆxs : x âˆˆ xs) â†’ P (f xâˆˆxs)

  returnâº     : P x â†’ Any P (return x)
  returnâ»     : Any P (return x) â†’ P x
  ```

* Added proofs to `Data.List.Any.Membership.Properties`
  ```agda
  âˆˆ-mapâº :  x âˆˆ xs â†’ f x âˆˆ map f xs
  âˆˆ-mapâ» :  y âˆˆ map f xs â†’ âˆƒ Î» x â†’ x âˆˆ xs Ã— y â‰ˆ f x
  ```

* Added proofs to `Data.List.Any.Membership.Propositional.Properties`
  ```agda
  âˆˆ-mapâº :  x âˆˆ xs â†’ f x âˆˆ map f xs
  âˆˆ-mapâ» :  y âˆˆ map f xs â†’ âˆƒ Î» x â†’ x âˆˆ xs Ã— y â‰ˆ f x
  ```

* Added proofs to `Data.Maybe`:
  ```agda
  Eq-refl             : Reflexive _â‰ˆ_ â†’ Reflexive (Eq _â‰ˆ_)
  Eq-sym              : Symmetric _â‰ˆ_ â†’ Symmetric (Eq _â‰ˆ_)
  Eq-trans            : Transitive _â‰ˆ_ â†’ Transitive (Eq _â‰ˆ_)
  Eq-dec              : Decidable _â‰ˆ_ â†’ Decidable (Eq _â‰ˆ_)
  Eq-isEquivalence    : IsEquivalence _â‰ˆ_ â†’ IsEquivalence (Eq _â‰ˆ_)
  Eq-isDecEquivalence : IsDecEquivalence _â‰ˆ_ â†’ IsDecEquivalence (Eq _â‰ˆ_)
  ```

* Added exponentiation operator `_^_` to `Data.Nat.Base`

* Added proofs to `Data.Nat.Properties`:
  ```agda
  suc-injective         : suc m â‰¡ suc n â†’ m â‰¡ n
  â‰¡-isDecEquivalence    : IsDecEquivalence (_â‰¡_ {A = â„•})
  â‰¡-decSetoid           : DecSetoid _ _

  â‰¤-reflexive           : _â‰¡_ â‡’ _â‰¤_
  â‰¤-refl                : Reflexive _â‰¤_
  â‰¤-trans               : Antisymmetric _â‰¡_ _â‰¤_
  â‰¤-antisymmetric       : Transitive _â‰¤_
  â‰¤-total               : Total _â‰¤_
  â‰¤-isPreorder          : IsPreorder _â‰¡_ _â‰¤_
  â‰¤-isPartialOrder      : IsPartialOrder _â‰¡_ _â‰¤_
  â‰¤-isTotalOrder        : IsTotalOrder _â‰¡_ _â‰¤_
  â‰¤-isDecTotalOrder     : IsDecTotalOrder _â‰¡_ _â‰¤_

  _<?_                  : Decidable _<_
  <-irrefl              : Irreflexive _â‰¡_ _<_
  <-asym                : Asymmetric _<_
  <-transÊ³              : Trans _â‰¤_ _<_ _<_
  <-transË¡              : Trans _<_ _â‰¤_ _<_
  <-isStrictTotalOrder  : IsStrictTotalOrder _â‰¡_ _<_
  <â‡’â‰¤                   : _<_ â‡’ _â‰¤_
  <â‡’â‰¢                   : _<_ â‡’ _â‰¢_
  <â‡’â‰±                   : _<_ â‡’ _â‰±_
  <â‡’â‰¯                   : _<_ â‡’ _â‰¯_
  â‰°â‡’â‰®                   : _â‰°_ â‡’ _â‰®_
  â‰°â‡’â‰¥                   : _â‰°_ â‡’ _â‰¥_
  â‰®â‡’â‰¥                   : _â‰®_ â‡’ _â‰¥_
  â‰¤+â‰¢â‡’<                 : m â‰¤ n â†’ m â‰¢ n â†’ m < n

  +-identityË¡           : LeftIdentity 0 _+_
  +-identity            : Identity 0 _+_
  +-cancelÊ³-â‰¡           : RightCancellative _â‰¡_ _+_
  +-cancel-â‰¡            : Cancellative _â‰¡_ _+_
  +-cancelÊ³-â‰¤           : RightCancellative _â‰¤_ _+_
  +-cancel-â‰¤            : Cancellative _â‰¤_ _+_
  +-isSemigroup         : IsSemigroup _â‰¡_ _+_
  +-monoË¡-<             : _+_ Preservesâ‚‚ _<_ âŸ¶ _â‰¤_ âŸ¶ _<_
  +-monoÊ³-<             : _+_ Preservesâ‚‚ _â‰¤_ âŸ¶ _<_ âŸ¶ _<_
  +-mono-<              : _+_ Preservesâ‚‚ _<_ âŸ¶ _<_ âŸ¶ _<_
  m+nâ‰¤oâ‡’mâ‰¤o             : m + n â‰¤ o â†’ m â‰¤ o
  m+nâ‰¤oâ‡’nâ‰¤o             : m + n â‰¤ o â†’ n â‰¤ o
  m+nâ‰®n                 : m + n â‰® n

  *-zeroË¡               : LeftZero 0 _*_
  *-zero                : Zero 0 _*_
  *-identityË¡           : LeftIdentity 1 _*_
  *-identityÊ³           : RightIdentity 1 _*_
  *-identity            : Identity 1 _*_
  *-distribË¡-+          : _*_ DistributesOverË¡ _+_
  *-distrib-+           : _*_ DistributesOver _+_
  *-isSemigroup         : IsSemigroup _â‰¡_ _*_
  *-mono-<              : _*_ Preservesâ‚‚ _<_ âŸ¶ _<_ âŸ¶ _<_
  *-monoË¡-<             : (_* suc n) Preserves _<_ âŸ¶ _<_
  *-monoÊ³-<             : (suc n *_) Preserves _<_ âŸ¶ _<_
  *-cancelË¡-â‰¡           : suc k * i â‰¡ suc k * j â†’ i â‰¡ j

  ^-distribË¡-+-*        : m ^ (n + p) â‰¡ m ^ n * m ^ p
  i^jâ‰¡0â‡’iâ‰¡0             : i ^ j â‰¡ 0 â†’ i â‰¡ 0
  i^jâ‰¡1â‡’jâ‰¡0âˆ¨iâ‰¡1         : i ^ j â‰¡ 1 â†’ j â‰¡ 0 âŠ i â‰¡ 1

  âŠ”-assoc               : Associative _âŠ”_
  âŠ”-comm                : Commutative _âŠ”_
  âŠ”-idem                : Idempotent _âŠ”_
  âŠ”-identityË¡           : LeftIdentity 0 _âŠ”_
  âŠ”-identityÊ³           : RightIdentity 0 _âŠ”_
  âŠ”-identity            : Identity 0 _âŠ”_
  âŠ“-assoc               : Associative _âŠ“_
  âŠ“-comm                : Commutative _âŠ“_
  âŠ“-idem                : Idempotent _âŠ“_
  âŠ“-zeroË¡               : LeftZero 0 _âŠ“_
  âŠ“-zeroÊ³               : RightZero 0 _âŠ“_
  âŠ“-zero                : Zero 0 _âŠ“_
  âŠ“-distribÊ³-âŠ”          : _âŠ“_ DistributesOverÊ³ _âŠ”_
  âŠ“-distribË¡-âŠ”          : _âŠ“_ DistributesOverË¡ _âŠ”_
  âŠ”-abs-âŠ“               : _âŠ”_ Absorbs _âŠ“_
  âŠ“-abs-âŠ”               : _âŠ“_ Absorbs _âŠ”_
  mâŠ“nâ‰¤n                 : m âŠ“ n â‰¤ n
  mâ‰¤mâŠ”n                 : m â‰¤ m âŠ” n
  mâŠ”nâ‰¤m+n               : m âŠ” n â‰¤ m + n
  mâŠ“nâ‰¤m+n               : m âŠ“ n â‰¤ m + n
  mâŠ“nâ‰¤mâŠ”n               : m âŠ” n â‰¤ m âŠ” n
  âŠ”-mono-â‰¤              : _âŠ”_ Preservesâ‚‚ _â‰¤_ âŸ¶ _â‰¤_ âŸ¶ _â‰¤_
  âŠ”-mono-<              : _âŠ”_ Preservesâ‚‚ _<_ âŸ¶ _<_ âŸ¶ _<_
  âŠ“-mono-â‰¤              : _âŠ“_ Preservesâ‚‚ _â‰¤_ âŸ¶ _â‰¤_ âŸ¶ _â‰¤_
  âŠ“-mono-<              : _âŠ“_ Preservesâ‚‚ _<_ âŸ¶ _<_ âŸ¶ _<_
  +-distribË¡-âŠ”          : _+_ DistributesOverË¡ _âŠ”_
  +-distribÊ³-âŠ”          : _+_ DistributesOverÊ³ _âŠ”_
  +-distrib-âŠ”           : _+_ DistributesOver _âŠ”_
  +-distribË¡-âŠ“          : _+_ DistributesOverË¡ _âŠ“_
  +-distribÊ³-âŠ“          : _+_ DistributesOverÊ³ _âŠ“_
  +-distrib-âŠ“           : _+_ DistributesOver _âŠ“_
  âŠ”-isSemigroup         : IsSemigroup _â‰¡_ _âŠ”_
  âŠ“-isSemigroup         : IsSemigroup _â‰¡_ _âŠ“_
  âŠ“-âŠ”-isLattice         : IsLattice _â‰¡_ _âŠ“_ _âŠ”_

  âˆ¸-distribÊ³-âŠ”          : _âˆ¸_ DistributesOverÊ³ _âŠ”_
  âˆ¸-distribÊ³-âŠ“          : _âˆ¸_ DistributesOverÊ³ _âŠ“_
  +-âˆ¸-comm              : o â‰¤ m â†’ (m + n) âˆ¸ o â‰¡ (m âˆ¸ o) + n
  ```

* Added decidability relation to `Data.Nat.GCD`
  ```agda
  gcd? : (m n d : â„•) â†’ Dec (GCD m n d)
  ```

* Added "not-divisible-by" relation to `Data.Nat.Divisibility`
  ```agda
  m âˆ¤ n = Â¬ (m âˆ£ n)
  ```

* Added proofs to `Data.Nat.Divisibility`
  ```agda
  âˆ£-reflexive      : _â‰¡_ â‡’ _âˆ£_
  âˆ£-refl           : Reflexive _âˆ£_
  âˆ£-trans          : Transitive _âˆ£_
  âˆ£-antisym        : Antisymmetric _â‰¡_ _âˆ£_
  âˆ£-isPreorder     : IsPreorder _â‰¡_ _âˆ£_
  âˆ£-isPartialOrder : IsPartialOrder _â‰¡_ _âˆ£_

  nâˆ£n              : n âˆ£ n
  âˆ£mâˆ¸nâˆ£nâ‡’âˆ£m        : n â‰¤ m â†’ i âˆ£ m âˆ¸ n â†’ i âˆ£ n â†’ i âˆ£ m
  ```

* Added proofs to `Data.Nat.GeneralisedArithmetic`:
  ```agda
  fold-+     : fold z s (m + n) â‰¡ fold (fold z s n) s m
  fold-k     : fold k (s âˆ˜â€²_) m z â‰¡ fold (k z) s m
  fold-*     : fold z s (m * n) â‰¡ fold z (fold id (s âˆ˜_) n) m
  fold-pull  : fold p s m â‰¡ g (fold z s m) p

  id-is-fold : fold zero suc m â‰¡ m
  +-is-fold  : fold n suc m â‰¡ m + n
  *-is-fold  : fold zero (n +_) m â‰¡ m * n
  ^-is-fold  : fold 1 (m *_) n â‰¡ m ^ n
  *+-is-fold : fold p (n +_) m â‰¡ m * n + p
  ^*-is-fold : fold p (m *_) n â‰¡ m ^ n * p
  ```

* Added syntax for existential quantifiers in `Data.Product`:
  ```agda
  âˆƒ-syntax (Î» x â†’ B) = âˆƒ[ x ] B
  âˆ„-syntax (Î» x â†’ B) = âˆ„[ x ] B
  ```

* A new module `Data.Rational.Properties` has been added, containing proofs:
  ```agda
  â‰¤-reflexive : _â‰¡_ â‡’ _â‰¤_
  â‰¤-refl      : Reflexive _â‰¤_
  â‰¤-trans     : Transitive _â‰¤_
  â‰¤-antisym   : Antisymmetric _â‰¡_ _â‰¤_
  â‰¤-total     : Total _â‰¤_

  â‰¤-isPreorder : IsPreorder _â‰¡_ _â‰¤_
  â‰¤-isPartialOrder : IsPartialOrder _â‰¡_ _â‰¤_
  â‰¤-isTotalOrder : IsTotalOrder _â‰¡_ _â‰¤_
  â‰¤-isDecTotalOrder : IsDecTotalOrder _â‰¡_ _â‰¤_
  ```

* Added proofs to `Data.Sign.Properties`:
  ```agda
  opposite-cong  : opposite s â‰¡ opposite t â†’ s â‰¡ t

  *-identityË¡    : LeftIdentity + _*_
  *-identityÊ³    : RightIdentity + _*_
  *-identity     : Identity + _*_
  *-comm         : Commutative _*_
  *-assoc        : Associative _*_
  cancel-*-left  : LeftCancellative _*_
  *-cancellative : Cancellative _*_
  s*sâ‰¡+          : s * s â‰¡ +
  ```

* Added definitions to `Data.Sum`:
  ```agda
  From-injâ‚ : âˆ€ {a b} {A : Set a} {B : Set b} â†’ A âŠ B â†’ Set a
  from-injâ‚ : âˆ€ {a b} {A : Set a} {B : Set b} (x : A âŠ B) â†’ From-injâ‚ x
  From-injâ‚‚ : âˆ€ {a b} {A : Set a} {B : Set b} â†’ A âŠ B â†’ Set b
  from-injâ‚‚ : âˆ€ {a b} {A : Set a} {B : Set b} (x : A âŠ B) â†’ From-injâ‚‚ x
  ```

* Added a functor encapsulating `map` in `Data.Vec`:
  ```agda
  functor = record { _<$>_ = map}
  ```

* Added proofs to `Data.Vec.Equality`
  ```agda
  to-â‰…      : xs â‰ˆ ys â†’ xs â‰… ys
  xs++[]â‰ˆxs  : xs ++ [] â‰ˆ xs
  xs++[]â‰…xs : xs ++ [] â‰… xs
  ```

* Added proofs to `Data.Vec.Properties`
  ```agda
  lookup-map              : lookup i (map f xs) â‰¡ f (lookup i xs)
  lookup-functor-morphism : Morphism functor IdentityFunctor
  map-replicate           : map f (replicate x) â‰¡ replicate (f x)

  âŠ›-is-zipWith            : fs âŠ› xs â‰¡ zipWith _$_ fs xs
  map-is-âŠ›                : map f xs â‰¡ replicate f âŠ› xs
  zipWith-is-âŠ›            : zipWith f xs ys â‰¡ replicate f âŠ› xs âŠ› ys

  zipWith-replicateâ‚      : zipWith _âŠ•_ (replicate x) ys â‰¡ map (x âŠ•_) ys
  zipWith-replicateâ‚‚      : zipWith _âŠ•_ xs (replicate y) â‰¡ map (_âŠ• y) xs
  zipWith-mapâ‚            : zipWith _âŠ•_ (map f xs) ys â‰¡ zipWith (Î» x y â†’ f x âŠ• y) xs ys
  zipWith-mapâ‚‚            : zipWith _âŠ•_ xs (map f ys) â‰¡ zipWith (Î» x y â†’ x âŠ• f y) xs ys
  ```

* Added proofs to `Data.Vec.All.Properties`
  ```agda
  All-++âº      : All P xs â†’ All P ys â†’ All P (xs ++ ys)
  All-++Ë¡â»     : All P (xs ++ ys) â†’ All P xs
  All-++Ê³â»     : All P (xs ++ ys) â†’ All P ys
  All-++â»      : All P (xs ++ ys) â†’ All P xs Ã— All P ys

  Allâ‚‚-++âº     : Allâ‚‚ _~_ ws xs â†’ Allâ‚‚ _~_ ys zs â†’ Allâ‚‚ _~_ (ws ++ ys) (xs ++ zs)
  Allâ‚‚-++Ë¡â»    : Allâ‚‚ _~_ (ws ++ ys) (xs ++ zs) â†’ Allâ‚‚ _~_ ws xs
  Allâ‚‚-++Ê³â»    : Allâ‚‚ _~_ (ws ++ ys) (xs ++ zs) â†’ Allâ‚‚ _~_ ys zs
  Allâ‚‚-++â»     : Allâ‚‚ _~_ (ws ++ ys) (xs ++ zs) â†’ Allâ‚‚ _~_ ws xs Ã— Allâ‚‚ _~_ ys zs

  All-concatâº  : All (All P) xss â†’ All P (concat xss)
  All-concatâ»  : All P (concat xss) â†’ All (All P) xss

  Allâ‚‚-concatâº : Allâ‚‚ (Allâ‚‚ _~_) xss yss â†’ Allâ‚‚ _~_ (concat xss) (concat yss)
  Allâ‚‚-concatâ» : Allâ‚‚ _~_ (concat xss) (concat yss) â†’ Allâ‚‚ (Allâ‚‚ _~_) xss yss
  ```

* Added non-dependant versions of the application combinators in `Function` for use
  cases where the most general one leads to unsolved meta variables:
  ```agda
  _$â€²_  : (A â†’ B) â†’ (A â†’ B)
  _$!â€²_ : (A â†’ B) â†’ (A â†’ B)
  ```

* Added proofs to `Relation.Binary.Consequences`
  ```agda
  P-respâŸ¶Â¬P-resp : Symmetric _â‰ˆ_ â†’ P Respects _â‰ˆ_ â†’ (Â¬_ âˆ˜ P) Respects _â‰ˆ_
  ```

* Added conversion lemmas to `Relation.Binary.HeterogeneousEquality`
  ```agda
  â‰…-to-type-â‰¡  : {x : A} {y : B} â†’ x â‰… y â†’ A â‰¡ B
  â‰…-to-subst-â‰¡ : (p : x â‰… y) â†’ subst (Î» x â†’ x) (â‰…-to-type-â‰¡ p) x â‰¡ y
  ```
