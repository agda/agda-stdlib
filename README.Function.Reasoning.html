<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Function.Reasoning</title><link rel="stylesheet" href="Agda.css"></head><body><pre><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Some examples showing how the Function.Reasoning module</a>
<a id="165" class="Comment">-- can be used to perform &quot;functional reasoning&quot; similar to what is being</a>
<a id="239" class="Comment">-- described in: https://stackoverflow.com/q/22676703/3168666</a>
<a id="301" class="Comment">------------------------------------------------------------------------</a>

<a id="375" class="Keyword">module</a> <a id="382" href="README.Function.Reasoning.html" class="Module">README.Function.Reasoning</a> <a id="408" class="Keyword">where</a>

<a id="415" class="Comment">-- Function.Reasoning exports a flipped application (_|&gt;_) combinator</a>
<a id="485" class="Comment">-- as well as a type annotation (_∶_) combinator.</a>

<a id="536" class="Keyword">open</a> <a id="541" class="Keyword">import</a> <a id="548" href="Function.Reasoning.html" class="Module">Function.Reasoning</a>

<a id="568" class="Comment">------------------------------------------------------------------------</a>
<a id="641" class="Comment">-- A simple example</a>

<a id="662" class="Keyword">module</a> <a id="669" href="README.Function.Reasoning.html#669" class="Module">_</a> <a id="671" class="Symbol">{</a><a id="672" href="README.Function.Reasoning.html#672" class="Bound">A</a> <a id="674" href="README.Function.Reasoning.html#674" class="Bound">B</a> <a id="676" href="README.Function.Reasoning.html#676" class="Bound">C</a> <a id="678" class="Symbol">:</a> <a id="680" class="PrimitiveType">Set</a><a id="683" class="Symbol">}</a> <a id="685" class="Symbol">{</a><a id="686" href="README.Function.Reasoning.html#686" class="Bound">A→B</a> <a id="690" class="Symbol">:</a> <a id="692" href="README.Function.Reasoning.html#672" class="Bound">A</a> <a id="694" class="Symbol">→</a> <a id="696" href="README.Function.Reasoning.html#674" class="Bound">B</a><a id="697" class="Symbol">}</a> <a id="699" class="Symbol">{</a><a id="700" href="README.Function.Reasoning.html#700" class="Bound">B→C</a> <a id="704" class="Symbol">:</a> <a id="706" href="README.Function.Reasoning.html#674" class="Bound">B</a> <a id="708" class="Symbol">→</a> <a id="710" href="README.Function.Reasoning.html#676" class="Bound">C</a><a id="711" class="Symbol">}</a> <a id="713" class="Keyword">where</a>

<a id="720" class="Comment">-- Using the combinators we can, starting from a value, chain various</a>
<a id="790" class="Comment">-- functions whilst tracking the types of the intermediate results.</a>

  <a id="861" href="README.Function.Reasoning.html#861" class="Function">A→C</a> <a id="865" class="Symbol">:</a> <a id="867" href="README.Function.Reasoning.html#672" class="Bound">A</a> <a id="869" class="Symbol">→</a> <a id="871" href="README.Function.Reasoning.html#676" class="Bound">C</a>
  <a id="875" href="README.Function.Reasoning.html#861" class="Function">A→C</a> <a id="879" href="README.Function.Reasoning.html#879" class="Bound">a</a> <a id="881" class="Symbol">=</a>
       <a id="890" href="README.Function.Reasoning.html#879" class="Bound">a</a>    <a id="895" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="897" href="README.Function.Reasoning.html#672" class="Bound">A</a>
    <a id="903" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="906" href="README.Function.Reasoning.html#686" class="Bound">A→B</a>  <a id="911" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="913" href="README.Function.Reasoning.html#674" class="Bound">B</a>
    <a id="919" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="922" href="README.Function.Reasoning.html#700" class="Bound">B→C</a>  <a id="927" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="929" href="README.Function.Reasoning.html#676" class="Bound">C</a>

<a id="932" class="Comment">------------------------------------------------------------------------</a>
<a id="1005" class="Comment">-- A more concrete example</a>

<a id="1033" class="Keyword">open</a> <a id="1038" class="Keyword">import</a> <a id="1045" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="1054" class="Keyword">open</a> <a id="1059" class="Keyword">import</a> <a id="1066" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="1081" class="Keyword">open</a> <a id="1086" class="Keyword">import</a> <a id="1093" href="Data.Char.Base.html" class="Module">Data.Char.Base</a>
<a id="1108" class="Keyword">open</a> <a id="1113" class="Keyword">import</a> <a id="1120" href="Data.String.html" class="Module">Data.String</a> <a id="1132" class="Keyword">using</a> <a id="1138" class="Symbol">(</a><a id="1139" href="Agda.Builtin.String.html#165" class="Postulate">String</a><a id="1145" class="Symbol">;</a> <a id="1147" href="Data.String.Base.html#869" class="Function">toList</a><a id="1153" class="Symbol">;</a> <a id="1155" href="Data.String.Base.html#924" class="Function">fromList</a><a id="1163" class="Symbol">)</a>
<a id="1165" class="Keyword">open</a> <a id="1170" class="Keyword">import</a> <a id="1177" href="Data.String.Unsafe.html" class="Module">Data.String.Unsafe</a> <a id="1196" class="Keyword">using</a> <a id="1202" class="Symbol">(</a><a id="1203" href="Data.String.Unsafe.html#1266" class="Function Operator">_==_</a><a id="1207" class="Symbol">)</a>
<a id="1209" class="Keyword">open</a> <a id="1214" class="Keyword">import</a> <a id="1221" href="Function.html" class="Module">Function</a>
<a id="1230" class="Keyword">open</a> <a id="1235" class="Keyword">import</a> <a id="1242" href="Data.Bool.html" class="Module">Data.Bool</a>
<a id="1252" class="Keyword">open</a> <a id="1257" class="Keyword">import</a> <a id="1264" href="Data.Product.html" class="Module">Data.Product</a> <a id="1277" class="Symbol">as</a> <a id="1280" class="Module">P</a> <a id="1282" class="Keyword">using</a> <a id="1288" class="Symbol">(</a><a id="1289" href="Data.Product.html#1353" class="Function Operator">_×_</a><a id="1292" class="Symbol">;</a> <a id="1294" href="Data.Product.html#1973" class="Function Operator">&lt;_,_&gt;</a><a id="1299" class="Symbol">;</a> <a id="1301" href="Data.Product.html#3464" class="Function">uncurry</a><a id="1308" class="Symbol">;</a> <a id="1310" href="Agda.Builtin.Sigma.html#155" class="Field">proj₁</a><a id="1315" class="Symbol">)</a>
<a id="1317" class="Keyword">open</a> <a id="1322" class="Keyword">import</a> <a id="1329" href="Agda.Builtin.Equality.html" class="Module">Agda.Builtin.Equality</a>

<a id="1352" class="Comment">-- This can give us for instance this decomposition of a function</a>
<a id="1418" class="Comment">-- collecting all of the substrings of the input which happen to be</a>
<a id="1486" class="Comment">-- palindromes:</a>

<a id="subpalindromes"></a><a id="1503" href="README.Function.Reasoning.html#1503" class="Function">subpalindromes</a> <a id="1518" class="Symbol">:</a> <a id="1520" href="Agda.Builtin.String.html#165" class="Postulate">String</a> <a id="1527" class="Symbol">→</a> <a id="1529" href="Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="1534" href="Agda.Builtin.String.html#165" class="Postulate">String</a>
<a id="1541" href="README.Function.Reasoning.html#1503" class="Function">subpalindromes</a> <a id="1556" href="README.Function.Reasoning.html#1556" class="Bound">str</a> <a id="1560" class="Symbol">=</a> <a id="1562" class="Keyword">let</a> <a id="1566" href="README.Function.Reasoning.html#1566" class="Bound">Chars</a> <a id="1572" class="Symbol">=</a> <a id="1574" href="Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="1579" href="Agda.Builtin.Char.html#132" class="Postulate">Char</a> <a id="1584" class="Keyword">in</a>
     <a id="1592" href="README.Function.Reasoning.html#1556" class="Bound">str</a>                                   <a id="1630" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="1632" href="Agda.Builtin.String.html#165" class="Postulate">String</a>
  <a id="1641" class="Comment">-- first generate the substrings</a>
  <a id="1676" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="1679" href="Data.String.Base.html#869" class="Function">toList</a>                                <a id="1717" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="1719" href="README.Function.Reasoning.html#1566" class="Bound">Chars</a>
  <a id="1727" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="1730" href="Data.List.Base.html#4462" class="Function">inits</a>                                 <a id="1768" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="1770" href="Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="1775" href="README.Function.Reasoning.html#1566" class="Bound">Chars</a>
  <a id="1783" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="1786" href="Data.List.Base.html#3488" class="Function">concatMap</a> <a id="1796" href="Data.List.Base.html#4583" class="Function">tails</a>                       <a id="1824" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="1826" href="Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="1831" href="README.Function.Reasoning.html#1566" class="Bound">Chars</a>
  <a id="1839" class="Comment">-- then only keeps the ones which are not singletons</a>
  <a id="1894" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="1897" href="Data.List.Base.html#7596" class="Function">filter</a> <a id="1904" class="Symbol">(λ</a> <a id="1907" href="README.Function.Reasoning.html#1907" class="Bound">cs</a> <a id="1910" class="Symbol">→</a> <a id="1912" class="Number">2</a> <a id="1914" href="Data.Nat.Properties.html#2603" class="Function Operator">≤?</a> <a id="1917" href="Data.List.Base.html#4008" class="Function">length</a> <a id="1924" href="README.Function.Reasoning.html#1907" class="Bound">cs</a><a id="1926" class="Symbol">)</a>        <a id="1935" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="1937" href="Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="1942" href="README.Function.Reasoning.html#1566" class="Bound">Chars</a>
  <a id="1950" class="Comment">-- only keep the ones that are palindromes</a>
  <a id="1995" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="1998" href="Data.List.Base.html#1120" class="Function">map</a> <a id="2002" href="Data.Product.html#1973" class="Function Operator">&lt;</a> <a id="2004" href="Data.String.Base.html#924" class="Function">fromList</a> <a id="2013" href="Data.Product.html#1973" class="Function Operator">,</a> <a id="2015" href="Data.String.Base.html#924" class="Function">fromList</a> <a id="2024" href="Function.html#769" class="Function Operator">∘</a> <a id="2026" href="Data.List.Base.html#8504" class="Function">reverse</a> <a id="2034" href="Data.Product.html#1973" class="Function Operator">&gt;</a> <a id="2036" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="2038" href="Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="2043" class="Symbol">(</a><a id="2044" href="Agda.Builtin.String.html#165" class="Postulate">String</a> <a id="2051" href="Data.Product.html#1353" class="Function Operator">×</a> <a id="2053" href="Agda.Builtin.String.html#165" class="Postulate">String</a><a id="2059" class="Symbol">)</a>
  <a id="2063" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="2066" href="Data.List.Base.html#9621" class="Function">boolFilter</a> <a id="2077" class="Symbol">(</a><a id="2078" href="Data.Product.html#3464" class="Function">uncurry</a> <a id="2086" href="Data.String.Unsafe.html#1266" class="Function Operator">_==_</a><a id="2090" class="Symbol">)</a>             <a id="2104" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="2106" href="Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="2111" class="Symbol">(</a><a id="2112" href="Agda.Builtin.String.html#165" class="Postulate">String</a> <a id="2119" href="Data.Product.html#1353" class="Function Operator">×</a> <a id="2121" href="Agda.Builtin.String.html#165" class="Postulate">String</a><a id="2127" class="Symbol">)</a>
  <a id="2131" href="Function.html#2333" class="Function Operator">|&gt;</a> <a id="2134" href="Data.List.Base.html#1120" class="Function">map</a> <a id="2138" href="Agda.Builtin.Sigma.html#155" class="Field">proj₁</a>                             <a id="2172" href="Function.Reasoning.html#429" class="Function">∶</a> <a id="2174" href="Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="2179" href="Agda.Builtin.String.html#165" class="Postulate">String</a>

<a id="2187" class="Comment">-- Test cases</a>

<a id="2202" href="README.Function.Reasoning.html#2202" class="Function">_</a> <a id="2204" class="Symbol">:</a> <a id="2206" href="README.Function.Reasoning.html#1503" class="Function">subpalindromes</a> <a id="2221" class="String">&quot;doctoresreverse&quot;</a> <a id="2239" href="Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="2241" class="String">&quot;eve&quot;</a> <a id="2247" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2249" class="String">&quot;rever&quot;</a> <a id="2257" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2259" class="String">&quot;srevers&quot;</a> <a id="2269" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2271" class="String">&quot;esreverse&quot;</a> <a id="2283" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2285" href="Agda.Builtin.List.html#117" class="InductiveConstructor">[]</a>
<a id="2288" class="Symbol">_</a> <a id="2290" class="Symbol">=</a> <a id="2292" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="2298" href="README.Function.Reasoning.html#2298" class="Function">_</a> <a id="2300" class="Symbol">:</a> <a id="2302" href="README.Function.Reasoning.html#1503" class="Function">subpalindromes</a> <a id="2317" class="String">&quot;elle-meme&quot;</a> <a id="2329" href="Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="2331" class="String">&quot;ll&quot;</a> <a id="2336" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2338" class="String">&quot;elle&quot;</a> <a id="2345" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2347" class="String">&quot;mem&quot;</a> <a id="2353" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2355" class="String">&quot;eme&quot;</a> <a id="2361" href="Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="2363" href="Agda.Builtin.List.html#117" class="InductiveConstructor">[]</a>
<a id="2366" class="Symbol">_</a> <a id="2368" class="Symbol">=</a> <a id="2370" href="Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
</pre></body></html>