<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Nary</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the generic n-ary operations the stdlib provides</a>
<a id="179" class="Comment">-- can be used</a>
<a id="194" class="Comment">------------------------------------------------------------------------</a>

<a id="268" class="Symbol">{-#</a> <a id="272" class="Keyword">OPTIONS</a> <a id="280" class="Pragma">--without-K</a> <a id="292" class="Pragma">--safe</a> <a id="299" class="Symbol">#-}</a>

<a id="304" class="Keyword">module</a> <a id="311" href="README.Nary.html" class="Module">README.Nary</a> <a id="323" class="Keyword">where</a>

<a id="330" class="Keyword">open</a> <a id="335" class="Keyword">import</a> <a id="342" href="Level.html" class="Module">Level</a> <a id="348" class="Keyword">using</a> <a id="354" class="Symbol">(</a><a id="355" href="Agda.Primitive.html#408" class="Postulate">Level</a><a id="360" class="Symbol">)</a>
<a id="362" class="Keyword">open</a> <a id="367" class="Keyword">import</a> <a id="374" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="388" class="Keyword">open</a> <a id="393" class="Keyword">import</a> <a id="400" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="441" class="Keyword">using</a> <a id="447" class="Symbol">(</a><a id="448" href="Data.Fin.Base.html#967" class="Datatype">Fin</a><a id="451" class="Symbol">;</a> <a id="453" href="Data.Fin.Base.html#1708" class="Function">fromℕ</a><a id="458" class="Symbol">;</a> <a id="460" href="Data.Fin.html#730" class="Function Operator">#_</a><a id="462" class="Symbol">;</a> <a id="464" href="Data.Fin.Base.html#2851" class="Function">inject₁</a><a id="471" class="Symbol">)</a>
<a id="473" class="Keyword">open</a> <a id="478" class="Keyword">import</a> <a id="485" href="Data.List.html" class="Module">Data.List</a>
<a id="495" class="Keyword">open</a> <a id="500" class="Keyword">import</a> <a id="507" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>
<a id="528" class="Keyword">open</a> <a id="533" class="Keyword">import</a> <a id="540" href="Data.Product.html" class="Module">Data.Product</a> <a id="553" class="Keyword">using</a> <a id="559" class="Symbol">(</a><a id="560" href="Data.Product.html#1162" class="Function Operator">_×_</a><a id="563" class="Symbol">;</a> <a id="565" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a><a id="568" class="Symbol">)</a>
<a id="570" class="Keyword">open</a> <a id="575" class="Keyword">import</a> <a id="582" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="591" class="Keyword">using</a> <a id="597" class="Symbol">(</a><a id="598" href="Data.Sum.Base.html#662" class="InductiveConstructor">inj₁</a><a id="602" class="Symbol">;</a> <a id="604" href="Data.Sum.Base.html#687" class="InductiveConstructor">inj₂</a><a id="608" class="Symbol">)</a>
<a id="610" class="Keyword">open</a> <a id="615" class="Keyword">import</a> <a id="622" href="Function.html" class="Module">Function</a>
<a id="631" class="Keyword">open</a> <a id="636" class="Keyword">import</a> <a id="643" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="660" class="Keyword">open</a> <a id="665" class="Keyword">import</a> <a id="672" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="688" class="Keyword">using</a> <a id="694" class="Symbol">(</a><a id="695" class="Keyword">module</a> <a id="702" href="Relation.Binary.Core.html#3694" class="Module">Tri</a><a id="705" class="Symbol">);</a> <a id="708" class="Keyword">open</a> <a id="713" href="Relation.Binary.Core.html#3694" class="Module">Tri</a>
<a id="717" class="Keyword">open</a> <a id="722" class="Keyword">import</a> <a id="729" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="768" class="Keyword">private</a>
  <a id="778" class="Keyword">variable</a>
    <a id="791" href="README.Nary.html#791" class="Generalizable">a</a> <a id="793" href="README.Nary.html#793" class="Generalizable">b</a> <a id="795" href="README.Nary.html#795" class="Generalizable">c</a> <a id="797" href="README.Nary.html#797" class="Generalizable">d</a> <a id="799" href="README.Nary.html#799" class="Generalizable">e</a> <a id="801" class="Symbol">:</a> <a id="803" href="Agda.Primitive.html#408" class="Postulate">Level</a>
    <a id="813" href="README.Nary.html#813" class="Generalizable">A</a> <a id="815" class="Symbol">:</a> <a id="817" class="PrimitiveType">Set</a> <a id="821" href="README.Nary.html#791" class="Generalizable">a</a>
    <a id="827" href="README.Nary.html#827" class="Generalizable">B</a> <a id="829" class="Symbol">:</a> <a id="831" class="PrimitiveType">Set</a> <a id="835" href="README.Nary.html#793" class="Generalizable">b</a>
    <a id="841" href="README.Nary.html#841" class="Generalizable">C</a> <a id="843" class="Symbol">:</a> <a id="845" class="PrimitiveType">Set</a> <a id="849" href="README.Nary.html#795" class="Generalizable">c</a>
    <a id="855" href="README.Nary.html#855" class="Generalizable">D</a> <a id="857" class="Symbol">:</a> <a id="859" class="PrimitiveType">Set</a> <a id="863" href="README.Nary.html#797" class="Generalizable">d</a>
    <a id="869" href="README.Nary.html#869" class="Generalizable">E</a> <a id="871" class="Symbol">:</a> <a id="873" class="PrimitiveType">Set</a> <a id="877" href="README.Nary.html#799" class="Generalizable">e</a>

<a id="880" class="Comment">------------------------------------------------------------------------</a>
<a id="953" class="Comment">-- Introduction</a>
<a id="969" class="Comment">------------------------------------------------------------------------</a>

<a id="1043" class="Comment">-- Function.Nary.NonDependent and Data.Product.N-ary.Heterogeneous provide</a>
<a id="1118" class="Comment">-- a generic representation of n-ary heterogeneous (non dependent) products</a>
<a id="1194" class="Comment">-- and the corresponding types of (non-dependent) n-ary functions. The</a>
<a id="1265" class="Comment">-- representation works well with inference thus allowing us to use generic</a>
<a id="1341" class="Comment">-- combinators to manipulate such functions.</a>

<a id="1387" class="Keyword">open</a> <a id="1392" class="Keyword">import</a> <a id="1399" href="Data.Product.Nary.NonDependent.html" class="Module">Data.Product.Nary.NonDependent</a>
<a id="1430" class="Keyword">open</a> <a id="1435" class="Keyword">import</a> <a id="1442" href="Function.Nary.NonDependent.html" class="Module">Function.Nary.NonDependent</a>
<a id="1469" class="Keyword">open</a> <a id="1474" class="Keyword">import</a> <a id="1481" href="Relation.Nary.html" class="Module">Relation.Nary</a>


<a id="1497" class="Comment">------------------------------------------------------------------------</a>
<a id="1570" class="Comment">-- Generalised equality-manipulating combinators</a>
<a id="1619" class="Comment">------------------------------------------------------------------------</a>

<a id="1693" class="Comment">-- By default the standard library provides users with (we are leaving out</a>
<a id="1768" class="Comment">-- the implicit arguments here):</a>
<a id="1801" class="Comment">--</a>
<a id="1804" class="Comment">-- cong   : (f : A₁      → B) → a₁ ≡ b₁           → f a₁   ≡ f b₁</a>
<a id="1870" class="Comment">-- cong₂  : (f : A₁ → A₂ → B) → a₁ ≡ b₁ → a₂ ≡ b₂ → f a₁ a₂ ≡ f b₁ b₂</a>
<a id="1940" class="Comment">--</a>
<a id="1943" class="Comment">-- and</a>
<a id="1950" class="Comment">--</a>
<a id="1953" class="Comment">-- subst  : (P : A₁      → Set p) → a₁ ≡ b₁           → P a₁    → P b₁</a>
<a id="2024" class="Comment">-- subst₂ : (P : A₁ → A₂ → Set p) → a₁ ≡ b₁ → a₂ ≡ b₂ → P a₁ a₂ → P b₁ b₂</a>
<a id="2098" class="Comment">--</a>
<a id="2101" class="Comment">-- This pattern can be generalised to any natural number `n`. Thanks to our</a>
<a id="2177" class="Comment">-- library for n-ary functions, we can write the types and implementations</a>
<a id="2252" class="Comment">-- of `congₙ` and `substₙ`.</a>

<a id="2281" class="Comment">------------------------------------------------------------------------</a>
<a id="2354" class="Comment">-- congₙ : ∀ n (f : A₁ → ⋯ → Aₙ → B) →</a>
<a id="2393" class="Comment">--         a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → f a₁ ⋯ aₙ ≡ f b₁ ⋯ bₙ</a>

<a id="2449" class="Comment">-- It may be used directly to prove something:</a>

<a id="2497" href="README.Nary.html#2497" class="Function">_</a> <a id="2499" class="Symbol">:</a> <a id="2501" class="Symbol">∀</a> <a id="2503" class="Symbol">(</a><a id="2504" href="README.Nary.html#2504" class="Bound">as</a> <a id="2507" href="README.Nary.html#2507" class="Bound">bs</a> <a id="2510" href="README.Nary.html#2510" class="Bound">cs</a> <a id="2513" class="Symbol">:</a> <a id="2515" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="2520" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="2521" class="Symbol">)</a> <a id="2523" class="Symbol">→</a>
       <a id="2532" href="Data.List.Base.html#3050" class="Function">zip</a> <a id="2536" class="Symbol">(</a><a id="2537" href="Data.List.Base.html#3050" class="Function">zip</a> <a id="2541" class="Symbol">(</a><a id="2542" href="README.Nary.html#2504" class="Bound">as</a> <a id="2545" href="Data.List.Base.html#1570" class="Function Operator">++</a> <a id="2548" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2550" class="Symbol">)</a> <a id="2552" class="Symbol">(</a><a id="2553" href="Data.List.Base.html#1304" class="Function">map</a> <a id="2557" href="Function.html#708" class="Function">id</a> <a id="2560" href="README.Nary.html#2510" class="Bound">cs</a><a id="2562" class="Symbol">))</a> <a id="2565" class="Symbol">(</a><a id="2566" href="Data.List.Base.html#8564" class="Function">reverse</a> <a id="2574" class="Symbol">(</a><a id="2575" href="Data.List.Base.html#8564" class="Function">reverse</a> <a id="2583" href="README.Nary.html#2507" class="Bound">bs</a><a id="2585" class="Symbol">))</a>
     <a id="2593" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="2595" href="Data.List.Base.html#3050" class="Function">zip</a> <a id="2599" class="Symbol">(</a><a id="2600" href="Data.List.Base.html#3050" class="Function">zip</a> <a id="2604" href="README.Nary.html#2504" class="Bound">as</a> <a id="2607" href="README.Nary.html#2510" class="Bound">cs</a><a id="2609" class="Symbol">)</a> <a id="2611" href="README.Nary.html#2507" class="Bound">bs</a>
<a id="2614" class="Symbol">_</a> <a id="2616" class="Symbol">=</a> <a id="2618" class="Symbol">λ</a> <a id="2620" href="README.Nary.html#2620" class="Bound">as</a> <a id="2623" href="README.Nary.html#2623" class="Bound">bs</a> <a id="2626" href="README.Nary.html#2626" class="Bound">cs</a> <a id="2629" class="Symbol">→</a> <a id="2631" href="Function.Nary.NonDependent.html#1943" class="Function">congₙ</a> <a id="2637" class="Number">3</a> <a id="2639" class="Symbol">(λ</a> <a id="2642" href="README.Nary.html#2642" class="Bound">as</a> <a id="2645" href="README.Nary.html#2645" class="Bound">bs</a> <a id="2648" class="Symbol">→</a> <a id="2650" href="Data.List.Base.html#3050" class="Function">zip</a> <a id="2654" class="Symbol">(</a><a id="2655" href="Data.List.Base.html#3050" class="Function">zip</a> <a id="2659" href="README.Nary.html#2642" class="Bound">as</a> <a id="2662" href="README.Nary.html#2645" class="Bound">bs</a><a id="2664" class="Symbol">))</a>
                         <a id="2692" class="Symbol">(</a><a id="2693" href="Data.List.Properties.html#5005" class="Function">++-identityʳ</a> <a id="2706" href="README.Nary.html#2620" class="Bound">as</a><a id="2708" class="Symbol">)</a>
                         <a id="2735" class="Symbol">(</a><a id="2736" href="Data.List.Properties.html#2466" class="Function">map-id</a> <a id="2743" href="README.Nary.html#2626" class="Bound">cs</a><a id="2745" class="Symbol">)</a>
                         <a id="2772" class="Symbol">(</a><a id="2773" href="Data.List.Properties.html#29170" class="Function">reverse-involutive</a> <a id="2792" href="README.Nary.html#2623" class="Bound">bs</a><a id="2794" class="Symbol">)</a>

<a id="2797" class="Comment">-- Or as part of a longer derivation:</a>

<a id="2836" href="README.Nary.html#2836" class="Function">_</a> <a id="2838" class="Symbol">:</a> <a id="2840" class="Symbol">∀</a> <a id="2842" href="README.Nary.html#2842" class="Bound">m</a> <a id="2844" href="README.Nary.html#2844" class="Bound">n</a> <a id="2846" href="README.Nary.html#2846" class="Bound">p</a> <a id="2848" href="README.Nary.html#2848" class="Bound">q</a> <a id="2850" class="Symbol">→</a> <a id="2852" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="2856" class="Symbol">(</a><a id="2857" href="README.Nary.html#2842" class="Bound">m</a> <a id="2859" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2861" class="Symbol">(</a><a id="2862" href="README.Nary.html#2846" class="Bound">p</a> <a id="2864" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="2866" href="README.Nary.html#2844" class="Bound">n</a><a id="2867" class="Symbol">)</a> <a id="2869" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2871" class="Symbol">(</a><a id="2872" href="README.Nary.html#2848" class="Bound">q</a> <a id="2874" href="Data.Nat.Base.html#2006" class="Function Operator">^</a> <a id="2876" class="Symbol">(</a><a id="2877" href="README.Nary.html#2842" class="Bound">m</a> <a id="2879" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2881" href="README.Nary.html#2844" class="Bound">n</a><a id="2882" class="Symbol">)))</a>
              <a id="2900" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="2902" class="Symbol">(</a><a id="2903" href="README.Nary.html#2842" class="Bound">m</a> <a id="2905" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2907" class="Number">0</a><a id="2908" class="Symbol">)</a> <a id="2910" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2912" class="Symbol">(</a><a id="2913" href="README.Nary.html#2844" class="Bound">n</a> <a id="2915" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="2917" href="README.Nary.html#2846" class="Bound">p</a><a id="2918" class="Symbol">)</a> <a id="2920" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2922" class="Symbol">(</a><a id="2923" href="README.Nary.html#2848" class="Bound">q</a> <a id="2925" href="Data.Nat.Base.html#2006" class="Function Operator">^</a> <a id="2927" href="README.Nary.html#2842" class="Bound">m</a> <a id="2929" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="2931" href="README.Nary.html#2848" class="Bound">q</a> <a id="2933" href="Data.Nat.Base.html#2006" class="Function Operator">^</a> <a id="2935" href="README.Nary.html#2844" class="Bound">n</a><a id="2936" class="Symbol">)</a> <a id="2938" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2940" class="Number">1</a>
<a id="2942" class="Symbol">_</a> <a id="2944" class="Symbol">=</a> <a id="2946" class="Symbol">λ</a> <a id="2948" href="README.Nary.html#2948" class="Bound">m</a> <a id="2950" href="README.Nary.html#2950" class="Bound">n</a> <a id="2952" href="README.Nary.html#2952" class="Bound">p</a> <a id="2954" href="README.Nary.html#2954" class="Bound">q</a> <a id="2956" class="Symbol">→</a> <a id="2958" href="Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
    <a id="2968" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="2972" class="Symbol">(</a><a id="2973" href="README.Nary.html#2948" class="Bound">m</a> <a id="2975" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2977" class="Symbol">(</a><a id="2978" href="README.Nary.html#2952" class="Bound">p</a> <a id="2980" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="2982" href="README.Nary.html#2950" class="Bound">n</a><a id="2983" class="Symbol">)</a> <a id="2985" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2987" class="Symbol">(</a><a id="2988" href="README.Nary.html#2954" class="Bound">q</a> <a id="2990" href="Data.Nat.Base.html#2006" class="Function Operator">^</a> <a id="2992" class="Symbol">(</a><a id="2993" href="README.Nary.html#2948" class="Bound">m</a> <a id="2995" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2997" href="README.Nary.html#2950" class="Bound">n</a><a id="2998" class="Symbol">)))</a> <a id="3002" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="3005" href="Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="3012" class="Number">1</a> <a id="3014" class="Symbol">_</a> <a id="3016" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
    <a id="3022" href="README.Nary.html#2948" class="Bound">m</a> <a id="3024" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3026" class="Symbol">(</a><a id="3027" href="README.Nary.html#2952" class="Bound">p</a> <a id="3029" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="3031" href="README.Nary.html#2950" class="Bound">n</a><a id="3032" class="Symbol">)</a> <a id="3034" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3036" class="Symbol">(</a><a id="3037" href="README.Nary.html#2954" class="Bound">q</a> <a id="3039" href="Data.Nat.Base.html#2006" class="Function Operator">^</a> <a id="3041" class="Symbol">(</a><a id="3042" href="README.Nary.html#2948" class="Bound">m</a> <a id="3044" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3046" href="README.Nary.html#2950" class="Bound">n</a><a id="3047" class="Symbol">))</a> <a id="3050" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3052" class="Number">1</a>   <a id="3056" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="3059" href="Function.Nary.NonDependent.html#1943" class="Function">congₙ</a> <a id="3065" class="Number">3</a> <a id="3067" class="Symbol">(λ</a> <a id="3070" href="README.Nary.html#3070" class="Bound">m</a> <a id="3072" href="README.Nary.html#3072" class="Bound">n</a> <a id="3074" href="README.Nary.html#3074" class="Bound">p</a> <a id="3076" class="Symbol">→</a> <a id="3078" href="README.Nary.html#3070" class="Bound">m</a> <a id="3080" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3082" href="README.Nary.html#3072" class="Bound">n</a> <a id="3084" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3086" href="README.Nary.html#3074" class="Bound">p</a> <a id="3088" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3090" class="Number">1</a><a id="3091" class="Symbol">)</a>
                                                 <a id="3142" class="Symbol">(</a><a id="3143" href="Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="3150" class="Number">0</a> <a id="3152" href="README.Nary.html#2948" class="Bound">m</a><a id="3153" class="Symbol">)</a>
                                                 <a id="3204" class="Symbol">(</a><a id="3205" href="Data.Nat.Properties.html#17772" class="Function">*-comm</a> <a id="3212" href="README.Nary.html#2952" class="Bound">p</a> <a id="3214" href="README.Nary.html#2950" class="Bound">n</a><a id="3215" class="Symbol">)</a>
                                                 <a id="3266" class="Symbol">(</a><a id="3267" href="Data.Nat.Properties.html#24004" class="Function">^-distribˡ-+-*</a> <a id="3282" href="README.Nary.html#2954" class="Bound">q</a> <a id="3284" href="README.Nary.html#2948" class="Bound">m</a> <a id="3286" href="README.Nary.html#2950" class="Bound">n</a><a id="3287" class="Symbol">)</a>
                                       <a id="3328" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
    <a id="3334" href="README.Nary.html#2948" class="Bound">m</a> <a id="3336" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3338" class="Number">0</a> <a id="3340" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3342" href="README.Nary.html#2950" class="Bound">n</a> <a id="3344" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="3346" href="README.Nary.html#2952" class="Bound">p</a> <a id="3348" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3350" class="Symbol">(</a><a id="3351" href="README.Nary.html#2954" class="Bound">q</a> <a id="3353" href="Data.Nat.Base.html#2006" class="Function Operator">^</a> <a id="3355" href="README.Nary.html#2948" class="Bound">m</a><a id="3356" class="Symbol">)</a> <a id="3358" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="3360" class="Symbol">(</a><a id="3361" href="README.Nary.html#2954" class="Bound">q</a> <a id="3363" href="Data.Nat.Base.html#2006" class="Function Operator">^</a> <a id="3365" href="README.Nary.html#2950" class="Bound">n</a><a id="3366" class="Symbol">)</a> <a id="3368" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3370" class="Number">1</a> <a id="3372" href="Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a> <a id="3374" class="Keyword">where</a> <a id="3380" class="Keyword">open</a> <a id="3385" href="Relation.Binary.PropositionalEquality.Core.html#2499" class="Module">≡-Reasoning</a>

<a id="3398" class="Comment">-- Partial application of the functional argument is fine: the number of arguments</a>
<a id="3481" class="Comment">-- `congₙ` is going to take is determined by its first argument (a natural number)</a>
<a id="3564" class="Comment">-- and not by the type of the function it works on.</a>

<a id="3617" href="README.Nary.html#3617" class="Function">_</a> <a id="3619" class="Symbol">:</a> <a id="3621" class="Symbol">∀</a> <a id="3623" href="README.Nary.html#3623" class="Bound">m</a> <a id="3625" class="Symbol">→</a> <a id="3627" class="Symbol">(</a><a id="3628" href="README.Nary.html#3623" class="Bound">m</a> <a id="3630" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+_</a><a id="3632" class="Symbol">)</a> <a id="3634" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3636" class="Symbol">((</a><a id="3638" href="README.Nary.html#3623" class="Bound">m</a> <a id="3640" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3642" class="Number">0</a><a id="3643" class="Symbol">)</a> <a id="3645" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+_</a><a id="3647" class="Symbol">)</a>
<a id="3649" class="Symbol">_</a> <a id="3651" class="Symbol">=</a> <a id="3653" class="Symbol">λ</a> <a id="3655" href="README.Nary.html#3655" class="Bound">m</a> <a id="3657" class="Symbol">→</a> <a id="3659" href="Function.Nary.NonDependent.html#1943" class="Function">congₙ</a> <a id="3665" class="Number">1</a> <a id="3667" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+_</a> <a id="3671" class="Symbol">(</a><a id="3672" href="Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="3679" class="Number">0</a> <a id="3681" href="README.Nary.html#3655" class="Bound">m</a><a id="3682" class="Symbol">)</a>

<a id="3685" class="Comment">-- We don&#39;t have to work on the function&#39;s first argument either: we can just as</a>
<a id="3766" class="Comment">-- easily use `congₙ` to act on the second one by `flip`ping it. See `holeₙ` for</a>
<a id="3847" class="Comment">-- a generalisation of this idea allowing to target *any* of the function&#39;s</a>
<a id="3923" class="Comment">-- arguments and not just the first or second one.</a>

<a id="3975" href="README.Nary.html#3975" class="Function">_</a> <a id="3977" class="Symbol">:</a> <a id="3979" class="Symbol">∀</a> <a id="3981" href="README.Nary.html#3981" class="Bound">m</a> <a id="3983" class="Symbol">→</a> <a id="3985" class="Symbol">(</a><a id="3986" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+</a> <a id="3989" href="README.Nary.html#3981" class="Bound">m</a><a id="3990" class="Symbol">)</a> <a id="3992" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3994" class="Symbol">(</a><a id="3995" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+</a> <a id="3998" class="Symbol">(</a><a id="3999" href="README.Nary.html#3981" class="Bound">m</a> <a id="4001" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4003" class="Number">0</a><a id="4004" class="Symbol">))</a>
<a id="4007" class="Symbol">_</a> <a id="4009" class="Symbol">=</a> <a id="4011" class="Symbol">λ</a> <a id="4013" href="README.Nary.html#4013" class="Bound">m</a> <a id="4015" class="Symbol">→</a> <a id="4017" href="Function.Nary.NonDependent.html#1943" class="Function">congₙ</a> <a id="4023" class="Number">1</a> <a id="4025" class="Symbol">(</a><a id="4026" href="Function.html#1300" class="Function">flip</a> <a id="4031" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+_</a><a id="4034" class="Symbol">)</a> <a id="4036" class="Symbol">(</a><a id="4037" href="Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="4044" class="Number">0</a> <a id="4046" href="README.Nary.html#4013" class="Bound">m</a><a id="4047" class="Symbol">)</a>

<a id="4050" class="Comment">------------------------------------------------------------------------</a>
<a id="4123" class="Comment">-- substₙ : (P : A₁ → ⋯ → Aₙ → Set p) →</a>
<a id="4163" class="Comment">--          a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → P a₁ ⋯ aₙ → P b₁ ⋯ bₙ</a>

<a id="4220" class="Comment">-- We can play the same type of game with subst</a>

<a id="4269" class="Keyword">open</a> <a id="4274" class="Keyword">import</a> <a id="4281" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a> <a id="4298" class="Keyword">using</a> <a id="4304" class="Symbol">(</a><a id="4305" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a><a id="4315" class="Symbol">)</a>

<a id="4318" class="Comment">-- Because we know from the definition `mod-helper` that this equation holds:</a>
<a id="4396" class="Comment">-- mod-helper k m (suc n) (suc j) = mod-helper (suc k) m n j</a>
<a id="4457" class="Comment">-- we should be able to prove the slightly modified statement by transforming</a>
<a id="4535" class="Comment">-- all the `x + 1` into `suc x`. We can do so using `substₙ`.</a>

<a id="4598" href="README.Nary.html#4598" class="Function">_</a> <a id="4600" class="Symbol">:</a> <a id="4602" class="Symbol">∀</a> <a id="4604" href="README.Nary.html#4604" class="Bound">k</a> <a id="4606" href="README.Nary.html#4606" class="Bound">m</a> <a id="4608" href="README.Nary.html#4608" class="Bound">n</a> <a id="4610" href="README.Nary.html#4610" class="Bound">j</a> <a id="4612" class="Symbol">→</a> <a id="4614" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a> <a id="4625" href="README.Nary.html#4604" class="Bound">k</a> <a id="4627" href="README.Nary.html#4606" class="Bound">m</a> <a id="4629" class="Symbol">(</a><a id="4630" href="README.Nary.html#4608" class="Bound">n</a> <a id="4632" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4634" class="Number">1</a><a id="4635" class="Symbol">)</a> <a id="4637" class="Symbol">(</a><a id="4638" href="README.Nary.html#4610" class="Bound">j</a> <a id="4640" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4642" class="Number">1</a><a id="4643" class="Symbol">)</a> <a id="4645" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4647" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a> <a id="4658" class="Symbol">(</a><a id="4659" href="README.Nary.html#4604" class="Bound">k</a> <a id="4661" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4663" class="Number">1</a><a id="4664" class="Symbol">)</a> <a id="4666" href="README.Nary.html#4606" class="Bound">m</a> <a id="4668" href="README.Nary.html#4608" class="Bound">n</a> <a id="4670" href="README.Nary.html#4610" class="Bound">j</a>
<a id="4672" class="Symbol">_</a> <a id="4674" class="Symbol">=</a> <a id="4676" class="Symbol">λ</a> <a id="4678" href="README.Nary.html#4678" class="Bound">k</a> <a id="4680" href="README.Nary.html#4680" class="Bound">m</a> <a id="4682" href="README.Nary.html#4682" class="Bound">n</a> <a id="4684" href="README.Nary.html#4684" class="Bound">j</a> <a id="4686" class="Symbol">→</a>
    <a id="4692" class="Keyword">let</a> <a id="4696" href="README.Nary.html#4696" class="Bound">P</a> <a id="4698" href="README.Nary.html#4698" class="Bound">sk</a> <a id="4701" href="README.Nary.html#4701" class="Bound">sn</a> <a id="4704" href="README.Nary.html#4704" class="Bound">sj</a> <a id="4707" class="Symbol">=</a> <a id="4709" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a> <a id="4720" href="README.Nary.html#4678" class="Bound">k</a> <a id="4722" href="README.Nary.html#4680" class="Bound">m</a> <a id="4724" href="README.Nary.html#4701" class="Bound">sn</a> <a id="4727" href="README.Nary.html#4704" class="Bound">sj</a> <a id="4730" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4732" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a> <a id="4743" href="README.Nary.html#4698" class="Bound">sk</a> <a id="4746" href="README.Nary.html#4680" class="Bound">m</a> <a id="4748" href="README.Nary.html#4682" class="Bound">n</a> <a id="4750" href="README.Nary.html#4684" class="Bound">j</a>
    <a id="4756" class="Keyword">in</a> <a id="4759" href="Relation.Nary.html#3593" class="Function">substₙ</a> <a id="4766" href="README.Nary.html#4696" class="Bound">P</a> <a id="4768" class="Symbol">(</a><a id="4769" href="Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="4776" class="Number">1</a> <a id="4778" href="README.Nary.html#4678" class="Bound">k</a><a id="4779" class="Symbol">)</a> <a id="4781" class="Symbol">(</a><a id="4782" href="Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="4789" class="Number">1</a> <a id="4791" href="README.Nary.html#4682" class="Bound">n</a><a id="4792" class="Symbol">)</a> <a id="4794" class="Symbol">(</a><a id="4795" href="Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="4802" class="Number">1</a> <a id="4804" href="README.Nary.html#4684" class="Bound">j</a><a id="4805" class="Symbol">)</a> <a id="4807" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="4813" class="Comment">-----------------------------------------------------------------------</a>
<a id="4885" class="Comment">-- Generic programs working on n-ary products &amp; functions</a>
<a id="4943" class="Comment">-----------------------------------------------------------------------</a>

<a id="5016" class="Comment">-----------------------------------------------------------------------</a>
<a id="5088" class="Comment">-- curryₙ   : ∀ n → (A₁ × ⋯ × Aₙ → B) → A₁ → ⋯ → Aₙ → B</a>
<a id="5144" class="Comment">-- uncurryₙ : ∀ n → (A₁ → ⋯ → Aₙ → B) → A₁ × ⋯ × Aₙ → B</a>

<a id="5201" class="Comment">-- The first thing we may want to do generically is convert between</a>
<a id="5269" class="Comment">-- curried function types and uncurried ones. We can do this by using:</a>

<a id="5341" class="Comment">-- They both work the same way so we will focus on curryₙ only here.</a>
<a id="5410" class="Comment">-- If we pass to `curryₙ` the arity of its argument then we obtain a</a>
<a id="5479" class="Comment">-- fully curried function.</a>

<a id="curry₁"></a><a id="5507" href="README.Nary.html#5507" class="Function">curry₁</a> <a id="5514" class="Symbol">:</a> <a id="5516" class="Symbol">(</a><a id="5517" href="README.Nary.html#813" class="Generalizable">A</a> <a id="5519" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="5521" href="README.Nary.html#827" class="Generalizable">B</a> <a id="5523" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="5525" href="README.Nary.html#841" class="Generalizable">C</a> <a id="5527" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="5529" href="README.Nary.html#855" class="Generalizable">D</a> <a id="5531" class="Symbol">→</a> <a id="5533" href="README.Nary.html#869" class="Generalizable">E</a><a id="5534" class="Symbol">)</a> <a id="5536" class="Symbol">→</a> <a id="5538" href="README.Nary.html#813" class="Generalizable">A</a> <a id="5540" class="Symbol">→</a> <a id="5542" href="README.Nary.html#827" class="Generalizable">B</a> <a id="5544" class="Symbol">→</a> <a id="5546" href="README.Nary.html#841" class="Generalizable">C</a> <a id="5548" class="Symbol">→</a> <a id="5550" href="README.Nary.html#855" class="Generalizable">D</a> <a id="5552" class="Symbol">→</a> <a id="5554" href="README.Nary.html#869" class="Generalizable">E</a>
<a id="5556" href="README.Nary.html#5507" class="Function">curry₁</a> <a id="5563" class="Symbol">=</a> <a id="5565" href="Data.Product.Nary.NonDependent.html#3625" class="Function">curryₙ</a> <a id="5572" class="Number">4</a>

<a id="5575" class="Comment">-- Note that here we are not flattening arbitrary nestings: products have</a>
<a id="5649" class="Comment">-- to be right nested. Which means that if you have a deeply-nested product</a>
<a id="5725" class="Comment">-- then it won&#39;t be affected by the procedure.</a>

<a id="curry₁&#39;"></a><a id="5773" href="README.Nary.html#5773" class="Function">curry₁&#39;</a> <a id="5781" class="Symbol">:</a> <a id="5783" class="Symbol">(</a><a id="5784" href="README.Nary.html#813" class="Generalizable">A</a> <a id="5786" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="5788" class="Symbol">(</a><a id="5789" href="README.Nary.html#827" class="Generalizable">B</a> <a id="5791" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="5793" href="README.Nary.html#841" class="Generalizable">C</a><a id="5794" class="Symbol">)</a> <a id="5796" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="5798" href="README.Nary.html#855" class="Generalizable">D</a> <a id="5800" class="Symbol">→</a> <a id="5802" href="README.Nary.html#869" class="Generalizable">E</a><a id="5803" class="Symbol">)</a> <a id="5805" class="Symbol">→</a> <a id="5807" href="README.Nary.html#813" class="Generalizable">A</a> <a id="5809" class="Symbol">→</a> <a id="5811" class="Symbol">(</a><a id="5812" href="README.Nary.html#827" class="Generalizable">B</a> <a id="5814" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="5816" href="README.Nary.html#841" class="Generalizable">C</a><a id="5817" class="Symbol">)</a> <a id="5819" class="Symbol">→</a> <a id="5821" href="README.Nary.html#855" class="Generalizable">D</a> <a id="5823" class="Symbol">→</a> <a id="5825" href="README.Nary.html#869" class="Generalizable">E</a>
<a id="5827" href="README.Nary.html#5773" class="Function">curry₁&#39;</a> <a id="5835" class="Symbol">=</a> <a id="5837" href="Data.Product.Nary.NonDependent.html#3625" class="Function">curryₙ</a> <a id="5844" class="Number">3</a>

<a id="5847" class="Comment">-- When we are currying a function, we have no obligation to pass its exact</a>
<a id="5923" class="Comment">-- arity as the parameter: we can decide to only curry part of it like so:</a>
<a id="5998" class="Comment">-- Indeed (A₁ × ⋯ × Aₙ → B) can also be seen as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ) → B)</a>

<a id="curry₂"></a><a id="6076" href="README.Nary.html#6076" class="Function">curry₂</a> <a id="6083" class="Symbol">:</a> <a id="6085" class="Symbol">(</a><a id="6086" href="README.Nary.html#813" class="Generalizable">A</a> <a id="6088" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6090" href="README.Nary.html#827" class="Generalizable">B</a> <a id="6092" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6094" href="README.Nary.html#841" class="Generalizable">C</a> <a id="6096" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6098" href="README.Nary.html#855" class="Generalizable">D</a> <a id="6100" class="Symbol">→</a> <a id="6102" href="README.Nary.html#869" class="Generalizable">E</a><a id="6103" class="Symbol">)</a> <a id="6105" class="Symbol">→</a> <a id="6107" href="README.Nary.html#813" class="Generalizable">A</a> <a id="6109" class="Symbol">→</a> <a id="6111" href="README.Nary.html#827" class="Generalizable">B</a> <a id="6113" class="Symbol">→</a> <a id="6115" class="Symbol">(</a><a id="6116" href="README.Nary.html#841" class="Generalizable">C</a> <a id="6118" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6120" href="README.Nary.html#855" class="Generalizable">D</a><a id="6121" class="Symbol">)</a> <a id="6123" class="Symbol">→</a> <a id="6125" href="README.Nary.html#869" class="Generalizable">E</a>
<a id="6127" href="README.Nary.html#6076" class="Function">curry₂</a> <a id="6134" class="Symbol">=</a> <a id="6136" href="Data.Product.Nary.NonDependent.html#3625" class="Function">curryₙ</a> <a id="6143" class="Number">3</a>

<a id="6146" class="Comment">-----------------------------------------------------------------------</a>
<a id="6218" class="Comment">-- projₙ : ∀ n (k : Fin n) → (A₁ × ⋯ × Aₙ) → Aₖ₊₁</a>

<a id="6269" class="Comment">-- Another useful class of functions to manipulate n-ary product is a</a>
<a id="6339" class="Comment">-- generic projection function. Note the (k + 1) in the return index:</a>
<a id="6409" class="Comment">-- Fin counts from 0 up.</a>

<a id="6435" class="Comment">-- It behaves as one expects (Data.Fin&#39;s #_ comes in handy to write down</a>
<a id="6508" class="Comment">-- Fin literals):</a>

<a id="proj₃"></a><a id="6527" href="README.Nary.html#6527" class="Function">proj₃</a> <a id="6533" class="Symbol">:</a> <a id="6535" class="Symbol">(</a><a id="6536" href="README.Nary.html#813" class="Generalizable">A</a> <a id="6538" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6540" href="README.Nary.html#827" class="Generalizable">B</a> <a id="6542" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6544" href="README.Nary.html#841" class="Generalizable">C</a> <a id="6546" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6548" href="README.Nary.html#855" class="Generalizable">D</a> <a id="6550" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6552" href="README.Nary.html#869" class="Generalizable">E</a><a id="6553" class="Symbol">)</a> <a id="6555" class="Symbol">→</a> <a id="6557" href="README.Nary.html#841" class="Generalizable">C</a>
<a id="6559" href="README.Nary.html#6527" class="Function">proj₃</a> <a id="6565" class="Symbol">=</a> <a id="6567" href="Data.Product.Nary.NonDependent.html#6419" class="Function">projₙ</a> <a id="6573" class="Number">5</a> <a id="6575" class="Symbol">(</a><a id="6576" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="6578" class="Number">2</a><a id="6579" class="Symbol">)</a>

<a id="6582" class="Comment">-- Of course we can once more project the &quot;tail&quot; of the n-ary product by</a>
<a id="6655" class="Comment">-- passing `projₙ` a natural number which is smaller than the size of the</a>
<a id="6729" class="Comment">-- n-ary product, seeing (A₁ × ⋯ × Aₙ) as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ)).</a>

<a id="proj₃&#39;"></a><a id="6798" href="README.Nary.html#6798" class="Function">proj₃&#39;</a> <a id="6805" class="Symbol">:</a> <a id="6807" class="Symbol">(</a><a id="6808" href="README.Nary.html#813" class="Generalizable">A</a> <a id="6810" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6812" href="README.Nary.html#827" class="Generalizable">B</a> <a id="6814" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6816" href="README.Nary.html#841" class="Generalizable">C</a> <a id="6818" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6820" href="README.Nary.html#855" class="Generalizable">D</a> <a id="6822" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6824" href="README.Nary.html#869" class="Generalizable">E</a><a id="6825" class="Symbol">)</a> <a id="6827" class="Symbol">→</a> <a id="6829" href="README.Nary.html#841" class="Generalizable">C</a> <a id="6831" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6833" href="README.Nary.html#855" class="Generalizable">D</a> <a id="6835" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="6837" href="README.Nary.html#869" class="Generalizable">E</a>
<a id="6839" href="README.Nary.html#6798" class="Function">proj₃&#39;</a> <a id="6846" class="Symbol">=</a> <a id="6848" href="Data.Product.Nary.NonDependent.html#6419" class="Function">projₙ</a> <a id="6854" class="Number">3</a> <a id="6856" class="Symbol">(</a><a id="6857" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="6859" class="Number">2</a><a id="6860" class="Symbol">)</a>

<a id="6863" class="Comment">-----------------------------------------------------------------------</a>
<a id="6935" class="Comment">-- insertₙ : ∀ n (k : Fin (suc n)) →</a>
<a id="6972" class="Comment">--           B → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B × Aₖ₊₁ × ⋯ Aₙ)</a>

<a id="insert₁"></a><a id="7036" href="README.Nary.html#7036" class="Function">insert₁</a> <a id="7044" class="Symbol">:</a> <a id="7046" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7048" class="Symbol">→</a> <a id="7050" class="Symbol">(</a><a id="7051" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7053" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7055" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7057" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7059" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7061" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7063" href="README.Nary.html#869" class="Generalizable">E</a><a id="7064" class="Symbol">)</a> <a id="7066" class="Symbol">→</a> <a id="7068" class="Symbol">(</a><a id="7069" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7071" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7073" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7075" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7077" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7079" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7081" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7083" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7085" href="README.Nary.html#869" class="Generalizable">E</a><a id="7086" class="Symbol">)</a>
<a id="7088" href="README.Nary.html#7036" class="Function">insert₁</a> <a id="7096" class="Symbol">=</a> <a id="7098" href="Data.Product.Nary.NonDependent.html#7986" class="Function">insertₙ</a> <a id="7106" class="Number">4</a> <a id="7108" class="Symbol">(</a><a id="7109" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="7111" class="Number">2</a><a id="7112" class="Symbol">)</a>

<a id="insert₁&#39;"></a><a id="7115" href="README.Nary.html#7115" class="Function">insert₁&#39;</a> <a id="7124" class="Symbol">:</a> <a id="7126" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7128" class="Symbol">→</a> <a id="7130" class="Symbol">(</a><a id="7131" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7133" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7135" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7137" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7139" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7141" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7143" href="README.Nary.html#869" class="Generalizable">E</a><a id="7144" class="Symbol">)</a> <a id="7146" class="Symbol">→</a> <a id="7148" class="Symbol">(</a><a id="7149" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7151" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7153" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7155" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7157" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7159" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7161" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7163" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7165" href="README.Nary.html#869" class="Generalizable">E</a><a id="7166" class="Symbol">)</a>
<a id="7168" href="README.Nary.html#7115" class="Function">insert₁&#39;</a> <a id="7177" class="Symbol">=</a> <a id="7179" href="Data.Product.Nary.NonDependent.html#7986" class="Function">insertₙ</a> <a id="7187" class="Number">3</a> <a id="7189" class="Symbol">(</a><a id="7190" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="7192" class="Number">2</a><a id="7193" class="Symbol">)</a>

<a id="7196" class="Comment">-- Note that `insertₙ` takes a `Fin (suc n)`. Indeed in an n-ary product</a>
<a id="7269" class="Comment">-- there are (suc n) positions at which one may insert a value. We may</a>
<a id="7340" class="Comment">-- insert at the front or the back of the product:</a>

<a id="insert-front"></a><a id="7392" href="README.Nary.html#7392" class="Function">insert-front</a> <a id="7405" class="Symbol">:</a> <a id="7407" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7409" class="Symbol">→</a> <a id="7411" class="Symbol">(</a><a id="7412" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7414" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7416" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7418" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7420" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7422" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7424" href="README.Nary.html#869" class="Generalizable">E</a><a id="7425" class="Symbol">)</a> <a id="7427" class="Symbol">→</a> <a id="7429" class="Symbol">(</a><a id="7430" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7432" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7434" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7436" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7438" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7440" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7442" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7444" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7446" href="README.Nary.html#869" class="Generalizable">E</a><a id="7447" class="Symbol">)</a>
<a id="7449" href="README.Nary.html#7392" class="Function">insert-front</a> <a id="7462" class="Symbol">=</a> <a id="7464" href="Data.Product.Nary.NonDependent.html#7986" class="Function">insertₙ</a> <a id="7472" class="Number">4</a> <a id="7474" class="Symbol">(</a><a id="7475" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="7477" class="Number">0</a><a id="7478" class="Symbol">)</a>

<a id="insert-back"></a><a id="7481" href="README.Nary.html#7481" class="Function">insert-back</a> <a id="7493" class="Symbol">:</a> <a id="7495" href="README.Nary.html#869" class="Generalizable">E</a> <a id="7497" class="Symbol">→</a> <a id="7499" class="Symbol">(</a><a id="7500" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7502" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7504" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7506" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7508" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7510" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7512" href="README.Nary.html#855" class="Generalizable">D</a><a id="7513" class="Symbol">)</a> <a id="7515" class="Symbol">→</a> <a id="7517" class="Symbol">(</a><a id="7518" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7520" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7522" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7524" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7526" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7528" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7530" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7532" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7534" href="README.Nary.html#869" class="Generalizable">E</a><a id="7535" class="Symbol">)</a>
<a id="7537" href="README.Nary.html#7481" class="Function">insert-back</a> <a id="7549" class="Symbol">=</a> <a id="7551" href="Data.Product.Nary.NonDependent.html#7986" class="Function">insertₙ</a> <a id="7559" class="Number">4</a> <a id="7561" class="Symbol">(</a><a id="7562" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="7564" class="Number">4</a><a id="7565" class="Symbol">)</a>

<a id="7568" class="Comment">-----------------------------------------------------------------------</a>
<a id="7640" class="Comment">-- removeₙ : ∀ n (k : Fin n) → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="7714" class="Comment">-- Dual to `insertₙ`, we may remove a value.</a>

<a id="remove₁"></a><a id="7760" href="README.Nary.html#7760" class="Function">remove₁</a> <a id="7768" class="Symbol">:</a> <a id="7770" class="Symbol">(</a><a id="7771" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7773" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7775" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7777" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7779" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7781" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7783" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7785" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7787" href="README.Nary.html#869" class="Generalizable">E</a><a id="7788" class="Symbol">)</a> <a id="7790" class="Symbol">→</a> <a id="7792" class="Symbol">(</a><a id="7793" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7795" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7797" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7799" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7801" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7803" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7805" href="README.Nary.html#869" class="Generalizable">E</a><a id="7806" class="Symbol">)</a>
<a id="7808" href="README.Nary.html#7760" class="Function">remove₁</a> <a id="7816" class="Symbol">=</a> <a id="7818" href="Data.Product.Nary.NonDependent.html#7123" class="Function">removeₙ</a> <a id="7826" class="Number">5</a> <a id="7828" class="Symbol">(</a><a id="7829" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="7831" class="Number">2</a><a id="7832" class="Symbol">)</a>

<a id="7835" class="Comment">-- Inserting at `k` and then removing at `inject₁ k` should yield the identity</a>

<a id="remove-insert"></a><a id="7915" href="README.Nary.html#7915" class="Function">remove-insert</a> <a id="7929" class="Symbol">:</a> <a id="7931" href="README.Nary.html#841" class="Generalizable">C</a> <a id="7933" class="Symbol">→</a> <a id="7935" class="Symbol">(</a><a id="7936" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7938" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7940" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7942" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7944" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7946" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7948" href="README.Nary.html#869" class="Generalizable">E</a><a id="7949" class="Symbol">)</a> <a id="7951" class="Symbol">→</a> <a id="7953" class="Symbol">(</a><a id="7954" href="README.Nary.html#813" class="Generalizable">A</a> <a id="7956" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7958" href="README.Nary.html#827" class="Generalizable">B</a> <a id="7960" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7962" href="README.Nary.html#855" class="Generalizable">D</a> <a id="7964" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7966" href="README.Nary.html#869" class="Generalizable">E</a><a id="7967" class="Symbol">)</a>
<a id="7969" href="README.Nary.html#7915" class="Function">remove-insert</a> <a id="7983" href="README.Nary.html#7983" class="Bound">c</a> <a id="7985" class="Symbol">=</a> <a id="7987" href="Data.Product.Nary.NonDependent.html#7123" class="Function">removeₙ</a> <a id="7995" class="Number">5</a> <a id="7997" class="Symbol">(</a><a id="7998" href="Data.Fin.Base.html#2851" class="Function">inject₁</a> <a id="8006" href="README.Nary.html#8036" class="Function">k</a><a id="8007" class="Symbol">)</a> <a id="8009" href="Function.html#3311" class="Function Operator">∘′</a> <a id="8012" href="Data.Product.Nary.NonDependent.html#7986" class="Function">insertₙ</a> <a id="8020" class="Number">4</a> <a id="8022" href="README.Nary.html#8036" class="Function">k</a> <a id="8024" href="README.Nary.html#7983" class="Bound">c</a>
    <a id="8030" class="Keyword">where</a> <a id="8036" href="README.Nary.html#8036" class="Function">k</a> <a id="8038" class="Symbol">=</a> <a id="8040" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="8042" class="Number">2</a>

<a id="8045" class="Comment">-----------------------------------------------------------------------</a>
<a id="8117" class="Comment">-- updateₙ : ∀ n (k : Fin n) (f : (a : Aₖ₊₁) → B a) →</a>
<a id="8171" class="Comment">--           (p : A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B (projₙ n k p) × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="8249" class="Comment">-- We can not only project out, insert or remove values: we can update them</a>
<a id="8325" class="Comment">-- in place. The type (and value) of the replacement at position k may depend</a>
<a id="8403" class="Comment">-- upon the current value at position k.</a>

<a id="update₁"></a><a id="8445" href="README.Nary.html#8445" class="Function">update₁</a> <a id="8453" class="Symbol">:</a> <a id="8455" class="Symbol">(</a><a id="8456" href="README.Nary.html#8456" class="Bound">p</a> <a id="8458" class="Symbol">:</a> <a id="8460" href="README.Nary.html#813" class="Generalizable">A</a> <a id="8462" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8464" href="README.Nary.html#827" class="Generalizable">B</a> <a id="8466" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8468" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="8470" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8472" href="README.Nary.html#841" class="Generalizable">C</a> <a id="8474" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8476" href="README.Nary.html#855" class="Generalizable">D</a><a id="8477" class="Symbol">)</a> <a id="8479" class="Symbol">→</a> <a id="8481" class="Symbol">(</a><a id="8482" href="README.Nary.html#813" class="Generalizable">A</a> <a id="8484" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8486" href="README.Nary.html#827" class="Generalizable">B</a> <a id="8488" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8490" href="Data.Fin.Base.html#967" class="Datatype">Fin</a> <a id="8494" class="Symbol">_</a> <a id="8496" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8498" href="README.Nary.html#841" class="Generalizable">C</a> <a id="8500" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8502" href="README.Nary.html#855" class="Generalizable">D</a><a id="8503" class="Symbol">)</a>
<a id="8505" href="README.Nary.html#8445" class="Function">update₁</a> <a id="8513" class="Symbol">=</a> <a id="8515" href="Data.Product.Nary.NonDependent.html#8785" class="Function">updateₙ</a> <a id="8523" class="Number">5</a> <a id="8525" class="Symbol">(</a><a id="8526" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="8528" class="Number">2</a><a id="8529" class="Symbol">)</a> <a id="8531" href="Data.Fin.Base.html#1708" class="Function">fromℕ</a>

<a id="8538" class="Comment">-- We can explicitly use the primed version of `updateₙ` to make it known to</a>
<a id="8615" class="Comment">-- Agda that the update function is non dependent. This type of information</a>
<a id="8691" class="Comment">-- is useful for inference: the tighter the constraints, the easier it is to</a>
<a id="8768" class="Comment">-- find a solution (if possible).</a>

<a id="update₂"></a><a id="8803" href="README.Nary.html#8803" class="Function">update₂</a> <a id="8811" class="Symbol">:</a> <a id="8813" class="Symbol">(</a><a id="8814" href="README.Nary.html#8814" class="Bound">p</a> <a id="8816" class="Symbol">:</a> <a id="8818" href="README.Nary.html#813" class="Generalizable">A</a> <a id="8820" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8822" href="README.Nary.html#827" class="Generalizable">B</a> <a id="8824" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8826" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="8828" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8830" href="README.Nary.html#841" class="Generalizable">C</a> <a id="8832" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8834" href="README.Nary.html#855" class="Generalizable">D</a><a id="8835" class="Symbol">)</a> <a id="8837" class="Symbol">→</a> <a id="8839" class="Symbol">(</a><a id="8840" href="README.Nary.html#813" class="Generalizable">A</a> <a id="8842" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8844" href="README.Nary.html#827" class="Generalizable">B</a> <a id="8846" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8848" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="8853" href="README.Nary.html#855" class="Generalizable">D</a> <a id="8855" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8857" href="README.Nary.html#841" class="Generalizable">C</a> <a id="8859" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="8861" href="README.Nary.html#855" class="Generalizable">D</a><a id="8862" class="Symbol">)</a>
<a id="8864" href="README.Nary.html#8803" class="Function">update₂</a> <a id="8872" class="Symbol">=</a> <a id="8874" class="Symbol">λ</a> <a id="8876" href="README.Nary.html#8876" class="Bound">p</a> <a id="8878" class="Symbol">→</a> <a id="8880" href="Data.Product.Nary.NonDependent.html#9125" class="Function">updateₙ′</a> <a id="8889" class="Number">5</a> <a id="8891" class="Symbol">(</a><a id="8892" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="8894" class="Number">2</a><a id="8895" class="Symbol">)</a> <a id="8897" class="Symbol">(λ</a> <a id="8900" href="README.Nary.html#8900" class="Bound">n</a> <a id="8902" class="Symbol">→</a> <a id="8904" href="Data.List.Base.html#4379" class="Function">replicate</a> <a id="8914" href="README.Nary.html#8900" class="Bound">n</a> <a id="8916" class="Symbol">(</a><a id="8917" href="Data.Product.Nary.NonDependent.html#6419" class="Function">projₙ</a> <a id="8923" class="Number">5</a> <a id="8925" class="Symbol">(</a><a id="8926" href="Data.Fin.html#730" class="Function Operator">#</a> <a id="8928" class="Number">4</a><a id="8929" class="Symbol">)</a> <a id="8931" href="README.Nary.html#8876" class="Bound">p</a><a id="8932" class="Symbol">))</a> <a id="8935" href="README.Nary.html#8876" class="Bound">p</a>

<a id="8938" class="Comment">-----------------------------------------------------------------------</a>
<a id="9010" class="Comment">-- _%=_⊢_ : ∀ n → (C → D) → (A₁ → ⋯ Aₙ → D → B) → A₁ → ⋯ → Aₙ → C → B</a>

<a id="9081" class="Comment">-- Traditional composition (also known as the index update operator `_⊢_`</a>
<a id="9155" class="Comment">-- in `Relation.Unary`) focuses solely on the first argument of an n-ary</a>
<a id="9228" class="Comment">-- function. `_%=_⊢_` on the other hand allows us to touch any one of the</a>
<a id="9302" class="Comment">-- arguments.</a>

<a id="9317" class="Comment">-- In the following example we have a function `f : A → B` and `replicate`</a>
<a id="9392" class="Comment">-- of type `ℕ → B → List B`. We want ̀f` to act on the second argument of</a>
<a id="9466" class="Comment">-- replicate. Which we can do like so.</a>

<a id="compose₁"></a><a id="9506" href="README.Nary.html#9506" class="Function">compose₁</a> <a id="9515" class="Symbol">:</a> <a id="9517" class="Symbol">(</a><a id="9518" href="README.Nary.html#813" class="Generalizable">A</a> <a id="9520" class="Symbol">→</a> <a id="9522" href="README.Nary.html#827" class="Generalizable">B</a><a id="9523" class="Symbol">)</a> <a id="9525" class="Symbol">→</a> <a id="9527" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9529" class="Symbol">→</a> <a id="9531" href="README.Nary.html#813" class="Generalizable">A</a> <a id="9533" class="Symbol">→</a> <a id="9535" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9540" href="README.Nary.html#827" class="Generalizable">B</a>
<a id="9542" href="README.Nary.html#9506" class="Function">compose₁</a> <a id="9551" href="README.Nary.html#9551" class="Bound">f</a> <a id="9553" class="Symbol">=</a> <a id="9555" class="Number">1</a> <a id="9557" href="Function.Nary.NonDependent.Base.html#3815" class="Function Operator">%=</a> <a id="9560" href="README.Nary.html#9551" class="Bound">f</a> <a id="9562" href="Function.Nary.NonDependent.Base.html#3815" class="Function Operator">⊢</a> <a id="9564" href="Data.List.Base.html#4379" class="Function">replicate</a>

<a id="9575" class="Comment">-- Here we spell out the equivalent explicit variable-manipulation and</a>
<a id="9646" class="Comment">-- prove the two functions equal.</a>

<a id="compose₁&#39;"></a><a id="9681" href="README.Nary.html#9681" class="Function">compose₁&#39;</a> <a id="9691" class="Symbol">:</a> <a id="9693" class="Symbol">(</a><a id="9694" href="README.Nary.html#813" class="Generalizable">A</a> <a id="9696" class="Symbol">→</a> <a id="9698" href="README.Nary.html#827" class="Generalizable">B</a><a id="9699" class="Symbol">)</a> <a id="9701" class="Symbol">→</a> <a id="9703" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9705" class="Symbol">→</a> <a id="9707" href="README.Nary.html#813" class="Generalizable">A</a> <a id="9709" class="Symbol">→</a> <a id="9711" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9716" href="README.Nary.html#827" class="Generalizable">B</a>
<a id="9718" href="README.Nary.html#9681" class="Function">compose₁&#39;</a> <a id="9728" href="README.Nary.html#9728" class="Bound">f</a> <a id="9730" href="README.Nary.html#9730" class="Bound">n</a> <a id="9732" href="README.Nary.html#9732" class="Bound">a</a> <a id="9734" class="Symbol">=</a> <a id="9736" href="Data.List.Base.html#4379" class="Function">replicate</a> <a id="9746" href="README.Nary.html#9730" class="Bound">n</a> <a id="9748" class="Symbol">(</a><a id="9749" href="README.Nary.html#9728" class="Bound">f</a> <a id="9751" href="README.Nary.html#9732" class="Bound">a</a><a id="9752" class="Symbol">)</a>

<a id="compose₁-eq"></a><a id="9755" href="README.Nary.html#9755" class="Function">compose₁-eq</a> <a id="9767" class="Symbol">:</a> <a id="9769" href="README.Nary.html#9506" class="Function">compose₁</a> <a id="9778" class="Symbol">{</a><a id="9779" href="README.Nary.html#791" class="Generalizable">a</a><a id="9780" class="Symbol">}</a> <a id="9782" class="Symbol">{</a><a id="9783" href="README.Nary.html#813" class="Generalizable">A</a><a id="9784" class="Symbol">}</a> <a id="9786" class="Symbol">{</a><a id="9787" href="README.Nary.html#793" class="Generalizable">b</a><a id="9788" class="Symbol">}</a> <a id="9790" class="Symbol">{</a><a id="9791" href="README.Nary.html#827" class="Generalizable">B</a><a id="9792" class="Symbol">}</a> <a id="9794" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="9796" href="README.Nary.html#9681" class="Function">compose₁&#39;</a>
<a id="9806" href="README.Nary.html#9755" class="Function">compose₁-eq</a> <a id="9818" class="Symbol">=</a> <a id="9820" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="9826" class="Comment">-----------------------------------------------------------------------</a>
<a id="9898" class="Comment">-- _∷=_⊢_ : ∀ n → A → (A₁ → ⋯ Aₙ → A → B) → A₁ → ⋯ → Aₙ → B</a>

<a id="9959" class="Comment">-- Partial application usually focuses on the first argument of a function.</a>
<a id="10035" class="Comment">-- We can now partially apply a function in any of its arguments using</a>
<a id="10106" class="Comment">-- `_∷=_⊢_`. Reusing our example involving replicate: we can specialise it</a>
<a id="10181" class="Comment">-- to only output finite lists of `0`:</a>

<a id="apply₁"></a><a id="10221" href="README.Nary.html#10221" class="Function">apply₁</a> <a id="10228" class="Symbol">:</a> <a id="10230" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="10232" class="Symbol">→</a> <a id="10234" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="10239" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="10241" href="README.Nary.html#10221" class="Function">apply₁</a> <a id="10248" class="Symbol">=</a> <a id="10250" class="Number">1</a> <a id="10252" href="Function.Nary.NonDependent.Base.html#3971" class="Function Operator">∷=</a> <a id="10255" class="Number">0</a> <a id="10257" href="Function.Nary.NonDependent.Base.html#3971" class="Function Operator">⊢</a> <a id="10259" href="Data.List.Base.html#4379" class="Function">replicate</a>

<a id="apply₁-eq"></a><a id="10270" href="README.Nary.html#10270" class="Function">apply₁-eq</a> <a id="10280" class="Symbol">:</a> <a id="10282" href="README.Nary.html#10221" class="Function">apply₁</a> <a id="10289" class="Number">3</a> <a id="10291" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10293" class="Number">0</a> <a id="10295" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="10297" class="Number">0</a> <a id="10299" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="10301" class="Number">0</a> <a id="10303" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="10305" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
<a id="10308" href="README.Nary.html#10270" class="Function">apply₁-eq</a> <a id="10318" class="Symbol">=</a> <a id="10320" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="10326" class="Comment">------------------------------------------------------------------------</a>
<a id="10399" class="Comment">-- holeₙ : ∀ n → (A → (A₁ → ⋯ Aₙ → B)) → A₁ → ⋯ → Aₙ → (A → B)</a>

<a id="10463" class="Comment">-- As we have seen earlier, `cong` acts on a function&#39;s first variable.</a>
<a id="10535" class="Comment">-- If we want to access the second one, we can use `flip`. But what about</a>
<a id="10609" class="Comment">-- the fourth one? We typically use an explicit λ-abstraction shuffling</a>
<a id="10681" class="Comment">-- variables. Not anymore.</a>

<a id="10709" class="Comment">-- Reusing mod-helper just because it takes a lot of arguments:</a>

<a id="hole₁"></a><a id="10774" href="README.Nary.html#10774" class="Function">hole₁</a> <a id="10780" class="Symbol">:</a> <a id="10782" class="Symbol">∀</a> <a id="10784" href="README.Nary.html#10784" class="Bound">k</a> <a id="10786" href="README.Nary.html#10786" class="Bound">m</a> <a id="10788" href="README.Nary.html#10788" class="Bound">n</a> <a id="10790" href="README.Nary.html#10790" class="Bound">j</a> <a id="10792" class="Symbol">→</a> <a id="10794" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a> <a id="10805" href="README.Nary.html#10784" class="Bound">k</a> <a id="10807" class="Symbol">(</a><a id="10808" href="README.Nary.html#10786" class="Bound">m</a> <a id="10810" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="10812" class="Number">1</a><a id="10813" class="Symbol">)</a> <a id="10815" href="README.Nary.html#10788" class="Bound">n</a> <a id="10817" href="README.Nary.html#10790" class="Bound">j</a> <a id="10819" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10821" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a> <a id="10832" href="README.Nary.html#10784" class="Bound">k</a> <a id="10834" class="Symbol">(</a><a id="10835" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="10839" href="README.Nary.html#10786" class="Bound">m</a><a id="10840" class="Symbol">)</a> <a id="10842" href="README.Nary.html#10788" class="Bound">n</a> <a id="10844" href="README.Nary.html#10790" class="Bound">j</a>
<a id="10846" href="README.Nary.html#10774" class="Function">hole₁</a> <a id="10852" class="Symbol">=</a> <a id="10854" class="Symbol">λ</a> <a id="10856" href="README.Nary.html#10856" class="Bound">k</a> <a id="10858" href="README.Nary.html#10858" class="Bound">m</a> <a id="10860" href="README.Nary.html#10860" class="Bound">n</a> <a id="10862" href="README.Nary.html#10862" class="Bound">j</a> <a id="10864" class="Symbol">→</a> <a id="10866" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="10871" class="Symbol">(</a><a id="10872" href="Function.Nary.NonDependent.Base.html#4095" class="Function">holeₙ</a> <a id="10878" class="Number">2</a> <a id="10880" class="Symbol">(</a><a id="10881" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a> <a id="10892" href="README.Nary.html#10856" class="Bound">k</a><a id="10893" class="Symbol">)</a> <a id="10895" href="README.Nary.html#10860" class="Bound">n</a> <a id="10897" href="README.Nary.html#10862" class="Bound">j</a><a id="10898" class="Symbol">)</a> <a id="10900" class="Symbol">(</a><a id="10901" href="Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="10908" href="README.Nary.html#10858" class="Bound">m</a> <a id="10910" class="Number">1</a><a id="10911" class="Symbol">)</a>

<a id="10914" class="Comment">-----------------------------------------------------------------------</a>
<a id="10986" class="Comment">-- mapₙ : ∀ n → (B → C) → (A₁ → ⋯ Aₙ → B) → (A₁ → ⋯ → Aₙ → C)</a>

<a id="11049" class="Comment">-- (R →_) gives us the reader monad (and, a fortiori, functor). That is to</a>
<a id="11124" class="Comment">-- say that given a function (A → B) and an (R → A) we can get an (R → B)</a>
<a id="11198" class="Comment">-- This generalises to n-ary functions.</a>

<a id="11239" class="Comment">-- Reusing our `composeₙ` example: instead of applying `f` to the replicated</a>
<a id="11316" class="Comment">-- element, we can map it on the resulting list. Giving us:</a>

<a id="map₁"></a><a id="11377" href="README.Nary.html#11377" class="Function">map₁</a> <a id="11382" class="Symbol">:</a> <a id="11384" class="Symbol">(</a><a id="11385" href="README.Nary.html#813" class="Generalizable">A</a> <a id="11387" class="Symbol">→</a> <a id="11389" href="README.Nary.html#827" class="Generalizable">B</a><a id="11390" class="Symbol">)</a> <a id="11392" class="Symbol">→</a> <a id="11394" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="11396" class="Symbol">→</a> <a id="11398" href="README.Nary.html#813" class="Generalizable">A</a> <a id="11400" class="Symbol">→</a> <a id="11402" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="11407" href="README.Nary.html#827" class="Generalizable">B</a>
<a id="11409" href="README.Nary.html#11377" class="Function">map₁</a> <a id="11414" href="README.Nary.html#11414" class="Bound">f</a> <a id="11416" class="Symbol">=</a> <a id="11418" href="Function.Nary.NonDependent.Base.html#3655" class="Function">mapₙ</a> <a id="11423" class="Number">2</a> <a id="11425" class="Symbol">(</a><a id="11426" href="Data.List.Base.html#1304" class="Function">map</a> <a id="11430" href="README.Nary.html#11414" class="Bound">f</a><a id="11431" class="Symbol">)</a> <a id="11433" href="Data.List.Base.html#4379" class="Function">replicate</a>

<a id="11444" class="Comment">------------------------------------------------------------------------</a>
<a id="11517" class="Comment">-- constₙ : ∀ n → B → A₁ → ⋯ → Aₙ → B</a>

<a id="11556" class="Comment">-- `const` is basically `pure` for the reader monad discussed above. Just</a>
<a id="11630" class="Comment">-- like we can generalise the functorial action corresponding to the reader</a>
<a id="11706" class="Comment">-- functor to n-ary functions, we can do the same for `pure`.</a>

<a id="const₁"></a><a id="11769" href="README.Nary.html#11769" class="Function">const₁</a> <a id="11776" class="Symbol">:</a> <a id="11778" href="README.Nary.html#813" class="Generalizable">A</a> <a id="11780" class="Symbol">→</a> <a id="11782" href="README.Nary.html#827" class="Generalizable">B</a> <a id="11784" class="Symbol">→</a> <a id="11786" href="README.Nary.html#841" class="Generalizable">C</a> <a id="11788" class="Symbol">→</a> <a id="11790" href="README.Nary.html#855" class="Generalizable">D</a> <a id="11792" class="Symbol">→</a> <a id="11794" href="README.Nary.html#869" class="Generalizable">E</a> <a id="11796" class="Symbol">→</a> <a id="11798" href="README.Nary.html#813" class="Generalizable">A</a>
<a id="11800" href="README.Nary.html#11769" class="Function">const₁</a> <a id="11807" class="Symbol">=</a> <a id="11809" href="Function.Nary.NonDependent.Base.html#4477" class="Function">constₙ</a> <a id="11816" class="Number">4</a>

<a id="11819" class="Comment">-- Together with `holeₙ`, this means we can make a constant function out</a>
<a id="11892" class="Comment">-- of any of the arguments. The fourth for instance:</a>

<a id="const₂"></a><a id="11946" href="README.Nary.html#11946" class="Function">const₂</a> <a id="11953" class="Symbol">:</a> <a id="11955" href="README.Nary.html#813" class="Generalizable">A</a> <a id="11957" class="Symbol">→</a> <a id="11959" href="README.Nary.html#827" class="Generalizable">B</a> <a id="11961" class="Symbol">→</a> <a id="11963" href="README.Nary.html#841" class="Generalizable">C</a> <a id="11965" class="Symbol">→</a> <a id="11967" href="README.Nary.html#855" class="Generalizable">D</a> <a id="11969" class="Symbol">→</a> <a id="11971" href="README.Nary.html#869" class="Generalizable">E</a> <a id="11973" class="Symbol">→</a> <a id="11975" href="README.Nary.html#855" class="Generalizable">D</a>
<a id="11977" href="README.Nary.html#11946" class="Function">const₂</a> <a id="11984" class="Symbol">=</a> <a id="11986" href="Function.Nary.NonDependent.Base.html#4095" class="Function">holeₙ</a> <a id="11992" class="Number">3</a> <a id="11994" class="Symbol">(</a><a id="11995" href="Function.Nary.NonDependent.Base.html#4477" class="Function">constₙ</a> <a id="12002" class="Number">4</a><a id="12003" class="Symbol">)</a>

<a id="12006" class="Comment">------------------------------------------------------------------------</a>
<a id="12079" class="Comment">-- Generalised quantifiers</a>
<a id="12106" class="Comment">------------------------------------------------------------------------</a>

<a id="12180" class="Comment">-- As we have seen multiple times already, one of the advantages of working</a>
<a id="12256" class="Comment">-- with non-dependent products is that they can be easily inferred. This is</a>
<a id="12332" class="Comment">-- a prime opportunity to define generic quantifiers.</a>

<a id="12387" class="Comment">-- And because n-ary relations are Set-terminated, there is no ambiguity</a>
<a id="12460" class="Comment">-- where to split between arguments &amp; codomain. As a consequence Agda can</a>
<a id="12534" class="Comment">-- infer even `n`, the number of arguments. We can use notations which are</a>
<a id="12609" class="Comment">-- just like the ones defined in `Relation.Unary`.</a>

<a id="12661" class="Comment">------------------------------------------------------------------------</a>
<a id="12734" class="Comment">-- ∃⟨_⟩ : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="12774" class="Comment">-- ∃⟨ P ⟩ = ∃ λ a₁ → ⋯ → ∃ λ aₙ → P a₁ ⋯ aₙ</a>

<a id="12819" class="Comment">-- Returning to our favourite function taking a lot of arguments: we can</a>
<a id="12892" class="Comment">-- find a set of input for which it evaluates to 666</a>

<a id="exist₁"></a><a id="12946" href="README.Nary.html#12946" class="Function">exist₁</a> <a id="12953" class="Symbol">:</a> <a id="12955" href="Relation.Nary.html#2260" class="Function Operator">∃⟨</a> <a id="12958" class="Symbol">(λ</a> <a id="12961" href="README.Nary.html#12961" class="Bound">k</a> <a id="12963" href="README.Nary.html#12963" class="Bound">m</a> <a id="12965" href="README.Nary.html#12965" class="Bound">n</a> <a id="12967" href="README.Nary.html#12967" class="Bound">j</a> <a id="12969" class="Symbol">→</a> <a id="12971" href="Agda.Builtin.Nat.html#3002" class="Primitive">mod-helper</a> <a id="12982" href="README.Nary.html#12961" class="Bound">k</a> <a id="12984" href="README.Nary.html#12963" class="Bound">m</a> <a id="12986" href="README.Nary.html#12965" class="Bound">n</a> <a id="12988" href="README.Nary.html#12967" class="Bound">j</a> <a id="12990" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="12992" class="Number">666</a><a id="12995" class="Symbol">)</a> <a id="12997" href="Relation.Nary.html#2260" class="Function Operator">⟩</a>
<a id="12999" href="README.Nary.html#12946" class="Function">exist₁</a> <a id="13006" class="Symbol">=</a> <a id="13008" class="Number">19</a> <a id="13011" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13013" class="Number">793</a> <a id="13017" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13019" class="Number">3059</a> <a id="13024" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13026" class="Number">10</a> <a id="13029" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13031" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="13037" class="Comment">------------------------------------------------------------------------</a>
<a id="13110" class="Comment">-- ∀[_] : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13150" class="Comment">-- ∀[_] P = ∀ {a₁} → ⋯ → ∀ {aₙ} → P a₁ ⋯ aₙ</a>

<a id="all₁"></a><a id="13195" href="README.Nary.html#13195" class="Function">all₁</a> <a id="13200" class="Symbol">:</a> <a id="13202" href="Relation.Nary.html#2536" class="Function Operator">∀[</a> <a id="13205" class="Symbol">(λ</a> <a id="13208" class="Symbol">(</a><a id="13209" href="README.Nary.html#13209" class="Bound">a₁</a> <a id="13212" href="README.Nary.html#13212" class="Bound">a₂</a> <a id="13215" class="Symbol">:</a> <a id="13217" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="13218" class="Symbol">)</a> <a id="13220" class="Symbol">→</a> <a id="13222" href="Relation.Nullary.html#605" class="Datatype">Dec</a> <a id="13226" class="Symbol">(</a><a id="13227" href="README.Nary.html#13209" class="Bound">a₁</a> <a id="13230" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="13232" href="README.Nary.html#13212" class="Bound">a₂</a><a id="13234" class="Symbol">))</a> <a id="13237" href="Relation.Nary.html#2536" class="Function Operator">]</a>
<a id="13239" href="README.Nary.html#13195" class="Function">all₁</a> <a id="13244" class="Symbol">{</a><a id="13245" href="README.Nary.html#13245" class="Bound">a₁</a><a id="13247" class="Symbol">}</a> <a id="13249" class="Symbol">{</a><a id="13250" href="README.Nary.html#13250" class="Bound">a₂</a><a id="13252" class="Symbol">}</a> <a id="13254" class="Symbol">=</a> <a id="13256" href="README.Nary.html#13245" class="Bound">a₁</a> <a id="13259" href="Data.Nat.Properties.html#2233" class="Function Operator">≟</a> <a id="13261" href="README.Nary.html#13250" class="Bound">a₂</a>

<a id="13265" class="Comment">------------------------------------------------------------------------</a>
<a id="13338" class="Comment">-- Π : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13375" class="Comment">-- Π P = ∀ a₁ → ⋯ → ∀ aₙ → P a₁ ⋯ aₙ</a>

<a id="all₂"></a><a id="13413" href="README.Nary.html#13413" class="Function">all₂</a> <a id="13418" class="Symbol">:</a> <a id="13420" href="Relation.Nary.html#2399" class="Function Operator">Π[</a> <a id="13423" class="Symbol">(λ</a> <a id="13426" class="Symbol">(</a><a id="13427" href="README.Nary.html#13427" class="Bound">a₁</a> <a id="13430" href="README.Nary.html#13430" class="Bound">a₂</a> <a id="13433" class="Symbol">:</a> <a id="13435" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="13436" class="Symbol">)</a> <a id="13438" class="Symbol">→</a> <a id="13440" href="Relation.Nullary.html#605" class="Datatype">Dec</a> <a id="13444" class="Symbol">(</a><a id="13445" href="README.Nary.html#13427" class="Bound">a₁</a> <a id="13448" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="13450" href="README.Nary.html#13430" class="Bound">a₂</a><a id="13452" class="Symbol">))</a> <a id="13455" href="Relation.Nary.html#2399" class="Function Operator">]</a>
<a id="13457" href="README.Nary.html#13413" class="Function">all₂</a> <a id="13462" class="Symbol">=</a> <a id="13464" href="Data.Nat.Properties.html#2233" class="Function Operator">_≟_</a>

<a id="13469" class="Comment">------------------------------------------------------------------------</a>
<a id="13542" class="Comment">-- _⇒_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13621" class="Comment">-- P ⇒ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ → Q a₁ ⋯ aₙ</a>

<a id="antisym"></a><a id="13673" href="README.Nary.html#13673" class="Function">antisym</a> <a id="13681" class="Symbol">:</a> <a id="13683" href="Relation.Nary.html#2536" class="Function Operator">∀[</a> <a id="13686" href="Data.Nat.Base.html#895" class="Datatype Operator">_≤_</a> <a id="13690" href="Relation.Nary.html#4935" class="Function Operator">⇒</a> <a id="13692" href="Data.Nat.Base.html#1039" class="Function Operator">_≥_</a> <a id="13696" href="Relation.Nary.html#4935" class="Function Operator">⇒</a> <a id="13698" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a> <a id="13702" href="Relation.Nary.html#2536" class="Function Operator">]</a>
<a id="13704" href="README.Nary.html#13673" class="Function">antisym</a> <a id="13712" class="Symbol">=</a> <a id="13714" href="Data.Nat.Properties.html#3682" class="Function">≤-antisym</a>

<a id="13725" class="Comment">------------------------------------------------------------------------</a>
<a id="13798" class="Comment">-- _∪_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13877" class="Comment">-- P ∪ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ ⊎ Q a₁ ⋯ aₙ</a>

<a id="≤-&gt;-connex"></a><a id="13929" href="README.Nary.html#13929" class="Function">≤-&gt;-connex</a> <a id="13940" class="Symbol">:</a> <a id="13942" href="Relation.Nary.html#2399" class="Function Operator">Π[</a> <a id="13945" href="Data.Nat.Base.html#895" class="Datatype Operator">_≤_</a> <a id="13949" href="Relation.Nary.html#5225" class="Function Operator">∪</a> <a id="13951" href="Data.Nat.Base.html#1069" class="Function Operator">_&gt;_</a> <a id="13955" href="Relation.Nary.html#2399" class="Function Operator">]</a>
<a id="13957" href="README.Nary.html#13929" class="Function">≤-&gt;-connex</a> <a id="13968" href="README.Nary.html#13968" class="Bound">m</a> <a id="13970" href="README.Nary.html#13970" class="Bound">n</a> <a id="13972" class="Keyword">with</a> <a id="13977" href="Data.Nat.Properties.html#8550" class="Function">&lt;-cmp</a> <a id="13983" href="README.Nary.html#13968" class="Bound">m</a> <a id="13985" href="README.Nary.html#13970" class="Bound">n</a>
<a id="13987" class="Symbol">...</a> <a id="13991" class="Symbol">|</a> <a id="13993" href="Relation.Binary.Core.html#3760" class="InductiveConstructor">tri&lt;</a> <a id="13998" href="README.Nary.html#13998" class="Bound">a</a> <a id="14000" href="README.Nary.html#14000" class="Bound">¬b</a> <a id="14003" href="README.Nary.html#14003" class="Bound">¬c</a> <a id="14006" class="Symbol">=</a> <a id="14008" href="Data.Sum.Base.html#662" class="InductiveConstructor">inj₁</a> <a id="14013" class="Symbol">(</a><a id="14014" href="Data.Nat.Properties.html#6552" class="Function">&lt;⇒≤</a> <a id="14018" href="README.Nary.html#13998" class="Bound">a</a><a id="14019" class="Symbol">)</a>
<a id="14021" class="Symbol">...</a> <a id="14025" class="Symbol">|</a> <a id="14027" href="Relation.Binary.Core.html#3814" class="InductiveConstructor">tri≈</a> <a id="14032" href="README.Nary.html#14032" class="Bound">¬a</a> <a id="14035" href="README.Nary.html#14035" class="Bound">b</a> <a id="14037" href="README.Nary.html#14037" class="Bound">¬c</a> <a id="14040" class="Symbol">=</a> <a id="14042" href="Data.Sum.Base.html#662" class="InductiveConstructor">inj₁</a> <a id="14047" class="Symbol">(</a><a id="14048" href="Data.Nat.Properties.html#3526" class="Function">≤-reflexive</a> <a id="14060" href="README.Nary.html#14035" class="Bound">b</a><a id="14061" class="Symbol">)</a>
<a id="14063" class="Symbol">...</a> <a id="14067" class="Symbol">|</a> <a id="14069" href="Relation.Binary.Core.html#3868" class="InductiveConstructor">tri&gt;</a> <a id="14074" href="README.Nary.html#14074" class="Bound">¬a</a> <a id="14077" href="README.Nary.html#14077" class="Bound">¬b</a> <a id="14080" href="README.Nary.html#14080" class="Bound">c</a> <a id="14082" class="Symbol">=</a> <a id="14084" href="Data.Sum.Base.html#687" class="InductiveConstructor">inj₂</a> <a id="14089" href="README.Nary.html#14080" class="Bound">c</a>

<a id="14092" class="Comment">------------------------------------------------------------------------</a>
<a id="14165" class="Comment">-- _∩_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14244" class="Comment">-- P ∩ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ × Q a₁ ⋯ aₙ</a>

<a id="&lt;-inversion"></a><a id="14296" href="README.Nary.html#14296" class="Function">&lt;-inversion</a> <a id="14308" class="Symbol">:</a> <a id="14310" href="Relation.Nary.html#2536" class="Function Operator">∀[</a> <a id="14313" href="Data.Nat.Base.html#1005" class="Function Operator">_&lt;_</a> <a id="14317" href="Relation.Nary.html#4935" class="Function Operator">⇒</a> <a id="14319" href="Data.Nat.Base.html#895" class="Datatype Operator">_≤_</a> <a id="14323" href="Relation.Nary.html#5086" class="Function Operator">∩</a> <a id="14325" href="Relation.Binary.PropositionalEquality.Core.html#799" class="Function Operator">_≢_</a> <a id="14329" href="Relation.Nary.html#2536" class="Function Operator">]</a>
<a id="14331" href="README.Nary.html#14296" class="Function">&lt;-inversion</a> <a id="14343" href="README.Nary.html#14343" class="Bound">m&lt;n</a> <a id="14347" class="Symbol">=</a> <a id="14349" href="Data.Nat.Properties.html#6552" class="Function">&lt;⇒≤</a> <a id="14353" href="README.Nary.html#14343" class="Bound">m&lt;n</a> <a id="14357" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="14359" href="Data.Nat.Properties.html#6613" class="Function">&lt;⇒≢</a> <a id="14363" href="README.Nary.html#14343" class="Bound">m&lt;n</a>

<a id="14368" class="Comment">------------------------------------------------------------------------</a>
<a id="14441" class="Comment">-- ∁ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14494" class="Comment">-- ∁ P = λ a₁ → ⋯ → λ aₙ → ¬ (P a₁ ⋯ aₙ)</a>

<a id="m&lt;n⇒m≱n"></a><a id="14536" href="README.Nary.html#14536" class="Function">m&lt;n⇒m≱n</a> <a id="14544" class="Symbol">:</a> <a id="14546" href="Relation.Nary.html#2536" class="Function Operator">∀[</a> <a id="14549" href="Data.Nat.Base.html#1069" class="Function Operator">_&gt;_</a> <a id="14553" href="Relation.Nary.html#4935" class="Function Operator">⇒</a> <a id="14555" href="Relation.Nary.html#5348" class="Function">∁</a> <a id="14557" href="Data.Nat.Base.html#895" class="Datatype Operator">_≤_</a> <a id="14561" href="Relation.Nary.html#2536" class="Function Operator">]</a>
<a id="14563" href="README.Nary.html#14536" class="Function">m&lt;n⇒m≱n</a> <a id="14571" href="README.Nary.html#14571" class="Bound">m&gt;n</a> <a id="14575" href="README.Nary.html#14575" class="Bound">m≤n</a> <a id="14579" class="Symbol">=</a> <a id="14581" href="Data.Nat.Properties.html#6710" class="Function">&lt;⇒≱</a> <a id="14585" href="README.Nary.html#14571" class="Bound">m&gt;n</a> <a id="14589" href="README.Nary.html#14575" class="Bound">m≤n</a>
</pre></body></html>