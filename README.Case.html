<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Case</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the case expressions can be used with anonymous</a>
<a id="178" class="Comment">-- pattern-matching lambda abstractions</a>
<a id="218" class="Comment">------------------------------------------------------------------------</a>

<a id="292" class="Symbol">{-#</a> <a id="296" class="Keyword">OPTIONS</a> <a id="304" class="Pragma">--without-K</a> <a id="316" class="Pragma">--safe</a> <a id="323" class="Symbol">#-}</a>

<a id="328" class="Keyword">module</a> <a id="335" href="README.Case.html" class="Module">README.Case</a> <a id="347" class="Keyword">where</a>

<a id="354" class="Keyword">open</a> <a id="359" class="Keyword">import</a> <a id="366" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="377" class="Keyword">hiding</a> <a id="384" class="Symbol">(</a><a id="385" href="Data.Fin.Base.html#5122" class="Function">pred</a><a id="389" class="Symbol">)</a>
<a id="391" class="Keyword">open</a> <a id="396" class="Keyword">import</a> <a id="403" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="414" class="Keyword">hiding</a> <a id="421" class="Symbol">(</a><a id="422" href="Data.Maybe.Base.html#1829" class="Function">from-just</a><a id="431" class="Symbol">)</a>
<a id="433" class="Keyword">open</a> <a id="438" class="Keyword">import</a> <a id="445" href="Data.Nat.html" class="Module">Data.Nat</a>   <a id="456" class="Keyword">hiding</a> <a id="463" class="Symbol">(</a><a id="464" href="Data.Nat.Base.html#1464" class="Function">pred</a><a id="468" class="Symbol">)</a>
<a id="470" class="Keyword">open</a> <a id="475" class="Keyword">import</a> <a id="482" href="Data.List.html" class="Module">Data.List</a>
<a id="492" class="Keyword">open</a> <a id="497" class="Keyword">import</a> <a id="504" href="Data.Sum.html" class="Module">Data.Sum</a>
<a id="513" class="Keyword">open</a> <a id="518" class="Keyword">import</a> <a id="525" href="Data.Product.html" class="Module">Data.Product</a>
<a id="538" class="Keyword">open</a> <a id="543" class="Keyword">import</a> <a id="550" href="Function.html" class="Module">Function</a>
<a id="559" class="Keyword">open</a> <a id="564" class="Keyword">import</a> <a id="571" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="Relation.Binary.html" class="Module">Relation.Binary</a>
<a id="616" class="Keyword">open</a> <a id="621" class="Keyword">import</a> <a id="628" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="667" class="Comment">------------------------------------------------------------------------</a>
<a id="740" class="Comment">-- Different types of pattern-matching lambdas</a>

<a id="788" class="Comment">-- absurd pattern</a>

<a id="empty"></a><a id="807" href="README.Case.html#807" class="Function">empty</a> <a id="813" class="Symbol">:</a> <a id="815" class="Symbol">∀</a> <a id="817" class="Symbol">{</a><a id="818" href="README.Case.html#818" class="Bound">a</a><a id="819" class="Symbol">}</a> <a id="821" class="Symbol">{</a><a id="822" href="README.Case.html#822" class="Bound">A</a> <a id="824" class="Symbol">:</a> <a id="826" class="PrimitiveType">Set</a> <a id="830" href="README.Case.html#818" class="Bound">a</a><a id="831" class="Symbol">}</a> <a id="833" class="Symbol">→</a> <a id="835" href="Data.Fin.Base.html#951" class="Datatype">Fin</a> <a id="839" class="Number">0</a> <a id="841" class="Symbol">→</a> <a id="843" href="README.Case.html#822" class="Bound">A</a>
<a id="845" href="README.Case.html#807" class="Function">empty</a> <a id="851" href="README.Case.html#851" class="Bound">i</a> <a id="853" class="Symbol">=</a> <a id="855" href="Function.html#3404" class="Function Operator">case</a> <a id="860" href="README.Case.html#851" class="Bound">i</a> <a id="862" href="Function.html#3404" class="Function Operator">of</a> <a id="865" class="Symbol">λ</a> <a id="867" class="Symbol">()</a>

<a id="871" class="Comment">-- {}-delimited and ;-separated list of clauses</a>
<a id="919" class="Comment">-- Note that they do not need to be on different lines</a>

<a id="pred"></a><a id="975" href="README.Case.html#975" class="Function">pred</a> <a id="980" class="Symbol">:</a> <a id="982" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="984" class="Symbol">→</a> <a id="986" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="988" href="README.Case.html#975" class="Function">pred</a> <a id="993" href="README.Case.html#993" class="Bound">n</a> <a id="995" class="Symbol">=</a> <a id="997" href="Function.html#3404" class="Function Operator">case</a> <a id="1002" href="README.Case.html#993" class="Bound">n</a> <a id="1004" href="Function.html#3404" class="Function Operator">of</a> <a id="1007" class="Symbol">λ</a>
  <a id="1011" class="Symbol">{</a> <a id="1013" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="1021" class="Symbol">→</a> <a id="1023" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
  <a id="1030" class="Symbol">;</a> <a id="1032" class="Symbol">(</a><a id="1033" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1037" href="README.Case.html#1037" class="Bound">n</a><a id="1038" class="Symbol">)</a> <a id="1040" class="Symbol">→</a> <a id="1042" href="README.Case.html#1037" class="Bound">n</a>
  <a id="1046" class="Symbol">}</a>

<a id="1049" class="Comment">-- where-introduced and indentation-identified block of list of clauses</a>

<a id="from-just"></a><a id="1122" href="README.Case.html#1122" class="Function">from-just</a> <a id="1132" class="Symbol">:</a> <a id="1134" class="Symbol">∀</a> <a id="1136" class="Symbol">{</a><a id="1137" href="README.Case.html#1137" class="Bound">a</a><a id="1138" class="Symbol">}</a> <a id="1140" class="Symbol">{</a><a id="1141" href="README.Case.html#1141" class="Bound">A</a> <a id="1143" class="Symbol">:</a> <a id="1145" class="PrimitiveType">Set</a> <a id="1149" href="README.Case.html#1137" class="Bound">a</a><a id="1150" class="Symbol">}</a> <a id="1152" class="Symbol">(</a><a id="1153" href="README.Case.html#1153" class="Bound">x</a> <a id="1155" class="Symbol">:</a> <a id="1157" href="Data.Maybe.Base.html#790" class="Datatype">Maybe</a> <a id="1163" href="README.Case.html#1141" class="Bound">A</a><a id="1164" class="Symbol">)</a> <a id="1166" class="Symbol">→</a> <a id="1168" href="Data.Maybe.Base.html#1741" class="Function">From-just</a> <a id="1178" href="README.Case.html#1153" class="Bound">x</a>
<a id="1180" href="README.Case.html#1122" class="Function">from-just</a> <a id="1190" href="README.Case.html#1190" class="Bound">x</a> <a id="1192" class="Symbol">=</a> <a id="1194" href="Function.html#2418" class="Function Operator">case</a> <a id="1199" href="README.Case.html#1190" class="Bound">x</a> <a id="1201" href="Function.html#2418" class="Function Operator">return</a> <a id="1208" href="Data.Maybe.Base.html#1741" class="Function">From-just</a> <a id="1218" href="Function.html#2418" class="Function Operator">of</a> <a id="1221" class="Symbol">λ</a> <a id="1223" class="Keyword">where</a>
  <a id="1231" class="Symbol">(</a><a id="1232" href="Data.Maybe.Base.html#824" class="InductiveConstructor">just</a> <a id="1237" href="README.Case.html#1237" class="Bound">x</a><a id="1238" class="Symbol">)</a> <a id="1240" class="Symbol">→</a> <a id="1242" href="README.Case.html#1237" class="Bound">x</a>
  <a id="1246" href="Data.Maybe.Base.html#854" class="InductiveConstructor">nothing</a>  <a id="1255" class="Symbol">→</a> <a id="1257" class="Symbol">_</a>

<a id="1260" class="Comment">------------------------------------------------------------------------</a>
<a id="1333" class="Comment">-- We can define some recursive functions with case</a>

<a id="plus"></a><a id="1386" href="README.Case.html#1386" class="Function">plus</a> <a id="1391" class="Symbol">:</a> <a id="1393" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="1395" class="Symbol">→</a> <a id="1397" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="1399" class="Symbol">→</a> <a id="1401" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="1403" href="README.Case.html#1386" class="Function">plus</a> <a id="1408" href="README.Case.html#1408" class="Bound">m</a> <a id="1410" href="README.Case.html#1410" class="Bound">n</a> <a id="1412" class="Symbol">=</a> <a id="1414" href="Function.html#3404" class="Function Operator">case</a> <a id="1419" href="README.Case.html#1408" class="Bound">m</a> <a id="1421" href="Function.html#3404" class="Function Operator">of</a> <a id="1424" class="Symbol">λ</a>
   <a id="1429" class="Symbol">{</a> <a id="1431" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="1439" class="Symbol">→</a> <a id="1441" href="README.Case.html#1410" class="Bound">n</a>
   <a id="1446" class="Symbol">;</a> <a id="1448" class="Symbol">(</a><a id="1449" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1453" href="README.Case.html#1453" class="Bound">m</a><a id="1454" class="Symbol">)</a> <a id="1456" class="Symbol">→</a> <a id="1458" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1462" class="Symbol">(</a><a id="1463" href="README.Case.html#1386" class="Function">plus</a> <a id="1468" href="README.Case.html#1453" class="Bound">m</a> <a id="1470" href="README.Case.html#1410" class="Bound">n</a><a id="1471" class="Symbol">)</a>
   <a id="1476" class="Symbol">}</a>

<a id="div2"></a><a id="1479" href="README.Case.html#1479" class="Function">div2</a> <a id="1484" class="Symbol">:</a> <a id="1486" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="1488" class="Symbol">→</a> <a id="1490" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="1492" href="README.Case.html#1479" class="Function">div2</a> <a id="1497" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="1505" class="Symbol">=</a> <a id="1507" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
<a id="1512" href="README.Case.html#1479" class="Function">div2</a> <a id="1517" class="Symbol">(</a><a id="1518" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1522" href="README.Case.html#1522" class="Bound">m</a><a id="1523" class="Symbol">)</a> <a id="1525" class="Symbol">=</a> <a id="1527" href="Function.html#3404" class="Function Operator">case</a> <a id="1532" href="README.Case.html#1522" class="Bound">m</a> <a id="1534" href="Function.html#3404" class="Function Operator">of</a> <a id="1537" class="Symbol">λ</a> <a id="1539" class="Keyword">where</a>
  <a id="1547" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>     <a id="1556" class="Symbol">→</a> <a id="1558" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
  <a id="1565" class="Symbol">(</a><a id="1566" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1570" href="README.Case.html#1570" class="Bound">m&#39;</a><a id="1572" class="Symbol">)</a> <a id="1574" class="Symbol">→</a> <a id="1576" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1580" class="Symbol">(</a><a id="1581" href="README.Case.html#1479" class="Function">div2</a> <a id="1586" href="README.Case.html#1570" class="Bound">m&#39;</a><a id="1588" class="Symbol">)</a>


<a id="1592" class="Comment">-- Note that some natural uses of case are rejected by the termination</a>
<a id="1663" class="Comment">-- checker:</a>

<a id="1676" class="Comment">-- module _ {a} {A : Set a} (eq? : Decidable {A = A} _≡_) where</a>

<a id="1741" class="Comment">--  pairBy : List A → List (A ⊎ (A × A))</a>
<a id="1782" class="Comment">--  pairBy []           = []</a>
<a id="1811" class="Comment">--  pairBy (x ∷ [])     = inj₁ x ∷ []</a>
<a id="1849" class="Comment">--  pairBy (x ∷ y ∷ xs) = case eq? x y of λ where</a>
<a id="1899" class="Comment">--    (yes _) → inj₂ (x , y) ∷ pairBy xs</a>
<a id="1940" class="Comment">--    (no _)  → inj₁ x ∷ pairBy (y ∷ xs)</a>
</pre></body></html>