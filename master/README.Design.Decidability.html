<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Design.Decidability</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples of decision procedures and how to use them</a>
<a id="161" class="Comment">------------------------------------------------------------------------</a>

<a id="235" class="Symbol">{-#</a> <a id="239" class="Keyword">OPTIONS</a> <a id="247" class="Pragma">--cubical-compatible</a> <a id="268" class="Pragma">--safe</a> <a id="275" class="Symbol">#-}</a>

<a id="280" class="Keyword">module</a> <a id="287" href="README.Design.Decidability.html" class="Module">README.Design.Decidability</a> <a id="314" class="Keyword">where</a>

<a id="321" class="Keyword">open</a> <a id="326" class="Keyword">import</a> <a id="333" href="Data.Bool.html" class="Module">Data.Bool</a>
<a id="343" class="Keyword">open</a> <a id="348" class="Keyword">import</a> <a id="355" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="370" class="Keyword">using</a> <a id="376" class="Symbol">(</a><a id="377" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="381" class="Symbol">;</a> <a id="383" href="Data.List.Base.html#7599" class="InductiveConstructor">[]</a><a id="385" class="Symbol">;</a> <a id="387" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="390" class="Symbol">)</a>
<a id="392" class="Keyword">open</a> <a id="397" class="Keyword">import</a> <a id="404" href="Data.List.Properties.html" class="Module">Data.List.Properties</a> <a id="425" class="Keyword">using</a> <a id="431" class="Symbol">(</a><a id="432" href="Data.List.Properties.html#2888" class="Function">∷-injective</a><a id="443" class="Symbol">)</a>
<a id="445" class="Keyword">open</a> <a id="450" class="Keyword">import</a> <a id="457" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="466" class="Keyword">open</a> <a id="471" class="Keyword">import</a> <a id="478" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="498" class="Keyword">using</a> <a id="504" class="Symbol">(</a><a id="505" href="Data.Nat.Properties.html#3266" class="Function">suc-injective</a><a id="518" class="Symbol">)</a>
<a id="520" class="Keyword">open</a> <a id="525" class="Keyword">import</a> <a id="532" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="550" class="Keyword">using</a> <a id="556" class="Symbol">(</a><a id="557" href="Data.Product.Base.html#3109" class="Function">uncurry</a><a id="564" class="Symbol">)</a>
<a id="566" class="Keyword">open</a> <a id="571" class="Keyword">import</a> <a id="578" href="Data.Unit.html" class="Module">Data.Unit</a>
<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="Function.Base.html" class="Module">Function.Base</a> <a id="614" class="Keyword">using</a> <a id="620" class="Symbol">(</a><a id="621" href="Function.Base.html#704" class="Function">id</a><a id="623" class="Symbol">;</a>  <a id="626" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="629" class="Symbol">)</a>
<a id="631" class="Keyword">open</a> <a id="636" class="Keyword">import</a> <a id="643" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
<a id="681" class="Keyword">open</a> <a id="686" class="Keyword">import</a> <a id="693" href="Relation.Nary.html" class="Module">Relation.Nary</a>

<a id="708" class="Comment">------------------------------------------------------------------------</a>
<a id="781" class="Comment">-- Reflects</a>

<a id="794" class="Keyword">open</a> <a id="799" class="Keyword">import</a> <a id="806" href="Relation.Nullary.Reflects.html" class="Module">Relation.Nullary.Reflects</a>

<a id="833" class="Keyword">infix</a> <a id="839" class="Number">4</a> <a id="841" href="README.Design.Decidability.html#1976" class="Function Operator">_≟₀_</a> <a id="846" href="README.Design.Decidability.html#2604" class="Function Operator">_≟₁_</a> <a id="851" href="README.Design.Decidability.html#3193" class="Function Operator">_≟₂_</a>

<a id="857" class="Comment">-- A proof of `Reflects P b` shows that a proposition `P` has the truth value of</a>
<a id="938" class="Comment">-- the boolean `b`. A proof of `Reflects P true` amounts to a proof of `P`, and</a>
<a id="1018" class="Comment">-- a proof of `Reflects P false` amounts to a refutation of `P`.</a>

<a id="ex₀"></a><a id="1084" href="README.Design.Decidability.html#1084" class="Function">ex₀</a> <a id="1088" class="Symbol">:</a> <a id="1090" class="Symbol">(</a><a id="1091" href="README.Design.Decidability.html#1091" class="Bound">n</a> <a id="1093" class="Symbol">:</a> <a id="1095" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1096" class="Symbol">)</a> <a id="1098" class="Symbol">→</a> <a id="1100" href="Relation.Nullary.Reflects.html#1010" class="Datatype">Reflects</a> <a id="1109" class="Symbol">(</a><a id="1110" href="README.Design.Decidability.html#1091" class="Bound">n</a> <a id="1112" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1114" href="README.Design.Decidability.html#1091" class="Bound">n</a><a id="1115" class="Symbol">)</a> <a id="1117" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a>
<a id="1122" href="README.Design.Decidability.html#1084" class="Function">ex₀</a> <a id="1126" href="README.Design.Decidability.html#1126" class="Bound">n</a> <a id="1128" class="Symbol">=</a> <a id="1130" href="Relation.Nullary.Reflects.html#1054" class="InductiveConstructor">ofʸ</a> <a id="1134" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="ex₁"></a><a id="1140" href="README.Design.Decidability.html#1140" class="Function">ex₁</a> <a id="1144" class="Symbol">:</a> <a id="1146" class="Symbol">(</a><a id="1147" href="README.Design.Decidability.html#1147" class="Bound">n</a> <a id="1149" class="Symbol">:</a> <a id="1151" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1152" class="Symbol">)</a> <a id="1154" class="Symbol">→</a> <a id="1156" href="Relation.Nullary.Reflects.html#1010" class="Datatype">Reflects</a> <a id="1165" class="Symbol">(</a><a id="1166" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="1171" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1173" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1177" href="README.Design.Decidability.html#1147" class="Bound">n</a><a id="1178" class="Symbol">)</a> <a id="1180" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a>
<a id="1186" href="README.Design.Decidability.html#1140" class="Function">ex₁</a> <a id="1190" href="README.Design.Decidability.html#1190" class="Bound">n</a> <a id="1192" class="Symbol">=</a> <a id="1194" href="Relation.Nullary.Reflects.html#1091" class="InductiveConstructor">ofⁿ</a> <a id="1198" class="Symbol">λ</a> <a id="1200" class="Symbol">()</a>

<a id="ex₂"></a><a id="1204" href="README.Design.Decidability.html#1204" class="Function">ex₂</a> <a id="1208" class="Symbol">:</a> <a id="1210" class="Symbol">(</a><a id="1211" href="README.Design.Decidability.html#1211" class="Bound">b</a> <a id="1213" class="Symbol">:</a> <a id="1215" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="1219" class="Symbol">)</a> <a id="1221" class="Symbol">→</a> <a id="1223" href="Relation.Nullary.Reflects.html#1010" class="Datatype">Reflects</a> <a id="1232" class="Symbol">(</a><a id="1233" href="Data.Bool.Base.html#1348" class="Function">T</a> <a id="1235" href="README.Design.Decidability.html#1211" class="Bound">b</a><a id="1236" class="Symbol">)</a> <a id="1238" href="README.Design.Decidability.html#1211" class="Bound">b</a>
<a id="1240" href="README.Design.Decidability.html#1204" class="Function">ex₂</a> <a id="1244" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="1250" class="Symbol">=</a> <a id="1252" href="Relation.Nullary.Reflects.html#1091" class="InductiveConstructor">ofⁿ</a> <a id="1256" href="Function.Base.html#704" class="Function">id</a>
<a id="1259" href="README.Design.Decidability.html#1204" class="Function">ex₂</a> <a id="1263" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a>  <a id="1269" class="Symbol">=</a> <a id="1271" href="Relation.Nullary.Reflects.html#1054" class="InductiveConstructor">ofʸ</a> <a id="1275" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>

<a id="1279" class="Comment">------------------------------------------------------------------------</a>
<a id="1352" class="Comment">-- Dec</a>

<a id="1360" class="Keyword">open</a> <a id="1365" class="Keyword">import</a> <a id="1372" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="1400" class="Comment">-- A proof of `Dec P` is a proof of `Reflects P b` for some `b`.</a>
<a id="1465" class="Comment">-- `Dec P` is declared as a record, with fields:</a>
<a id="1514" class="Comment">--   does : Bool</a>
<a id="1531" class="Comment">--   proof : Reflects P does</a>

<a id="ex₃"></a><a id="1561" href="README.Design.Decidability.html#1561" class="Function">ex₃</a> <a id="1565" class="Symbol">:</a> <a id="1567" class="Symbol">(</a><a id="1568" href="README.Design.Decidability.html#1568" class="Bound">b</a> <a id="1570" class="Symbol">:</a> <a id="1572" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="1576" class="Symbol">)</a> <a id="1578" class="Symbol">→</a> <a id="1580" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="1584" class="Symbol">(</a><a id="1585" href="Data.Bool.Base.html#1348" class="Function">T</a> <a id="1587" href="README.Design.Decidability.html#1568" class="Bound">b</a><a id="1588" class="Symbol">)</a>
<a id="1590" href="Relation.Nullary.Decidable.Core.html#1927" class="Field">does</a>  <a id="1596" class="Symbol">(</a><a id="1597" href="README.Design.Decidability.html#1561" class="Function">ex₃</a> <a id="1601" href="README.Design.Decidability.html#1601" class="Bound">b</a><a id="1602" class="Symbol">)</a> <a id="1604" class="Symbol">=</a> <a id="1606" href="README.Design.Decidability.html#1601" class="Bound">b</a>
<a id="1608" href="Relation.Nullary.Decidable.Core.html#1944" class="Field">proof</a> <a id="1614" class="Symbol">(</a><a id="1615" href="README.Design.Decidability.html#1561" class="Function">ex₃</a> <a id="1619" href="README.Design.Decidability.html#1619" class="Bound">b</a><a id="1620" class="Symbol">)</a> <a id="1622" class="Symbol">=</a> <a id="1624" href="README.Design.Decidability.html#1204" class="Function">ex₂</a> <a id="1628" href="README.Design.Decidability.html#1619" class="Bound">b</a>

<a id="1631" class="Comment">-- We also have pattern synonyms `yes` and `no`, allowing both fields to be</a>
<a id="1707" class="Comment">-- given at once.</a>

<a id="ex₄"></a><a id="1726" href="README.Design.Decidability.html#1726" class="Function">ex₄</a> <a id="1730" class="Symbol">:</a> <a id="1732" class="Symbol">(</a><a id="1733" href="README.Design.Decidability.html#1733" class="Bound">n</a> <a id="1735" class="Symbol">:</a> <a id="1737" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1738" class="Symbol">)</a> <a id="1740" class="Symbol">→</a> <a id="1742" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="1746" class="Symbol">(</a><a id="1747" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="1752" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1754" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1758" href="README.Design.Decidability.html#1733" class="Bound">n</a><a id="1759" class="Symbol">)</a>
<a id="1761" href="README.Design.Decidability.html#1726" class="Function">ex₄</a> <a id="1765" href="README.Design.Decidability.html#1765" class="Bound">n</a> <a id="1767" class="Symbol">=</a> <a id="1769" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="1772" class="Symbol">λ</a> <a id="1774" class="Symbol">()</a>

<a id="1778" class="Comment">-- It is possible, but not ideal, to define recursive decision procedures using</a>
<a id="1858" class="Comment">-- only the `yes` and `no` patterns. The following procedure decides whether two</a>
<a id="1939" class="Comment">-- given natural numbers are equal.</a>

<a id="_≟₀_"></a><a id="1976" href="README.Design.Decidability.html#1976" class="Function Operator">_≟₀_</a> <a id="1981" class="Symbol">:</a> <a id="1983" class="Symbol">(</a><a id="1984" href="README.Design.Decidability.html#1984" class="Bound">m</a> <a id="1986" href="README.Design.Decidability.html#1986" class="Bound">n</a> <a id="1988" class="Symbol">:</a> <a id="1990" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="1991" class="Symbol">)</a> <a id="1993" class="Symbol">→</a> <a id="1995" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="1999" class="Symbol">(</a><a id="2000" href="README.Design.Decidability.html#1984" class="Bound">m</a> <a id="2002" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2004" href="README.Design.Decidability.html#1986" class="Bound">n</a><a id="2005" class="Symbol">)</a>
<a id="2007" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2013" href="README.Design.Decidability.html#1976" class="Function Operator">≟₀</a> <a id="2016" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2022" class="Symbol">=</a> <a id="2024" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="2028" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2033" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2039" href="README.Design.Decidability.html#1976" class="Function Operator">≟₀</a> <a id="2042" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2046" href="README.Design.Decidability.html#2046" class="Bound">n</a> <a id="2048" class="Symbol">=</a> <a id="2050" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="2053" class="Symbol">λ</a> <a id="2055" class="Symbol">()</a>
<a id="2058" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2062" href="README.Design.Decidability.html#2062" class="Bound">m</a> <a id="2064" href="README.Design.Decidability.html#1976" class="Function Operator">≟₀</a> <a id="2067" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2073" class="Symbol">=</a> <a id="2075" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="2078" class="Symbol">λ</a> <a id="2080" class="Symbol">()</a>
<a id="2083" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2087" href="README.Design.Decidability.html#2087" class="Bound">m</a> <a id="2089" href="README.Design.Decidability.html#1976" class="Function Operator">≟₀</a> <a id="2092" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2096" href="README.Design.Decidability.html#2096" class="Bound">n</a> <a id="2098" class="Keyword">with</a> <a id="2103" href="README.Design.Decidability.html#2087" class="Bound">m</a> <a id="2105" href="README.Design.Decidability.html#1976" class="Function Operator">≟₀</a> <a id="2108" href="README.Design.Decidability.html#2096" class="Bound">n</a>
<a id="2110" class="Symbol">...</a> <a id="2114" class="Symbol">|</a> <a id="2116" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="2120" href="README.Design.Decidability.html#2120" class="Bound">p</a> <a id="2122" class="Symbol">=</a> <a id="2124" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="2128" class="Symbol">(</a><a id="2129" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="2134" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2138" href="README.Design.Decidability.html#2120" class="Bound">p</a><a id="2139" class="Symbol">)</a>
<a id="2141" class="Symbol">...</a> <a id="2145" class="Symbol">|</a> <a id="2147" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="2150" href="README.Design.Decidability.html#2150" class="Bound">¬p</a> <a id="2153" class="Symbol">=</a> <a id="2155" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="2158" class="Symbol">(</a><a id="2159" href="README.Design.Decidability.html#2150" class="Bound">¬p</a> <a id="2162" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2164" href="Data.Nat.Properties.html#3266" class="Function">suc-injective</a><a id="2177" class="Symbol">)</a>

<a id="2180" class="Comment">-- In this case, we can see that `does (suc m ≟ suc n)` should be equal to</a>
<a id="2255" class="Comment">-- `does (m ≟ n)`, because a `yes` from `m ≟ n` gives rise to a `yes` from the</a>
<a id="2334" class="Comment">-- result, and similarly for `no`. However, in the above definition, this</a>
<a id="2408" class="Comment">-- equality does not hold definitionally, because we always do a case split</a>
<a id="2484" class="Comment">-- before returning a result. To avoid this, we can return the `does` part</a>
<a id="2559" class="Comment">-- separately, before any pattern matching.</a>

<a id="_≟₁_"></a><a id="2604" href="README.Design.Decidability.html#2604" class="Function Operator">_≟₁_</a> <a id="2609" class="Symbol">:</a> <a id="2611" class="Symbol">(</a><a id="2612" href="README.Design.Decidability.html#2612" class="Bound">m</a> <a id="2614" href="README.Design.Decidability.html#2614" class="Bound">n</a> <a id="2616" class="Symbol">:</a> <a id="2618" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2619" class="Symbol">)</a> <a id="2621" class="Symbol">→</a> <a id="2623" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="2627" class="Symbol">(</a><a id="2628" href="README.Design.Decidability.html#2612" class="Bound">m</a> <a id="2630" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2632" href="README.Design.Decidability.html#2614" class="Bound">n</a><a id="2633" class="Symbol">)</a>
<a id="2635" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2641" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2644" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2650" class="Symbol">=</a> <a id="2652" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="2656" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2661" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2667" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2670" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2674" href="README.Design.Decidability.html#2674" class="Bound">n</a> <a id="2676" class="Symbol">=</a> <a id="2678" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="2681" class="Symbol">λ</a> <a id="2683" class="Symbol">()</a>
<a id="2686" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2690" href="README.Design.Decidability.html#2690" class="Bound">m</a> <a id="2692" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2695" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2701" class="Symbol">=</a> <a id="2703" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="2706" class="Symbol">λ</a> <a id="2708" class="Symbol">()</a>
<a id="2711" href="Relation.Nullary.Decidable.Core.html#1927" class="Field">does</a>  <a id="2717" class="Symbol">(</a><a id="2718" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2722" href="README.Design.Decidability.html#2722" class="Bound">m</a> <a id="2724" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2727" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2731" href="README.Design.Decidability.html#2731" class="Bound">n</a><a id="2732" class="Symbol">)</a> <a id="2734" class="Symbol">=</a> <a id="2736" href="Relation.Nullary.Decidable.Core.html#1927" class="Field">does</a> <a id="2741" class="Symbol">(</a><a id="2742" href="README.Design.Decidability.html#2722" class="Bound">m</a> <a id="2744" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2747" href="README.Design.Decidability.html#2731" class="Bound">n</a><a id="2748" class="Symbol">)</a>
<a id="2750" href="Relation.Nullary.Decidable.Core.html#1944" class="Field">proof</a> <a id="2756" class="Symbol">(</a><a id="2757" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2761" href="README.Design.Decidability.html#2761" class="Bound">m</a> <a id="2763" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2766" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2770" href="README.Design.Decidability.html#2770" class="Bound">n</a><a id="2771" class="Symbol">)</a> <a id="2773" class="Keyword">with</a> <a id="2778" href="README.Design.Decidability.html#2761" class="Bound">m</a> <a id="2780" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2783" href="README.Design.Decidability.html#2770" class="Bound">n</a>
<a id="2785" class="Symbol">...</a> <a id="2789" class="Symbol">|</a> <a id="2791" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="2795" href="README.Design.Decidability.html#2795" class="Bound">p</a> <a id="2797" class="Symbol">=</a> <a id="2799" href="Relation.Nullary.Reflects.html#1054" class="InductiveConstructor">ofʸ</a> <a id="2803" class="Symbol">(</a><a id="2804" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="2809" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2813" href="README.Design.Decidability.html#2795" class="Bound">p</a><a id="2814" class="Symbol">)</a>
<a id="2816" class="Symbol">...</a> <a id="2820" class="Symbol">|</a> <a id="2822" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="2825" href="README.Design.Decidability.html#2825" class="Bound">¬p</a> <a id="2828" class="Symbol">=</a> <a id="2830" href="Relation.Nullary.Reflects.html#1091" class="InductiveConstructor">ofⁿ</a> <a id="2834" class="Symbol">(</a><a id="2835" href="README.Design.Decidability.html#2825" class="Bound">¬p</a> <a id="2838" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2840" href="Data.Nat.Properties.html#3266" class="Function">suc-injective</a><a id="2853" class="Symbol">)</a>

<a id="2856" class="Comment">-- We now get definitional equalities such as the following.</a>

<a id="2918" href="README.Design.Decidability.html#2918" class="Function">_</a> <a id="2920" class="Symbol">:</a> <a id="2922" class="Symbol">(</a><a id="2923" href="README.Design.Decidability.html#2923" class="Bound">m</a> <a id="2925" href="README.Design.Decidability.html#2925" class="Bound">n</a> <a id="2927" class="Symbol">:</a> <a id="2929" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2930" class="Symbol">)</a> <a id="2932" class="Symbol">→</a> <a id="2934" href="Relation.Nullary.Decidable.Core.html#1927" class="Field">does</a> <a id="2939" class="Symbol">(</a><a id="2940" class="Number">5</a> <a id="2942" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2944" href="README.Design.Decidability.html#2923" class="Bound">m</a> <a id="2946" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2949" class="Number">3</a> <a id="2951" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2953" href="README.Design.Decidability.html#2925" class="Bound">n</a><a id="2954" class="Symbol">)</a> <a id="2956" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2958" href="Relation.Nullary.Decidable.Core.html#1927" class="Field">does</a> <a id="2963" class="Symbol">(</a><a id="2964" class="Number">2</a> <a id="2966" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2968" href="README.Design.Decidability.html#2923" class="Bound">m</a> <a id="2970" href="README.Design.Decidability.html#2604" class="Function Operator">≟₁</a> <a id="2973" href="README.Design.Decidability.html#2925" class="Bound">n</a><a id="2974" class="Symbol">)</a>
<a id="2976" class="Symbol">_</a> <a id="2978" class="Symbol">=</a> <a id="2980" class="Symbol">λ</a> <a id="2982" href="README.Design.Decidability.html#2982" class="Bound">m</a> <a id="2984" href="README.Design.Decidability.html#2984" class="Bound">n</a> <a id="2986" class="Symbol">→</a> <a id="2988" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="2994" class="Comment">-- Even better, from a maintainability point of view, is to use `map` or `map′`,</a>
<a id="3075" class="Comment">-- both of which capture the pattern of the `does` field remaining the same, but</a>
<a id="3156" class="Comment">-- the `proof` field being updated.</a>

<a id="_≟₂_"></a><a id="3193" href="README.Design.Decidability.html#3193" class="Function Operator">_≟₂_</a> <a id="3198" class="Symbol">:</a> <a id="3200" class="Symbol">(</a><a id="3201" href="README.Design.Decidability.html#3201" class="Bound">m</a> <a id="3203" href="README.Design.Decidability.html#3203" class="Bound">n</a> <a id="3205" class="Symbol">:</a> <a id="3207" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3208" class="Symbol">)</a> <a id="3210" class="Symbol">→</a> <a id="3212" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="3216" class="Symbol">(</a><a id="3217" href="README.Design.Decidability.html#3201" class="Bound">m</a> <a id="3219" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3221" href="README.Design.Decidability.html#3203" class="Bound">n</a><a id="3222" class="Symbol">)</a>
<a id="3224" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="3230" href="README.Design.Decidability.html#3193" class="Function Operator">≟₂</a> <a id="3233" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="3239" class="Symbol">=</a> <a id="3241" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="3245" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="3250" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="3256" href="README.Design.Decidability.html#3193" class="Function Operator">≟₂</a> <a id="3259" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3263" href="README.Design.Decidability.html#3263" class="Bound">n</a> <a id="3265" class="Symbol">=</a> <a id="3267" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="3270" class="Symbol">λ</a> <a id="3272" class="Symbol">()</a>
<a id="3275" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3279" href="README.Design.Decidability.html#3279" class="Bound">m</a> <a id="3281" href="README.Design.Decidability.html#3193" class="Function Operator">≟₂</a> <a id="3284" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="3290" class="Symbol">=</a> <a id="3292" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="3295" class="Symbol">λ</a> <a id="3297" class="Symbol">()</a>
<a id="3300" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3304" href="README.Design.Decidability.html#3304" class="Bound">m</a> <a id="3306" href="README.Design.Decidability.html#3193" class="Function Operator">≟₂</a> <a id="3309" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3313" href="README.Design.Decidability.html#3313" class="Bound">n</a> <a id="3315" class="Symbol">=</a> <a id="3317" href="Relation.Nullary.Decidable.Core.html#5914" class="Function">map′</a> <a id="3322" class="Symbol">(</a><a id="3323" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="3328" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="3331" class="Symbol">)</a> <a id="3333" href="Data.Nat.Properties.html#3266" class="Function">suc-injective</a> <a id="3347" class="Symbol">(</a><a id="3348" href="README.Design.Decidability.html#3304" class="Bound">m</a> <a id="3350" href="README.Design.Decidability.html#3193" class="Function Operator">≟₂</a> <a id="3353" href="README.Design.Decidability.html#3313" class="Bound">n</a><a id="3354" class="Symbol">)</a>

<a id="3357" href="README.Design.Decidability.html#3357" class="Function">_</a> <a id="3359" class="Symbol">:</a> <a id="3361" class="Symbol">(</a><a id="3362" href="README.Design.Decidability.html#3362" class="Bound">m</a> <a id="3364" href="README.Design.Decidability.html#3364" class="Bound">n</a> <a id="3366" class="Symbol">:</a> <a id="3368" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3369" class="Symbol">)</a> <a id="3371" class="Symbol">→</a> <a id="3373" href="Relation.Nullary.Decidable.Core.html#1927" class="Field">does</a> <a id="3378" class="Symbol">(</a><a id="3379" class="Number">5</a> <a id="3381" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3383" href="README.Design.Decidability.html#3362" class="Bound">m</a> <a id="3385" href="README.Design.Decidability.html#3193" class="Function Operator">≟₂</a> <a id="3388" class="Number">3</a> <a id="3390" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3392" href="README.Design.Decidability.html#3364" class="Bound">n</a><a id="3393" class="Symbol">)</a> <a id="3395" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3397" href="Relation.Nullary.Decidable.Core.html#1927" class="Field">does</a> <a id="3402" class="Symbol">(</a><a id="3403" class="Number">2</a> <a id="3405" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3407" href="README.Design.Decidability.html#3362" class="Bound">m</a> <a id="3409" href="README.Design.Decidability.html#3193" class="Function Operator">≟₂</a> <a id="3412" href="README.Design.Decidability.html#3364" class="Bound">n</a><a id="3413" class="Symbol">)</a>
<a id="3415" class="Symbol">_</a> <a id="3417" class="Symbol">=</a> <a id="3419" class="Symbol">λ</a> <a id="3421" href="README.Design.Decidability.html#3421" class="Bound">m</a> <a id="3423" href="README.Design.Decidability.html#3423" class="Bound">n</a> <a id="3425" class="Symbol">→</a> <a id="3427" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="3433" class="Comment">-- `map′` can be used in conjunction with combinators such as `_⊎-dec_` and</a>
<a id="3509" class="Comment">-- `_×-dec_` to build complex (simply typed) decision procedures.</a>

<a id="3576" class="Keyword">module</a> <a id="ListDecEq₀"></a><a id="3583" href="README.Design.Decidability.html#3583" class="Module">ListDecEq₀</a> <a id="3594" class="Symbol">{</a><a id="3595" href="README.Design.Decidability.html#3595" class="Bound">a</a><a id="3596" class="Symbol">}</a> <a id="3598" class="Symbol">{</a><a id="3599" href="README.Design.Decidability.html#3599" class="Bound">A</a> <a id="3601" class="Symbol">:</a> <a id="3603" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="3607" href="README.Design.Decidability.html#3595" class="Bound">a</a><a id="3608" class="Symbol">}</a> <a id="3610" class="Symbol">(</a><a id="3611" href="README.Design.Decidability.html#3611" class="Bound Operator">_≟ᴬ_</a> <a id="3616" class="Symbol">:</a> <a id="3618" class="Symbol">(</a><a id="3619" href="README.Design.Decidability.html#3619" class="Bound">x</a> <a id="3621" href="README.Design.Decidability.html#3621" class="Bound">y</a> <a id="3623" class="Symbol">:</a> <a id="3625" href="README.Design.Decidability.html#3599" class="Bound">A</a><a id="3626" class="Symbol">)</a> <a id="3628" class="Symbol">→</a> <a id="3630" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="3634" class="Symbol">(</a><a id="3635" href="README.Design.Decidability.html#3619" class="Bound">x</a> <a id="3637" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3639" href="README.Design.Decidability.html#3621" class="Bound">y</a><a id="3640" class="Symbol">))</a> <a id="3643" class="Keyword">where</a>

  <a id="ListDecEq₀._≟ᴸᴬ_"></a><a id="3652" href="README.Design.Decidability.html#3652" class="Function Operator">_≟ᴸᴬ_</a> <a id="3658" class="Symbol">:</a> <a id="3660" class="Symbol">(</a><a id="3661" href="README.Design.Decidability.html#3661" class="Bound">xs</a> <a id="3664" href="README.Design.Decidability.html#3664" class="Bound">ys</a> <a id="3667" class="Symbol">:</a> <a id="3669" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3674" href="README.Design.Decidability.html#3599" class="Bound">A</a><a id="3675" class="Symbol">)</a> <a id="3677" class="Symbol">→</a> <a id="3679" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="3683" class="Symbol">(</a><a id="3684" href="README.Design.Decidability.html#3661" class="Bound">xs</a> <a id="3687" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3689" href="README.Design.Decidability.html#3664" class="Bound">ys</a><a id="3691" class="Symbol">)</a>
  <a id="3695" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="3704" href="README.Design.Decidability.html#3652" class="Function Operator">≟ᴸᴬ</a> <a id="3708" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="3717" class="Symbol">=</a> <a id="3719" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="3723" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="3730" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="3739" href="README.Design.Decidability.html#3652" class="Function Operator">≟ᴸᴬ</a> <a id="3743" class="Symbol">(</a><a id="3744" href="README.Design.Decidability.html#3744" class="Bound">y</a> <a id="3746" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3748" href="README.Design.Decidability.html#3748" class="Bound">ys</a><a id="3750" class="Symbol">)</a> <a id="3752" class="Symbol">=</a> <a id="3754" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="3757" class="Symbol">λ</a> <a id="3759" class="Symbol">()</a>
  <a id="3764" class="Symbol">(</a><a id="3765" href="README.Design.Decidability.html#3765" class="Bound">x</a> <a id="3767" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3769" href="README.Design.Decidability.html#3769" class="Bound">xs</a><a id="3771" class="Symbol">)</a> <a id="3773" href="README.Design.Decidability.html#3652" class="Function Operator">≟ᴸᴬ</a> <a id="3777" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="3786" class="Symbol">=</a> <a id="3788" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="3791" class="Symbol">λ</a> <a id="3793" class="Symbol">()</a>
  <a id="3798" class="Symbol">(</a><a id="3799" href="README.Design.Decidability.html#3799" class="Bound">x</a> <a id="3801" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3803" href="README.Design.Decidability.html#3803" class="Bound">xs</a><a id="3805" class="Symbol">)</a> <a id="3807" href="README.Design.Decidability.html#3652" class="Function Operator">≟ᴸᴬ</a> <a id="3811" class="Symbol">(</a><a id="3812" href="README.Design.Decidability.html#3812" class="Bound">y</a> <a id="3814" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3816" href="README.Design.Decidability.html#3816" class="Bound">ys</a><a id="3818" class="Symbol">)</a> <a id="3820" class="Symbol">=</a>
    <a id="3826" href="Relation.Nullary.Decidable.Core.html#5914" class="Function">map′</a> <a id="3831" class="Symbol">(</a><a id="3832" href="Data.Product.Base.html#3109" class="Function">uncurry</a> <a id="3840" class="Symbol">(</a><a id="3841" href="Relation.Binary.PropositionalEquality.Core.html#1576" class="Function">cong₂</a> <a id="3847" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="3850" class="Symbol">))</a> <a id="3853" href="Data.List.Properties.html#2888" class="Function">∷-injective</a> <a id="3865" class="Symbol">(</a><a id="3866" href="README.Design.Decidability.html#3799" class="Bound">x</a> <a id="3868" href="README.Design.Decidability.html#3611" class="Bound Operator">≟ᴬ</a> <a id="3871" href="README.Design.Decidability.html#3812" class="Bound">y</a> <a id="3873" href="Relation.Nullary.Decidable.Core.html#3103" class="Function Operator">×-dec</a> <a id="3879" href="README.Design.Decidability.html#3803" class="Bound">xs</a> <a id="3882" href="README.Design.Decidability.html#3652" class="Function Operator">≟ᴸᴬ</a> <a id="3886" href="README.Design.Decidability.html#3816" class="Bound">ys</a><a id="3888" class="Symbol">)</a>

<a id="3891" class="Comment">-- The final case says that `x ∷ xs ≡ y ∷ ys` exactly when `x ≡ y` *and*</a>
<a id="3964" class="Comment">-- `xs ≡ ys`. The proofs are updated by the first two arguments to `map′`.</a>

<a id="4040" class="Comment">-- In the case of ≡-equality tests, the pattern</a>
<a id="4088" class="Comment">-- `map′ (congₙ c) c-injective (x₀ ≟ y₀ ×-dec ... ×-dec xₙ₋₁ ≟ yₙ₋₁)`</a>
<a id="4158" class="Comment">-- is captured by `≟-mapₙ n c c-injective (x₀ ≟ y₀) ... (xₙ₋₁ ≟ yₙ₋₁)`.</a>

<a id="4231" class="Keyword">module</a> <a id="ListDecEq₁"></a><a id="4238" href="README.Design.Decidability.html#4238" class="Module">ListDecEq₁</a> <a id="4249" class="Symbol">{</a><a id="4250" href="README.Design.Decidability.html#4250" class="Bound">a</a><a id="4251" class="Symbol">}</a> <a id="4253" class="Symbol">{</a><a id="4254" href="README.Design.Decidability.html#4254" class="Bound">A</a> <a id="4256" class="Symbol">:</a> <a id="4258" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="4262" href="README.Design.Decidability.html#4250" class="Bound">a</a><a id="4263" class="Symbol">}</a> <a id="4265" class="Symbol">(</a><a id="4266" href="README.Design.Decidability.html#4266" class="Bound Operator">_≟ᴬ_</a> <a id="4271" class="Symbol">:</a> <a id="4273" class="Symbol">(</a><a id="4274" href="README.Design.Decidability.html#4274" class="Bound">x</a> <a id="4276" href="README.Design.Decidability.html#4276" class="Bound">y</a> <a id="4278" class="Symbol">:</a> <a id="4280" href="README.Design.Decidability.html#4254" class="Bound">A</a><a id="4281" class="Symbol">)</a> <a id="4283" class="Symbol">→</a> <a id="4285" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="4289" class="Symbol">(</a><a id="4290" href="README.Design.Decidability.html#4274" class="Bound">x</a> <a id="4292" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4294" href="README.Design.Decidability.html#4276" class="Bound">y</a><a id="4295" class="Symbol">))</a> <a id="4298" class="Keyword">where</a>

  <a id="ListDecEq₁._≟ᴸᴬ_"></a><a id="4307" href="README.Design.Decidability.html#4307" class="Function Operator">_≟ᴸᴬ_</a> <a id="4313" class="Symbol">:</a> <a id="4315" class="Symbol">(</a><a id="4316" href="README.Design.Decidability.html#4316" class="Bound">xs</a> <a id="4319" href="README.Design.Decidability.html#4319" class="Bound">ys</a> <a id="4322" class="Symbol">:</a> <a id="4324" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4329" href="README.Design.Decidability.html#4254" class="Bound">A</a><a id="4330" class="Symbol">)</a> <a id="4332" class="Symbol">→</a> <a id="4334" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="4338" class="Symbol">(</a><a id="4339" href="README.Design.Decidability.html#4316" class="Bound">xs</a> <a id="4342" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4344" href="README.Design.Decidability.html#4319" class="Bound">ys</a><a id="4346" class="Symbol">)</a>
  <a id="4350" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="4359" href="README.Design.Decidability.html#4307" class="Function Operator">≟ᴸᴬ</a> <a id="4363" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="4372" class="Symbol">=</a> <a id="4374" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="4378" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="4385" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="4394" href="README.Design.Decidability.html#4307" class="Function Operator">≟ᴸᴬ</a> <a id="4398" class="Symbol">(</a><a id="4399" href="README.Design.Decidability.html#4399" class="Bound">y</a> <a id="4401" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4403" href="README.Design.Decidability.html#4403" class="Bound">ys</a><a id="4405" class="Symbol">)</a> <a id="4407" class="Symbol">=</a> <a id="4409" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="4412" class="Symbol">λ</a> <a id="4414" class="Symbol">()</a>
  <a id="4419" class="Symbol">(</a><a id="4420" href="README.Design.Decidability.html#4420" class="Bound">x</a> <a id="4422" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4424" href="README.Design.Decidability.html#4424" class="Bound">xs</a><a id="4426" class="Symbol">)</a> <a id="4428" href="README.Design.Decidability.html#4307" class="Function Operator">≟ᴸᴬ</a> <a id="4432" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="4441" class="Symbol">=</a> <a id="4443" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="4446" class="Symbol">λ</a> <a id="4448" class="Symbol">()</a>
  <a id="4453" class="Symbol">(</a><a id="4454" href="README.Design.Decidability.html#4454" class="Bound">x</a> <a id="4456" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4458" href="README.Design.Decidability.html#4458" class="Bound">xs</a><a id="4460" class="Symbol">)</a> <a id="4462" href="README.Design.Decidability.html#4307" class="Function Operator">≟ᴸᴬ</a> <a id="4466" class="Symbol">(</a><a id="4467" href="README.Design.Decidability.html#4467" class="Bound">y</a> <a id="4469" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4471" href="README.Design.Decidability.html#4471" class="Bound">ys</a><a id="4473" class="Symbol">)</a> <a id="4475" class="Symbol">=</a> <a id="4477" href="Relation.Nary.html#2991" class="Function">≟-mapₙ</a> <a id="4484" class="Number">2</a> <a id="4486" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a> <a id="4490" href="Data.List.Properties.html#2888" class="Function">∷-injective</a> <a id="4502" class="Symbol">(</a><a id="4503" href="README.Design.Decidability.html#4454" class="Bound">x</a> <a id="4505" href="README.Design.Decidability.html#4266" class="Bound Operator">≟ᴬ</a> <a id="4508" href="README.Design.Decidability.html#4467" class="Bound">y</a><a id="4509" class="Symbol">)</a> <a id="4511" class="Symbol">(</a><a id="4512" href="README.Design.Decidability.html#4458" class="Bound">xs</a> <a id="4515" href="README.Design.Decidability.html#4307" class="Function Operator">≟ᴸᴬ</a> <a id="4519" href="README.Design.Decidability.html#4471" class="Bound">ys</a><a id="4521" class="Symbol">)</a>
</pre></body></html>