<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--cubical-compatible</a> <a id="305" class="Pragma">--safe</a> <a id="312" class="Symbol">#-}</a>

<a id="317" class="Keyword">module</a> <a id="324" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="342" class="Keyword">where</a>

<a id="349" class="Keyword">open</a> <a id="354" class="Keyword">import</a> <a id="361" href="Algebra.html" class="Module">Algebra</a>
<a id="369" class="Keyword">open</a> <a id="374" class="Keyword">import</a> <a id="381" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>   <a id="397" class="Symbol">as</a> <a id="400" class="Module">Fin</a>     <a id="408" class="Keyword">using</a> <a id="414" class="Symbol">(</a><a id="415" href="Data.Fin.Base.html#1154" class="Datatype">Fin</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>   <a id="448" class="Symbol">as</a> <a id="451" class="Module">Vec</a>     <a id="459" class="Keyword">using</a> <a id="465" class="Symbol">(</a><a id="466" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a><a id="469" class="Symbol">;</a> <a id="471" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">_∷_</a><a id="474" class="Symbol">;</a> <a id="476" href="Data.Vec.Base.html#1150" class="InductiveConstructor">[]</a><a id="478" class="Symbol">)</a>
<a id="480" class="Keyword">open</a> <a id="485" class="Keyword">import</a> <a id="492" href="Data.List.Base.html" class="Module">Data.List.Base</a>  <a id="508" class="Symbol">as</a> <a id="511" class="Module">List</a>    <a id="519" class="Keyword">using</a> <a id="525" class="Symbol">(</a><a id="526" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="530" class="Symbol">;</a> <a id="532" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="535" class="Symbol">;</a> <a id="537" href="Data.List.Base.html#7808" class="InductiveConstructor">[]</a><a id="539" class="Symbol">)</a>
<a id="541" class="Keyword">open</a> <a id="546" class="Keyword">import</a> <a id="553" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="569" class="Symbol">as</a> <a id="572" class="Module">Maybe</a>   <a id="580" class="Keyword">using</a> <a id="586" class="Symbol">(</a><a id="587" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a><a id="592" class="Symbol">;</a> <a id="594" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a><a id="598" class="Symbol">;</a> <a id="600" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="607" class="Symbol">;</a> <a id="609" href="Data.Maybe.Base.html#1722" class="Function">fromMaybe</a><a id="618" class="Symbol">)</a>
<a id="620" class="Keyword">open</a> <a id="625" class="Keyword">import</a> <a id="632" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>              <a id="659" class="Keyword">using</a> <a id="665" class="Symbol">(</a><a id="666" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="667" class="Symbol">;</a> <a id="669" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="672" class="Symbol">;</a> <a id="674" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="678" class="Symbol">;</a> <a id="680" href="Data.Nat.Base.html#1457" class="Primitive Operator">_&lt;ᵇ_</a><a id="684" class="Symbol">)</a>
<a id="686" class="Keyword">open</a> <a id="691" class="Keyword">import</a> <a id="698" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>             <a id="725" class="Keyword">using</a> <a id="731" class="Symbol">(</a><a id="732" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="736" class="Symbol">;</a> <a id="738" href="Data.Bool.Base.html#1505" class="Function Operator">if_then_else_</a><a id="751" class="Symbol">;</a> <a id="753" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="757" class="Symbol">;</a> <a id="759" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="764" class="Symbol">)</a>
<a id="766" class="Keyword">open</a> <a id="771" class="Keyword">import</a> <a id="778" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>             <a id="805" class="Keyword">using</a> <a id="811" class="Symbol">(</a><a id="812" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="813" class="Symbol">)</a>
<a id="815" class="Keyword">open</a> <a id="820" class="Keyword">import</a> <a id="827" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="844" class="Symbol">as</a> <a id="847" class="Module">String</a> <a id="854" class="Keyword">using</a> <a id="860" class="Symbol">(</a><a id="861" href="Agda.Builtin.String.html#335" class="Postulate">String</a><a id="867" class="Symbol">;</a> <a id="869" href="Data.String.Base.html#2404" class="Function Operator">_++_</a><a id="873" class="Symbol">;</a> <a id="875" href="Data.String.Base.html#2864" class="Function">parens</a><a id="881" class="Symbol">)</a>
<a id="883" class="Keyword">open</a> <a id="888" class="Keyword">import</a> <a id="895" href="Data.Product.Base.html" class="Module">Data.Product.Base</a>          <a id="922" class="Keyword">using</a> <a id="928" class="Symbol">(</a><a id="929" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="932" class="Symbol">;</a> <a id="934" href="Data.Product.Base.html#636" class="Field">proj₁</a><a id="939" class="Symbol">)</a>
<a id="941" class="Keyword">open</a> <a id="946" class="Keyword">import</a> <a id="953" href="Function.Base.html" class="Module">Function.Base</a>
<a id="967" class="Keyword">open</a> <a id="972" class="Keyword">import</a> <a id="979" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="1007" class="Keyword">open</a> <a id="1012" class="Keyword">import</a> <a id="1019" href="Reflection.html" class="Module">Reflection</a>
<a id="1030" class="Keyword">open</a> <a id="1035" class="Keyword">import</a> <a id="1042" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="1066" class="Keyword">open</a> <a id="1071" class="Keyword">import</a> <a id="1078" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a> <a id="1098" class="Symbol">as</a> <a id="1101" class="Module">Term</a>
<a id="1106" class="Keyword">open</a> <a id="1111" class="Keyword">import</a> <a id="1118" href="Reflection.AST.AlphaEquality.html" class="Module">Reflection.AST.AlphaEquality</a>
<a id="1147" class="Keyword">open</a> <a id="1152" class="Keyword">import</a> <a id="1159" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="1179" class="Symbol">as</a> <a id="1182" class="Module">Name</a>
<a id="1187" class="Keyword">open</a> <a id="1192" class="Keyword">import</a> <a id="1199" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>
<a id="1221" class="Keyword">open</a> <a id="1226" class="Keyword">import</a> <a id="1233" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a>
<a id="1253" class="Keyword">open</a> <a id="1258" class="Keyword">import</a> <a id="1265" href="Data.List.Reflection.html" class="Module">Data.List.Reflection</a>
<a id="1286" class="Keyword">import</a> <a id="1293" href="Data.Vec.Reflection.html" class="Module">Data.Vec.Reflection</a> <a id="1313" class="Symbol">as</a> <a id="1316" class="Module">Vec</a>

<a id="1321" class="Keyword">open</a> <a id="1326" class="Keyword">import</a> <a id="1333" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1365" class="Keyword">renaming</a> <a id="1374" class="Symbol">(</a><a id="1375" href="Tactic.RingSolver.NonReflective.html#3025" class="Function">solve</a> <a id="1381" class="Symbol">to</a> <a id="1384" class="Function">solver</a><a id="1390" class="Symbol">)</a>
<a id="1392" class="Keyword">open</a> <a id="1397" class="Keyword">import</a> <a id="1404" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1449" class="Keyword">open</a> <a id="1454" class="Keyword">import</a> <a id="1461" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1491" class="Symbol">as</a> <a id="1494" class="Module">NatSet</a>

<a id="1502" class="Keyword">open</a> <a id="1507" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1288" class="Module">AlmostCommutativeRing</a>

<a id="1530" class="Comment">------------------------------------------------------------------------</a>
<a id="1603" class="Comment">-- Utilities</a>

<a id="1617" class="Keyword">private</a>
  <a id="VarMap"></a><a id="1627" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a> <a id="1634" class="Symbol">:</a> <a id="1636" href="Agda.Primitive.html#388" class="Primitive">Set</a>
  <a id="1642" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a> <a id="1649" class="Symbol">=</a> <a id="1651" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="1653" class="Symbol">→</a> <a id="1655" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1661" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>

  <a id="getVisible"></a><a id="1669" href="Tactic.RingSolver.html#1669" class="Function">getVisible</a> <a id="1680" class="Symbol">:</a> <a id="1682" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="1686" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1691" class="Symbol">→</a> <a id="1693" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1699" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="1706" href="Tactic.RingSolver.html#1669" class="Function">getVisible</a> <a id="1717" class="Symbol">(</a><a id="1718" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="1722" class="Symbol">(</a><a id="1723" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="1732" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="1740" class="Symbol">_)</a> <a id="1743" href="Tactic.RingSolver.html#1743" class="Bound">x</a><a id="1744" class="Symbol">)</a> <a id="1746" class="Symbol">=</a> <a id="1748" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="1753" href="Tactic.RingSolver.html#1743" class="Bound">x</a>
  <a id="1757" href="Tactic.RingSolver.html#1669" class="CatchallClause Function">getVisible</a><a id="1767" class="CatchallClause"> </a><a id="1768" class="CatchallClause Symbol">_</a>                            <a id="1797" class="Symbol">=</a> <a id="1799" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="getVisibleArgs"></a><a id="1810" href="Tactic.RingSolver.html#1810" class="Function">getVisibleArgs</a> <a id="1825" class="Symbol">:</a> <a id="1827" class="Symbol">∀</a> <a id="1829" href="Tactic.RingSolver.html#1829" class="Bound">n</a> <a id="1831" class="Symbol">→</a> <a id="1833" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1838" class="Symbol">→</a> <a id="1840" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1846" class="Symbol">(</a><a id="1847" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="1851" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1856" href="Tactic.RingSolver.html#1829" class="Bound">n</a><a id="1857" class="Symbol">)</a>
  <a id="1861" href="Tactic.RingSolver.html#1810" class="Function">getVisibleArgs</a> <a id="1876" href="Tactic.RingSolver.html#1876" class="Bound">n</a> <a id="1878" class="Symbol">(</a><a id="1879" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="1883" class="Symbol">_</a> <a id="1885" href="Tactic.RingSolver.html#1885" class="Bound">xs</a><a id="1887" class="Symbol">)</a> <a id="1889" class="Symbol">=</a> <a id="1891" href="Data.Maybe.Base.html#2110" class="Function">Maybe.map</a> <a id="1901" href="Data.Vec.Base.html#8884" class="Function">Vec.reverse</a>
    <a id="1917" class="Symbol">(</a><a id="1918" href="Data.List.Base.html#4452" class="Function">List.foldl</a> <a id="1929" href="Tactic.RingSolver.html#1980" class="Function">f</a> <a id="1931" href="Tactic.RingSolver.html#2124" class="Function">c</a> <a id="1933" class="Symbol">(</a><a id="1934" href="Data.List.Base.html#1719" class="Function">List.mapMaybe</a> <a id="1948" href="Tactic.RingSolver.html#1669" class="Function">getVisible</a> <a id="1959" href="Tactic.RingSolver.html#1885" class="Bound">xs</a><a id="1961" class="Symbol">)</a> <a id="1963" href="Tactic.RingSolver.html#1876" class="Bound">n</a><a id="1964" class="Symbol">)</a>
    <a id="1970" class="Keyword">where</a>
    <a id="1980" href="Tactic.RingSolver.html#1980" class="Function">f</a> <a id="1982" class="Symbol">:</a> <a id="1984" class="Symbol">(∀</a> <a id="1987" href="Tactic.RingSolver.html#1987" class="Bound">n</a> <a id="1989" class="Symbol">→</a> <a id="1991" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1997" class="Symbol">(</a><a id="1998" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="2002" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2007" href="Tactic.RingSolver.html#1987" class="Bound">n</a><a id="2008" class="Symbol">))</a> <a id="2011" class="Symbol">→</a> <a id="2013" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2018" class="Symbol">→</a> <a id="2020" class="Symbol">∀</a> <a id="2022" href="Tactic.RingSolver.html#2022" class="Bound">n</a> <a id="2024" class="Symbol">→</a> <a id="2026" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2032" class="Symbol">(</a><a id="2033" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="2037" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2042" href="Tactic.RingSolver.html#2022" class="Bound">n</a><a id="2043" class="Symbol">)</a>
    <a id="2049" href="Tactic.RingSolver.html#1980" class="Function">f</a> <a id="2051" href="Tactic.RingSolver.html#2051" class="Bound">xs</a> <a id="2054" href="Tactic.RingSolver.html#2054" class="Bound">x</a> <a id="2056" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="2064" class="Symbol">=</a> <a id="2066" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2071" href="Data.Vec.Base.html#1150" class="InductiveConstructor">[]</a>
    <a id="2078" href="Tactic.RingSolver.html#1980" class="Function">f</a> <a id="2080" href="Tactic.RingSolver.html#2080" class="Bound">xs</a> <a id="2083" href="Tactic.RingSolver.html#2083" class="Bound">x</a> <a id="2085" class="Symbol">(</a><a id="2086" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2090" href="Tactic.RingSolver.html#2090" class="Bound">n</a><a id="2091" class="Symbol">)</a> <a id="2093" class="Symbol">=</a> <a id="2095" href="Data.Maybe.Base.html#2110" class="Function">Maybe.map</a> <a id="2105" class="Symbol">(</a><a id="2106" href="Tactic.RingSolver.html#2083" class="Bound">x</a> <a id="2108" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷_</a><a id="2110" class="Symbol">)</a> <a id="2112" class="Symbol">(</a><a id="2113" href="Tactic.RingSolver.html#2080" class="Bound">xs</a> <a id="2116" href="Tactic.RingSolver.html#2090" class="Bound">n</a><a id="2117" class="Symbol">)</a>

    <a id="2124" href="Tactic.RingSolver.html#2124" class="Function">c</a> <a id="2126" class="Symbol">:</a> <a id="2128" class="Symbol">∀</a> <a id="2130" href="Tactic.RingSolver.html#2130" class="Bound">n</a> <a id="2132" class="Symbol">→</a> <a id="2134" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2140" class="Symbol">(</a><a id="2141" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="2145" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2150" href="Tactic.RingSolver.html#2130" class="Bound">n</a><a id="2151" class="Symbol">)</a>
    <a id="2157" href="Tactic.RingSolver.html#2124" class="Function">c</a> <a id="2159" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>     <a id="2168" class="Symbol">=</a> <a id="2170" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2175" href="Data.Vec.Base.html#1150" class="InductiveConstructor">[]</a>
    <a id="2182" href="Tactic.RingSolver.html#2124" class="Function">c</a> <a id="2184" class="Symbol">(</a><a id="2185" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2189" class="Symbol">_</a> <a id="2191" class="Symbol">)</a> <a id="2193" class="Symbol">=</a> <a id="2195" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
  <a id="2205" href="Tactic.RingSolver.html#1810" class="CatchallClause Function">getVisibleArgs</a><a id="2219" class="CatchallClause"> </a><a id="2220" class="CatchallClause Symbol">_</a><a id="2221" class="CatchallClause"> </a><a id="2222" class="CatchallClause Symbol">_</a> <a id="2224" class="Symbol">=</a> <a id="2226" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="curriedTerm"></a><a id="2237" href="Tactic.RingSolver.html#2237" class="Function">curriedTerm</a> <a id="2249" class="Symbol">:</a> <a id="2251" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a> <a id="2258" class="Symbol">→</a> <a id="2260" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2267" href="Tactic.RingSolver.html#2237" class="Function">curriedTerm</a> <a id="2279" class="Symbol">=</a> <a id="2281" href="Data.List.Base.html#4351" class="Function">List.foldr</a> <a id="2292" href="Tactic.RingSolver.html#2333" class="Function">go</a> <a id="2295" href="Data.Vec.Reflection.html#684" class="Function">Vec.`[]</a> <a id="2303" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2305" href="Tactic.RingSolver.Core.NatSet.html#3349" class="Function">NatSet.toList</a>
    <a id="2323" class="Keyword">where</a>
    <a id="2333" href="Tactic.RingSolver.html#2333" class="Function">go</a> <a id="2336" class="Symbol">:</a> <a id="2338" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2340" class="Symbol">→</a> <a id="2342" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2347" class="Symbol">→</a> <a id="2349" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="2358" href="Tactic.RingSolver.html#2333" class="Function">go</a> <a id="2361" href="Tactic.RingSolver.html#2361" class="Bound">x</a> <a id="2363" href="Tactic.RingSolver.html#2363" class="Bound">xs</a> <a id="2366" class="Symbol">=</a> <a id="2368" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="2372" href="Tactic.RingSolver.html#2361" class="Bound">x</a> <a id="2374" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2377" href="Data.Vec.Reflection.html#749" class="Function Operator">Vec.`∷</a> <a id="2384" href="Tactic.RingSolver.html#2363" class="Bound">xs</a>

<a id="2388" class="Comment">------------------------------------------------------------------------</a>
<a id="2461" class="Comment">-- Reflection utilities for rings</a>

<a id="`AlmostCommutativeRing"></a><a id="2496" href="Tactic.RingSolver.html#2496" class="Function">`AlmostCommutativeRing</a> <a id="2519" class="Symbol">:</a> <a id="2521" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="2526" href="Tactic.RingSolver.html#2496" class="Function">`AlmostCommutativeRing</a> <a id="2549" class="Symbol">=</a> <a id="2551" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2555" class="Symbol">(</a><a id="2556" class="Keyword">quote</a> <a id="2562" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1288" class="Record">AlmostCommutativeRing</a><a id="2583" class="Symbol">)</a> <a id="2585" class="Symbol">(</a><a id="2586" class="Number">2</a> <a id="2588" href="Reflection.AST.Term.html#2885" class="Function Operator">⋯⟨∷⟩</a> <a id="2593" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2595" class="Symbol">)</a>

<a id="2598" class="Keyword">record</a> <a id="RingOperatorTerms"></a><a id="2605" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a> <a id="2623" class="Symbol">:</a> <a id="2625" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="2629" class="Keyword">where</a>
  <a id="2637" class="Keyword">constructor</a> <a id="add⇒_mul⇒_pow⇒_neg⇒_sub⇒_"></a><a id="2649" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">add⇒_mul⇒_pow⇒_neg⇒_sub⇒_</a>
  <a id="2677" class="Keyword">field</a>
    <a id="RingOperatorTerms.add"></a><a id="2687" href="Tactic.RingSolver.html#2687" class="Field">add</a> <a id="RingOperatorTerms.mul"></a><a id="2691" href="Tactic.RingSolver.html#2691" class="Field">mul</a> <a id="RingOperatorTerms.pow"></a><a id="2695" href="Tactic.RingSolver.html#2695" class="Field">pow</a> <a id="RingOperatorTerms.neg"></a><a id="2699" href="Tactic.RingSolver.html#2699" class="Field">neg</a> <a id="RingOperatorTerms.sub"></a><a id="2703" href="Tactic.RingSolver.html#2703" class="Field">sub</a> <a id="2707" class="Symbol">:</a> <a id="2709" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>

<a id="checkIsRing"></a><a id="2715" href="Tactic.RingSolver.html#2715" class="Function">checkIsRing</a> <a id="2727" class="Symbol">:</a> <a id="2729" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2734" class="Symbol">→</a> <a id="2736" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2739" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="2744" href="Tactic.RingSolver.html#2715" class="Function">checkIsRing</a> <a id="2756" href="Tactic.RingSolver.html#2756" class="Bound">ring</a> <a id="2761" class="Symbol">=</a> <a id="2763" href="Agda.Builtin.Reflection.html#8914" class="Postulate">checkType</a> <a id="2773" href="Tactic.RingSolver.html#2756" class="Bound">ring</a> <a id="2778" href="Tactic.RingSolver.html#2496" class="Function">`AlmostCommutativeRing</a>

<a id="2802" class="Keyword">module</a> <a id="RingReflection"></a><a id="2809" href="Tactic.RingSolver.html#2809" class="Module">RingReflection</a> <a id="2824" class="Symbol">(</a><a id="2825" href="Tactic.RingSolver.html#2825" class="Bound">`ring</a> <a id="2831" class="Symbol">:</a> <a id="2833" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="2837" class="Symbol">)</a> <a id="2839" class="Keyword">where</a>

  <a id="2848" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
  <a id="2916" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
  <a id="2983" class="Comment">-- the required ring arguments</a>
  <a id="3016" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
  <a id="3064" class="Keyword">infixr</a> <a id="3071" class="Number">6</a> <a id="3073" href="Tactic.RingSolver.html#3080" class="Function Operator">_$ʳ_</a>
  <a id="RingReflection._$ʳ_"></a><a id="3080" href="Tactic.RingSolver.html#3080" class="Function Operator">_$ʳ_</a> <a id="3085" class="Symbol">:</a> <a id="3087" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="3092" class="Symbol">→</a> <a id="3094" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="3099" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3104" class="Symbol">→</a> <a id="3106" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3113" href="Tactic.RingSolver.html#3113" class="Bound">nm</a> <a id="3116" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3119" href="Tactic.RingSolver.html#3119" class="Bound">args</a> <a id="3124" class="Symbol">=</a> <a id="3126" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3130" href="Tactic.RingSolver.html#3113" class="Bound">nm</a> <a id="3133" class="Symbol">(</a><a id="3134" class="Number">2</a> <a id="3136" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="3141" href="Tactic.RingSolver.html#2825" class="Bound">`ring</a> <a id="3147" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3151" href="Tactic.RingSolver.html#3119" class="Bound">args</a><a id="3155" class="Symbol">)</a>

  <a id="RingReflection.`Carrier"></a><a id="3160" href="Tactic.RingSolver.html#3160" class="Function">`Carrier</a> <a id="3169" class="Symbol">:</a> <a id="3171" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3178" href="Tactic.RingSolver.html#3160" class="Function">`Carrier</a> <a id="3187" class="Symbol">=</a> <a id="3189" class="Keyword">quote</a> <a id="3195" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1426" class="Field">Carrier</a> <a id="3203" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3206" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

  <a id="RingReflection.`refl"></a><a id="3212" href="Tactic.RingSolver.html#3212" class="Function">`refl</a> <a id="3218" class="Symbol">:</a> <a id="3220" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3227" href="Tactic.RingSolver.html#3212" class="Function">`refl</a> <a id="3233" class="Symbol">=</a> <a id="3235" class="Keyword">quote</a> <a id="3241" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2589" class="Function">refl</a> <a id="3246" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3249" class="Symbol">(</a><a id="3250" class="Number">1</a> <a id="3252" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="3257" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3259" class="Symbol">)</a>

  <a id="RingReflection.`sym"></a><a id="3264" href="Tactic.RingSolver.html#3264" class="Function">`sym</a> <a id="3269" class="Symbol">:</a> <a id="3271" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3276" class="Symbol">→</a> <a id="3278" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3285" href="Tactic.RingSolver.html#3264" class="Function">`sym</a> <a id="3290" href="Tactic.RingSolver.html#3290" class="Bound">x≈y</a> <a id="3294" class="Symbol">=</a> <a id="3296" class="Keyword">quote</a> <a id="3302" href="Relation.Binary.Structures.html#1622" class="Function">sym</a> <a id="3306" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3309" class="Symbol">(</a><a id="3310" class="Number">2</a> <a id="3312" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="3317" href="Tactic.RingSolver.html#3290" class="Bound">x≈y</a> <a id="3321" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3325" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3327" class="Symbol">)</a>

  <a id="RingReflection.`trans"></a><a id="3332" href="Tactic.RingSolver.html#3332" class="Function">`trans</a> <a id="3339" class="Symbol">:</a> <a id="3341" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3346" class="Symbol">→</a> <a id="3348" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3353" class="Symbol">→</a> <a id="3355" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3362" href="Tactic.RingSolver.html#3332" class="Function">`trans</a> <a id="3369" href="Tactic.RingSolver.html#3369" class="Bound">x≈y</a> <a id="3373" href="Tactic.RingSolver.html#3373" class="Bound">y≈z</a> <a id="3377" class="Symbol">=</a> <a id="3379" class="Keyword">quote</a> <a id="3385" href="Relation.Binary.Structures.html#1648" class="Function">trans</a> <a id="3391" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3394" class="Symbol">(</a><a id="3395" class="Number">3</a> <a id="3397" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="3402" href="Tactic.RingSolver.html#3369" class="Bound">x≈y</a> <a id="3406" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3410" href="Tactic.RingSolver.html#3373" class="Bound">y≈z</a> <a id="3414" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3418" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3420" class="Symbol">)</a>

  <a id="3425" class="Comment">-- Normalises each of the fields of the ring operator so we can</a>
  <a id="3491" class="Comment">-- compare the result against the normalised definitions we come</a>
  <a id="3558" class="Comment">-- across when converting the term passed to the macro.</a>
  <a id="RingReflection.getRingOperatorTerms"></a><a id="3616" href="Tactic.RingSolver.html#3616" class="Function">getRingOperatorTerms</a> <a id="3637" class="Symbol">:</a> <a id="3639" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="3642" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a>
  <a id="3662" href="Tactic.RingSolver.html#3616" class="Function">getRingOperatorTerms</a> <a id="3683" class="Symbol">=</a> <a id="3685" class="Symbol">⦇</a>
    <a id="3691" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">add⇒</a> <a id="3696" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="3706" class="Symbol">(</a><a id="3707" class="Keyword">quote</a> <a id="3713" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1506" class="Field Operator">_+_</a>  <a id="3718" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3721" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3723" class="Symbol">)</a>
    <a id="3729" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">mul⇒</a> <a id="3734" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="3744" class="Symbol">(</a><a id="3745" class="Keyword">quote</a> <a id="3751" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1548" class="Field Operator">_*_</a>  <a id="3756" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3759" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3761" class="Symbol">)</a>
    <a id="3767" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">pow⇒</a> <a id="3772" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="3782" class="Symbol">(</a><a id="3783" class="Keyword">quote</a> <a id="3789" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2447" class="Function Operator">_^_</a>  <a id="3794" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3797" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3799" class="Symbol">)</a>
    <a id="3805" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">neg⇒</a> <a id="3810" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="3820" class="Symbol">(</a><a id="3821" class="Keyword">quote</a> <a id="3827" class="Symbol">(</a><a id="3828" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1590" class="Field Operator">-_</a><a id="3830" class="Symbol">)</a> <a id="3832" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3835" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3837" class="Symbol">)</a>
    <a id="3843" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">sub⇒</a> <a id="3848" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="3858" class="Symbol">(</a><a id="3859" class="Keyword">quote</a> <a id="3865" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2530" class="Function Operator">_-_</a>  <a id="3870" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3873" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3875" class="Symbol">)</a>
    <a id="3881" class="Symbol">⦈</a>

<a id="3884" class="Comment">------------------------------------------------------------------------</a>
<a id="3957" class="Comment">-- Reflection utilities for ring solver</a>

<a id="3998" class="Keyword">module</a> <a id="RingSolverReflection"></a><a id="4005" href="Tactic.RingSolver.html#4005" class="Module">RingSolverReflection</a> <a id="4026" class="Symbol">(</a><a id="4027" href="Tactic.RingSolver.html#4027" class="Bound">ring</a> <a id="4032" class="Symbol">:</a> <a id="4034" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="4038" class="Symbol">)</a> <a id="4040" class="Symbol">(</a><a id="4041" href="Tactic.RingSolver.html#4041" class="Bound">numberOfVariables</a> <a id="4059" class="Symbol">:</a> <a id="4061" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="4062" class="Symbol">)</a> <a id="4064" class="Keyword">where</a>
  <a id="4072" class="Keyword">open</a> <a id="4077" href="Tactic.RingSolver.html#2809" class="Module">RingReflection</a> <a id="4092" href="Tactic.RingSolver.html#4027" class="Bound">ring</a>

  <a id="RingSolverReflection.`numberOfVariables"></a><a id="4100" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="4119" class="Symbol">:</a> <a id="4121" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4128" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="4147" class="Symbol">=</a> <a id="4149" href="Data.Nat.Reflection.html#653" class="Function">toTerm</a> <a id="4156" href="Tactic.RingSolver.html#4041" class="Bound">numberOfVariables</a>

  <a id="4177" class="Comment">-- This function applies the hidden arguments that the constructors</a>
  <a id="4247" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
  <a id="4320" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
  <a id="4389" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
  <a id="4458" class="Comment">-- make things easier we supply the third because we know it.</a>
  <a id="4522" class="Keyword">infix</a> <a id="4528" class="Number">-1</a> <a id="4531" href="Tactic.RingSolver.html#4538" class="Function Operator">_$ᵉ_</a>
  <a id="RingSolverReflection._$ᵉ_"></a><a id="4538" href="Tactic.RingSolver.html#4538" class="Function Operator">_$ᵉ_</a> <a id="4543" class="Symbol">:</a> <a id="4545" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="4550" class="Symbol">→</a> <a id="4552" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4557" class="Symbol">(</a><a id="4558" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4562" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="4566" class="Symbol">)</a> <a id="4568" class="Symbol">→</a> <a id="4570" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4577" href="Tactic.RingSolver.html#4577" class="Bound">e</a> <a id="4579" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="4582" href="Tactic.RingSolver.html#4582" class="Bound">xs</a> <a id="4585" class="Symbol">=</a> <a id="4587" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4591" href="Tactic.RingSolver.html#4577" class="Bound">e</a> <a id="4593" class="Symbol">(</a><a id="4594" class="Number">1</a> <a id="4596" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="4601" href="Tactic.RingSolver.html#3160" class="Function">`Carrier</a> <a id="4610" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4614" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="4633" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4637" href="Tactic.RingSolver.html#4582" class="Bound">xs</a><a id="4639" class="Symbol">)</a>

  <a id="4644" class="Comment">-- A constant expression.</a>
  <a id="RingSolverReflection.`Κ"></a><a id="4672" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="4675" class="Symbol">:</a> <a id="4677" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4682" class="Symbol">→</a> <a id="4684" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4691" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="4694" href="Tactic.RingSolver.html#4694" class="Bound">x</a> <a id="4696" class="Symbol">=</a> <a id="4698" class="Keyword">quote</a> <a id="4704" href="Tactic.RingSolver.Core.Expression.html#558" class="InductiveConstructor">Κ</a> <a id="4706" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="4709" class="Symbol">(</a><a id="4710" href="Tactic.RingSolver.html#4694" class="Bound">x</a> <a id="4712" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4716" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4718" class="Symbol">)</a>

  <a id="RingSolverReflection.`I"></a><a id="4723" href="Tactic.RingSolver.html#4723" class="Function">`I</a> <a id="4726" class="Symbol">:</a> <a id="4728" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4733" class="Symbol">→</a> <a id="4735" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4742" href="Tactic.RingSolver.html#4723" class="Function">`I</a> <a id="4745" href="Tactic.RingSolver.html#4745" class="Bound">x</a> <a id="4747" class="Symbol">=</a> <a id="4749" class="Keyword">quote</a> <a id="4755" href="Tactic.RingSolver.Core.Expression.html#609" class="InductiveConstructor">Ι</a> <a id="4757" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="4760" class="Symbol">(</a><a id="4761" href="Tactic.RingSolver.html#4745" class="Bound">x</a> <a id="4763" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4767" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4769" class="Symbol">)</a>

  <a id="4774" class="Keyword">infixl</a> <a id="4781" class="Number">6</a> <a id="4783" href="Tactic.RingSolver.html#4791" class="Function Operator">_`⊜_</a>

  <a id="RingSolverReflection._`⊜_"></a><a id="4791" href="Tactic.RingSolver.html#4791" class="Function Operator">_`⊜_</a> <a id="4796" class="Symbol">:</a> <a id="4798" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4803" class="Symbol">→</a> <a id="4805" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4810" class="Symbol">→</a> <a id="4812" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4819" href="Tactic.RingSolver.html#4819" class="Bound">x</a> <a id="4821" href="Tactic.RingSolver.html#4791" class="Function Operator">`⊜</a> <a id="4824" href="Tactic.RingSolver.html#4824" class="Bound">y</a> <a id="4826" class="Symbol">=</a> <a id="4828" class="Keyword">quote</a> <a id="4834" href="Tactic.RingSolver.NonReflective.html#3387" class="Function Operator">_⊜_</a>  <a id="4839" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="4842" class="Symbol">(</a><a id="4843" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="4862" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4866" href="Tactic.RingSolver.html#4819" class="Bound">x</a> <a id="4868" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4872" href="Tactic.RingSolver.html#4824" class="Bound">y</a> <a id="4874" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4878" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4880" class="Symbol">)</a>

  <a id="RingSolverReflection.`correct"></a><a id="4885" href="Tactic.RingSolver.html#4885" class="Function">`correct</a> <a id="4894" class="Symbol">:</a> <a id="4896" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4901" class="Symbol">→</a> <a id="4903" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4908" class="Symbol">→</a> <a id="4910" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="4917" href="Tactic.RingSolver.html#4885" class="Function">`correct</a> <a id="4926" href="Tactic.RingSolver.html#4926" class="Bound">x</a> <a id="4928" href="Tactic.RingSolver.html#4928" class="Bound">ρ</a> <a id="4930" class="Symbol">=</a> <a id="4932" class="Keyword">quote</a> <a id="4938" href="Tactic.RingSolver.NonReflective.html#2361" class="Function">Ops.correct</a> <a id="4950" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="4953" class="Symbol">(</a><a id="4954" class="Number">1</a> <a id="4956" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="4961" href="Tactic.RingSolver.html#4926" class="Bound">x</a> <a id="4963" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4967" href="Tactic.RingSolver.html#4928" class="Bound">ρ</a> <a id="4969" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4973" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4975" class="Symbol">)</a>

  <a id="RingSolverReflection.`solver"></a><a id="4980" href="Tactic.RingSolver.html#4980" class="Function">`solver</a> <a id="4988" class="Symbol">:</a> <a id="4990" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4995" class="Symbol">→</a> <a id="4997" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5002" class="Symbol">→</a> <a id="5004" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5011" href="Tactic.RingSolver.html#4980" class="Function">`solver</a> <a id="5019" href="Tactic.RingSolver.html#5019" class="Bound">`f</a> <a id="5022" href="Tactic.RingSolver.html#5022" class="Bound">`eq</a> <a id="5026" class="Symbol">=</a> <a id="5028" class="Keyword">quote</a> <a id="5034" href="Tactic.RingSolver.html#1384" class="Function">solver</a> <a id="5041" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="5044" class="Symbol">(</a><a id="5045" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="5064" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5068" href="Tactic.RingSolver.html#5019" class="Bound">`f</a> <a id="5071" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5075" href="Tactic.RingSolver.html#5022" class="Bound">`eq</a> <a id="5079" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5083" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="5085" class="Symbol">)</a>

  <a id="5090" class="Comment">-- Converts the raw terms provided by the macro into the `Expr`s</a>
  <a id="5157" class="Comment">-- used internally by the solver.</a>
  <a id="5193" class="Comment">--</a>
  <a id="5198" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
  <a id="5264" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
  <a id="5327" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
  <a id="5393" class="Comment">-- might look for its constructors: however, we want to deal with</a>
  <a id="5461" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
  <a id="5528" class="Comment">-- Term type contained type information we might be able to</a>
  <a id="5590" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
  <a id="5631" class="Comment">--</a>
  <a id="5636" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
  <a id="5705" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
  <a id="5773" class="Comment">-- will just assume that it has a constant expression.</a>
  <a id="RingSolverReflection.convertTerm"></a><a id="5830" href="Tactic.RingSolver.html#5830" class="Function">convertTerm</a> <a id="5842" class="Symbol">:</a> <a id="5844" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a> <a id="5862" class="Symbol">→</a> <a id="5864" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a> <a id="5871" class="Symbol">→</a> <a id="5873" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5878" class="Symbol">→</a> <a id="5880" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="5883" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5890" href="Tactic.RingSolver.html#5830" class="Function">convertTerm</a> <a id="5902" href="Tactic.RingSolver.html#5902" class="Bound">operatorTerms</a> <a id="5916" href="Tactic.RingSolver.html#5916" class="Bound">varMap</a> <a id="5923" class="Symbol">=</a> <a id="5925" href="Tactic.RingSolver.html#6002" class="Function">convert</a>
    <a id="5937" class="Keyword">where</a>
    <a id="5947" class="Keyword">open</a> <a id="5952" href="Tactic.RingSolver.html#2605" class="Module">RingOperatorTerms</a> <a id="5970" href="Tactic.RingSolver.html#5902" class="Bound">operatorTerms</a>

    <a id="5989" class="Keyword">mutual</a>
      <a id="6002" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6010" class="Symbol">:</a> <a id="6012" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6017" class="Symbol">→</a> <a id="6019" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="6022" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="6033" class="Comment">-- First try and match directly against the fields</a>
      <a id="6090" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6098" class="Symbol">(</a><a id="6099" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6103" class="Symbol">(</a><a id="6104" class="Keyword">quote</a> <a id="6110" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1506" class="Field Operator">_+_</a><a id="6113" class="Symbol">)</a> <a id="6115" href="Tactic.RingSolver.html#6115" class="Bound">xs</a><a id="6117" class="Symbol">)</a> <a id="6119" class="Symbol">=</a> <a id="6121" href="Tactic.RingSolver.html#7089" class="Function">convertOp₂</a> <a id="6132" class="Symbol">(</a><a id="6133" class="Keyword">quote</a> <a id="6139" href="Tactic.RingSolver.Core.Expression.html#660" class="InductiveConstructor Operator">_⊕_</a><a id="6142" class="Symbol">)</a> <a id="6144" href="Tactic.RingSolver.html#6115" class="Bound">xs</a>
      <a id="6153" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6161" class="Symbol">(</a><a id="6162" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6166" class="Symbol">(</a><a id="6167" class="Keyword">quote</a> <a id="6173" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1548" class="Field Operator">_*_</a><a id="6176" class="Symbol">)</a> <a id="6178" href="Tactic.RingSolver.html#6178" class="Bound">xs</a><a id="6180" class="Symbol">)</a> <a id="6182" class="Symbol">=</a> <a id="6184" href="Tactic.RingSolver.html#7089" class="Function">convertOp₂</a> <a id="6195" class="Symbol">(</a><a id="6196" class="Keyword">quote</a> <a id="6202" href="Tactic.RingSolver.Core.Expression.html#711" class="InductiveConstructor Operator">_⊗_</a><a id="6205" class="Symbol">)</a> <a id="6207" href="Tactic.RingSolver.html#6178" class="Bound">xs</a>
      <a id="6216" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6224" class="Symbol">(</a><a id="6225" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6229" class="Symbol">(</a><a id="6230" class="Keyword">quote</a>  <a id="6237" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1590" class="Field Operator">-_</a><a id="6239" class="Symbol">)</a> <a id="6241" href="Tactic.RingSolver.html#6241" class="Bound">xs</a><a id="6243" class="Symbol">)</a> <a id="6245" class="Symbol">=</a> <a id="6247" href="Tactic.RingSolver.html#7372" class="Function">convertOp₁</a> <a id="6258" class="Symbol">(</a><a id="6259" class="Keyword">quote</a>  <a id="6266" href="Tactic.RingSolver.Core.Expression.html#825" class="InductiveConstructor Operator">⊝_</a><a id="6268" class="Symbol">)</a> <a id="6270" href="Tactic.RingSolver.html#6241" class="Bound">xs</a>
      <a id="6279" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6287" class="Symbol">(</a><a id="6288" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6292" class="Symbol">(</a><a id="6293" class="Keyword">quote</a> <a id="6299" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2447" class="Function Operator">_^_</a><a id="6302" class="Symbol">)</a> <a id="6304" href="Tactic.RingSolver.html#6304" class="Bound">xs</a><a id="6306" class="Symbol">)</a> <a id="6308" class="Symbol">=</a> <a id="6310" href="Tactic.RingSolver.html#7607" class="Function">convertExp</a> <a id="6321" href="Tactic.RingSolver.html#6304" class="Bound">xs</a>
      <a id="6330" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6338" class="Symbol">(</a><a id="6339" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6343" class="Symbol">(</a><a id="6344" class="Keyword">quote</a> <a id="6350" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2530" class="Function Operator">_-_</a><a id="6353" class="Symbol">)</a> <a id="6355" href="Tactic.RingSolver.html#6355" class="Bound">xs</a><a id="6357" class="Symbol">)</a> <a id="6359" class="Symbol">=</a> <a id="6361" href="Tactic.RingSolver.html#7854" class="Function">convertSub</a> <a id="6372" href="Tactic.RingSolver.html#6355" class="Bound">xs</a>
      <a id="6381" class="Comment">-- Other definitions the underlying implementation of the ring&#39;s fields</a>
      <a id="6459" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6467" class="Symbol">(</a><a id="6468" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6472" href="Tactic.RingSolver.html#6472" class="Bound">nm</a>          <a id="6484" href="Tactic.RingSolver.html#6484" class="Bound">xs</a><a id="6486" class="Symbol">)</a> <a id="6488" class="Symbol">=</a> <a id="6490" href="Tactic.RingSolver.html#8151" class="Function">convertUnknownName</a> <a id="6509" href="Tactic.RingSolver.html#6472" class="Bound">nm</a> <a id="6512" href="Tactic.RingSolver.html#6484" class="Bound">xs</a>
      <a id="6521" class="Comment">-- Variables</a>
      <a id="6540" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6548" href="Tactic.RingSolver.html#6548" class="Bound">v</a><a id="6549" class="Symbol">@(</a><a id="6551" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="6555" href="Tactic.RingSolver.html#6555" class="Bound">x</a> <a id="6557" class="Symbol">_)</a>          <a id="6569" class="Symbol">=</a> <a id="6571" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="6576" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6578" href="Data.Maybe.Base.html#1722" class="Function">fromMaybe</a> <a id="6588" class="Symbol">(</a><a id="6589" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="6592" href="Tactic.RingSolver.html#6548" class="Bound">v</a><a id="6593" class="Symbol">)</a> <a id="6595" class="Symbol">(</a><a id="6596" href="Tactic.RingSolver.html#5916" class="Bound">varMap</a> <a id="6603" href="Tactic.RingSolver.html#6555" class="Bound">x</a><a id="6604" class="Symbol">)</a>
      <a id="6612" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
      <a id="6666" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="6674" class="Symbol">(</a><a id="6675" href="Data.Nat.Reflection.html#616" class="InductiveConstructor">`suc</a> <a id="6680" href="Tactic.RingSolver.html#6680" class="Bound">x</a><a id="6681" class="Symbol">)</a>             <a id="6695" class="Symbol">=</a> <a id="6697" href="Tactic.RingSolver.html#8672" class="Function">convertSuc</a> <a id="6708" href="Tactic.RingSolver.html#6680" class="Bound">x</a>
      <a id="6716" class="Comment">-- Otherwise we&#39;re forced to treat it as a constant</a>
      <a id="6774" href="Tactic.RingSolver.html#6002" class="CatchallClause Function">convert</a><a id="6781" class="CatchallClause"> </a><a id="6782" href="Tactic.RingSolver.html#6782" class="CatchallClause Bound">t</a>                    <a id="6803" class="Symbol">=</a> <a id="6805" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="6810" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6812" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="6815" href="Tactic.RingSolver.html#6782" class="Bound">t</a>

      <a id="6824" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
      <a id="6893" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
      <a id="6963" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
      <a id="7032" class="Comment">-- by just taking the last two explicit arguments.</a>
      <a id="7089" href="Tactic.RingSolver.html#7089" class="Function">convertOp₂</a> <a id="7100" class="Symbol">:</a> <a id="7102" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="7107" class="Symbol">→</a> <a id="7109" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7114" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7119" class="Symbol">→</a> <a id="7121" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7124" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="7135" href="Tactic.RingSolver.html#7089" class="Function">convertOp₂</a> <a id="7146" href="Tactic.RingSolver.html#7146" class="Bound">nm</a> <a id="7149" class="Symbol">(</a><a id="7150" href="Tactic.RingSolver.html#7150" class="Bound">x</a> <a id="7152" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7156" href="Tactic.RingSolver.html#7156" class="Bound">y</a> <a id="7158" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7162" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7164" class="Symbol">)</a> <a id="7166" class="Symbol">=</a> <a id="7168" class="Keyword">do</a>
        <a id="7179" href="Tactic.RingSolver.html#7179" class="Bound">x&#39;</a> <a id="7182" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7184" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="7192" href="Tactic.RingSolver.html#7150" class="Bound">x</a>
        <a id="7202" href="Tactic.RingSolver.html#7202" class="Bound">y&#39;</a> <a id="7205" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7207" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="7215" href="Tactic.RingSolver.html#7156" class="Bound">y</a>
        <a id="7225" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7230" class="Symbol">(</a><a id="7231" href="Tactic.RingSolver.html#7146" class="Bound">nm</a> <a id="7234" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="7237" class="Symbol">(</a><a id="7238" href="Tactic.RingSolver.html#7179" class="Bound">x&#39;</a> <a id="7241" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7245" href="Tactic.RingSolver.html#7202" class="Bound">y&#39;</a> <a id="7248" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7252" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7254" class="Symbol">))</a>
      <a id="7263" href="Tactic.RingSolver.html#7089" class="CatchallClause Function">convertOp₂</a><a id="7273" class="CatchallClause"> </a><a id="7274" href="Tactic.RingSolver.html#7274" class="CatchallClause Bound">nm</a><a id="7276" class="CatchallClause"> </a><a id="7277" class="CatchallClause Symbol">(</a><a id="7278" href="Tactic.RingSolver.html#7278" class="CatchallClause Bound">x</a><a id="7279" class="CatchallClause"> </a><a id="7280" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7281" class="CatchallClause"> </a><a id="7282" href="Tactic.RingSolver.html#7282" class="CatchallClause Bound">xs</a><a id="7284" class="CatchallClause Symbol">)</a>         <a id="7294" class="Symbol">=</a> <a id="7296" href="Tactic.RingSolver.html#7089" class="Function">convertOp₂</a> <a id="7307" href="Tactic.RingSolver.html#7274" class="Bound">nm</a> <a id="7310" href="Tactic.RingSolver.html#7282" class="Bound">xs</a>
      <a id="7319" href="Tactic.RingSolver.html#7089" class="CatchallClause Function">convertOp₂</a><a id="7329" class="CatchallClause"> </a><a id="7330" class="CatchallClause Symbol">_</a><a id="7331" class="CatchallClause">  </a><a id="7333" class="CatchallClause Symbol">_</a>                <a id="7350" class="Symbol">=</a> <a id="7352" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7357" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

      <a id="7372" href="Tactic.RingSolver.html#7372" class="Function">convertOp₁</a> <a id="7383" class="Symbol">:</a> <a id="7385" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="7390" class="Symbol">→</a> <a id="7392" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7397" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7402" class="Symbol">→</a> <a id="7404" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7407" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="7418" href="Tactic.RingSolver.html#7372" class="Function">convertOp₁</a> <a id="7429" href="Tactic.RingSolver.html#7429" class="Bound">nm</a> <a id="7432" class="Symbol">(</a><a id="7433" href="Tactic.RingSolver.html#7433" class="Bound">x</a> <a id="7435" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7439" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7441" class="Symbol">)</a> <a id="7443" class="Symbol">=</a> <a id="7445" class="Keyword">do</a>
        <a id="7456" href="Tactic.RingSolver.html#7456" class="Bound">x&#39;</a> <a id="7459" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7461" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="7469" href="Tactic.RingSolver.html#7433" class="Bound">x</a>
        <a id="7479" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7484" class="Symbol">(</a><a id="7485" href="Tactic.RingSolver.html#7429" class="Bound">nm</a> <a id="7488" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="7491" class="Symbol">(</a><a id="7492" href="Tactic.RingSolver.html#7456" class="Bound">x&#39;</a> <a id="7495" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7499" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7501" class="Symbol">))</a>
      <a id="7510" href="Tactic.RingSolver.html#7372" class="CatchallClause Function">convertOp₁</a><a id="7520" class="CatchallClause"> </a><a id="7521" href="Tactic.RingSolver.html#7521" class="CatchallClause Bound">nm</a><a id="7523" class="CatchallClause"> </a><a id="7524" class="CatchallClause Symbol">(</a><a id="7525" href="Tactic.RingSolver.html#7525" class="CatchallClause Bound">x</a><a id="7526" class="CatchallClause"> </a><a id="7527" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7528" class="CatchallClause"> </a><a id="7529" href="Tactic.RingSolver.html#7529" class="CatchallClause Bound">xs</a><a id="7531" class="CatchallClause Symbol">)</a>   <a id="7535" class="Symbol">=</a> <a id="7537" href="Tactic.RingSolver.html#7372" class="Function">convertOp₁</a> <a id="7548" href="Tactic.RingSolver.html#7521" class="Bound">nm</a> <a id="7551" href="Tactic.RingSolver.html#7529" class="Bound">xs</a>
      <a id="7560" href="Tactic.RingSolver.html#7372" class="CatchallClause Function">convertOp₁</a><a id="7570" class="CatchallClause"> </a><a id="7571" class="CatchallClause Symbol">_</a><a id="7572" class="CatchallClause">  </a><a id="7574" class="CatchallClause Symbol">_</a>          <a id="7585" class="Symbol">=</a> <a id="7587" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7592" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

      <a id="7607" href="Tactic.RingSolver.html#7607" class="Function">convertExp</a> <a id="7618" class="Symbol">:</a> <a id="7620" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7625" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7630" class="Symbol">→</a> <a id="7632" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7635" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="7646" href="Tactic.RingSolver.html#7607" class="Function">convertExp</a> <a id="7657" class="Symbol">(</a><a id="7658" href="Tactic.RingSolver.html#7658" class="Bound">x</a> <a id="7660" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7664" href="Tactic.RingSolver.html#7664" class="Bound">y</a> <a id="7666" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7670" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7672" class="Symbol">)</a> <a id="7674" class="Symbol">=</a> <a id="7676" class="Keyword">do</a>
        <a id="7687" href="Tactic.RingSolver.html#7687" class="Bound">x&#39;</a> <a id="7690" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7692" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="7700" href="Tactic.RingSolver.html#7658" class="Bound">x</a>
        <a id="7710" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7715" class="Symbol">(</a><a id="7716" class="Keyword">quote</a> <a id="7722" href="Tactic.RingSolver.Core.Expression.html#768" class="InductiveConstructor Operator">_⊛_</a> <a id="7726" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="7729" class="Symbol">(</a><a id="7730" href="Tactic.RingSolver.html#7687" class="Bound">x&#39;</a> <a id="7733" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7737" href="Tactic.RingSolver.html#7664" class="Bound">y</a> <a id="7739" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7743" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7745" class="Symbol">))</a>
      <a id="7754" href="Tactic.RingSolver.html#7607" class="CatchallClause Function">convertExp</a><a id="7764" class="CatchallClause"> </a><a id="7765" class="CatchallClause Symbol">(</a><a id="7766" href="Tactic.RingSolver.html#7766" class="CatchallClause Bound">x</a><a id="7767" class="CatchallClause"> </a><a id="7768" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7769" class="CatchallClause"> </a><a id="7770" href="Tactic.RingSolver.html#7770" class="CatchallClause Bound">xs</a><a id="7772" class="CatchallClause Symbol">)</a>         <a id="7782" class="Symbol">=</a> <a id="7784" href="Tactic.RingSolver.html#7607" class="Function">convertExp</a> <a id="7795" href="Tactic.RingSolver.html#7770" class="Bound">xs</a>
      <a id="7804" href="Tactic.RingSolver.html#7607" class="CatchallClause Function">convertExp</a><a id="7814" class="CatchallClause"> </a><a id="7815" class="CatchallClause Symbol">_</a>                <a id="7832" class="Symbol">=</a> <a id="7834" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7839" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

      <a id="7854" href="Tactic.RingSolver.html#7854" class="Function">convertSub</a> <a id="7865" class="Symbol">:</a> <a id="7867" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7872" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7877" class="Symbol">→</a> <a id="7879" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7882" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="7893" href="Tactic.RingSolver.html#7854" class="Function">convertSub</a> <a id="7904" class="Symbol">(</a><a id="7905" href="Tactic.RingSolver.html#7905" class="Bound">x</a> <a id="7907" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7911" href="Tactic.RingSolver.html#7911" class="Bound">y</a> <a id="7913" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7917" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7919" class="Symbol">)</a> <a id="7921" class="Symbol">=</a> <a id="7923" class="Keyword">do</a>
        <a id="7934" href="Tactic.RingSolver.html#7934" class="Bound">x&#39;</a>  <a id="7938" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7940" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="7948" href="Tactic.RingSolver.html#7905" class="Bound">x</a>
        <a id="7958" href="Tactic.RingSolver.html#7958" class="Bound">-y&#39;</a> <a id="7962" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7964" href="Tactic.RingSolver.html#7372" class="Function">convertOp₁</a> <a id="7975" class="Symbol">(</a><a id="7976" class="Keyword">quote</a> <a id="7982" class="Symbol">(</a><a id="7983" href="Tactic.RingSolver.Core.Expression.html#825" class="InductiveConstructor Operator">⊝_</a><a id="7985" class="Symbol">))</a> <a id="7988" class="Symbol">(</a><a id="7989" href="Tactic.RingSolver.html#7911" class="Bound">y</a> <a id="7991" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7995" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7997" class="Symbol">)</a>
        <a id="8007" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="8012" class="Symbol">(</a><a id="8013" class="Keyword">quote</a> <a id="8019" href="Tactic.RingSolver.Core.Expression.html#660" class="InductiveConstructor Operator">_⊕_</a> <a id="8023" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="8026" href="Tactic.RingSolver.html#7934" class="Bound">x&#39;</a> <a id="8029" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8033" href="Tactic.RingSolver.html#7958" class="Bound">-y&#39;</a> <a id="8037" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8041" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8043" class="Symbol">)</a>
      <a id="8051" href="Tactic.RingSolver.html#7854" class="CatchallClause Function">convertSub</a><a id="8061" class="CatchallClause"> </a><a id="8062" class="CatchallClause Symbol">(</a><a id="8063" href="Tactic.RingSolver.html#8063" class="CatchallClause Bound">x</a><a id="8064" class="CatchallClause"> </a><a id="8065" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8066" class="CatchallClause"> </a><a id="8067" href="Tactic.RingSolver.html#8067" class="CatchallClause Bound">xs</a><a id="8069" class="CatchallClause Symbol">)</a>         <a id="8079" class="Symbol">=</a> <a id="8081" href="Tactic.RingSolver.html#7854" class="Function">convertSub</a> <a id="8092" href="Tactic.RingSolver.html#8067" class="Bound">xs</a>
      <a id="8101" href="Tactic.RingSolver.html#7854" class="CatchallClause Function">convertSub</a><a id="8111" class="CatchallClause"> </a><a id="8112" class="CatchallClause Symbol">_</a>                <a id="8129" class="Symbol">=</a> <a id="8131" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="8136" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

      <a id="8151" href="Tactic.RingSolver.html#8151" class="Function">convertUnknownName</a> <a id="8170" class="Symbol">:</a> <a id="8172" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="8177" class="Symbol">→</a> <a id="8179" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="8184" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8189" class="Symbol">→</a> <a id="8191" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="8194" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="8205" href="Tactic.RingSolver.html#8151" class="Function">convertUnknownName</a> <a id="8224" href="Tactic.RingSolver.html#8224" class="Bound">nm</a> <a id="8227" href="Tactic.RingSolver.html#8227" class="Bound">xs</a> <a id="8230" class="Symbol">=</a> <a id="8232" class="Keyword">do</a>
        <a id="8243" href="Tactic.RingSolver.html#8243" class="Bound">nameTerm</a> <a id="8252" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="8254" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="8264" class="Symbol">(</a><a id="8265" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8269" href="Tactic.RingSolver.html#8224" class="Bound">nm</a> <a id="8272" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8274" class="Symbol">)</a>
        <a id="8284" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8287" class="Symbol">(</a><a id="8288" href="Tactic.RingSolver.html#8243" class="Bound">nameTerm</a> <a id="8297" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8301" href="Tactic.RingSolver.html#2687" class="Function">add</a><a id="8304" class="Symbol">)</a> <a id="8306" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8311" href="Tactic.RingSolver.html#7089" class="Function">convertOp₂</a> <a id="8322" class="Symbol">(</a><a id="8323" class="Keyword">quote</a> <a id="8329" href="Tactic.RingSolver.Core.Expression.html#660" class="InductiveConstructor Operator">_⊕_</a><a id="8332" class="Symbol">)</a> <a id="8334" href="Tactic.RingSolver.html#8227" class="Bound">xs</a> <a id="8337" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
          <a id="8352" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8355" class="Symbol">(</a><a id="8356" href="Tactic.RingSolver.html#8243" class="Bound">nameTerm</a> <a id="8365" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8369" href="Tactic.RingSolver.html#2691" class="Function">mul</a><a id="8372" class="Symbol">)</a> <a id="8374" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8379" href="Tactic.RingSolver.html#7089" class="Function">convertOp₂</a> <a id="8390" class="Symbol">(</a><a id="8391" class="Keyword">quote</a> <a id="8397" href="Tactic.RingSolver.Core.Expression.html#711" class="InductiveConstructor Operator">_⊗_</a><a id="8400" class="Symbol">)</a> <a id="8402" href="Tactic.RingSolver.html#8227" class="Bound">xs</a> <a id="8405" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
            <a id="8422" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8425" class="Symbol">(</a><a id="8426" href="Tactic.RingSolver.html#8243" class="Bound">nameTerm</a> <a id="8435" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8439" href="Tactic.RingSolver.html#2699" class="Function">neg</a><a id="8442" class="Symbol">)</a> <a id="8444" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8449" href="Tactic.RingSolver.html#7372" class="Function">convertOp₁</a> <a id="8460" class="Symbol">(</a><a id="8461" class="Keyword">quote</a> <a id="8467" href="Tactic.RingSolver.Core.Expression.html#825" class="InductiveConstructor Operator">⊝_</a><a id="8469" class="Symbol">)</a>  <a id="8472" href="Tactic.RingSolver.html#8227" class="Bound">xs</a> <a id="8475" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
              <a id="8494" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8497" class="Symbol">(</a><a id="8498" href="Tactic.RingSolver.html#8243" class="Bound">nameTerm</a> <a id="8507" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8511" href="Tactic.RingSolver.html#2695" class="Function">pow</a><a id="8514" class="Symbol">)</a> <a id="8516" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8521" href="Tactic.RingSolver.html#7607" class="Function">convertExp</a>             <a id="8544" href="Tactic.RingSolver.html#8227" class="Bound">xs</a> <a id="8547" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
                <a id="8568" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8571" class="Symbol">(</a><a id="8572" href="Tactic.RingSolver.html#8243" class="Bound">nameTerm</a> <a id="8581" href="Reflection.AST.AlphaEquality.html#1421" class="Field Operator">=α=</a> <a id="8585" href="Tactic.RingSolver.html#2703" class="Function">sub</a><a id="8588" class="Symbol">)</a> <a id="8590" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8595" href="Tactic.RingSolver.html#7854" class="Function">convertSub</a>            <a id="8617" href="Tactic.RingSolver.html#8227" class="Bound">xs</a> <a id="8620" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
                  <a id="8643" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="8648" class="Symbol">(</a><a id="8649" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="8652" class="Symbol">(</a><a id="8653" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8657" href="Tactic.RingSolver.html#8224" class="Bound">nm</a> <a id="8660" href="Tactic.RingSolver.html#8227" class="Bound">xs</a><a id="8662" class="Symbol">))</a>

      <a id="8672" href="Tactic.RingSolver.html#8672" class="Function">convertSuc</a> <a id="8683" class="Symbol">:</a> <a id="8685" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8690" class="Symbol">→</a> <a id="8692" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="8695" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="8706" href="Tactic.RingSolver.html#8672" class="Function">convertSuc</a> <a id="8717" href="Tactic.RingSolver.html#8717" class="Bound">x</a> <a id="8719" class="Symbol">=</a> <a id="8721" class="Keyword">do</a> <a id="8724" href="Tactic.RingSolver.html#8724" class="Bound">x&#39;</a> <a id="8727" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="8729" href="Tactic.RingSolver.html#6002" class="Function">convert</a> <a id="8737" href="Tactic.RingSolver.html#8717" class="Bound">x</a><a id="8738" class="Symbol">;</a> <a id="8740" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="8745" class="Symbol">(</a><a id="8746" class="Keyword">quote</a> <a id="8752" href="Tactic.RingSolver.Core.Expression.html#660" class="InductiveConstructor Operator">_⊕_</a> <a id="8756" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="8759" class="Symbol">(</a><a id="8760" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="8763" class="Symbol">(</a><a id="8764" href="Data.Nat.Reflection.html#653" class="Function">toTerm</a> <a id="8771" class="Number">1</a><a id="8772" class="Symbol">)</a> <a id="8774" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8778" href="Tactic.RingSolver.html#8724" class="Bound">x&#39;</a> <a id="8781" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8785" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8787" class="Symbol">))</a>

<a id="8791" class="Comment">------------------------------------------------------------------------</a>
<a id="8864" class="Comment">-- Macros</a>
<a id="8874" class="Comment">------------------------------------------------------------------------</a>
<a id="8947" class="Comment">-- Quantified macro</a>

<a id="8968" class="Keyword">open</a> <a id="8973" href="Tactic.RingSolver.html#2809" class="Module">RingReflection</a>
<a id="8988" class="Keyword">open</a> <a id="8993" href="Tactic.RingSolver.html#4005" class="Module">RingSolverReflection</a>

<a id="malformedForallTypeError"></a><a id="9015" href="Tactic.RingSolver.html#9015" class="Function">malformedForallTypeError</a> <a id="9040" class="Symbol">:</a> <a id="9042" class="Symbol">∀</a> <a id="9044" class="Symbol">{</a><a id="9045" href="Tactic.RingSolver.html#9045" class="Bound">a</a><a id="9046" class="Symbol">}</a> <a id="9048" class="Symbol">{</a><a id="9049" href="Tactic.RingSolver.html#9049" class="Bound">A</a> <a id="9051" class="Symbol">:</a> <a id="9053" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="9057" href="Tactic.RingSolver.html#9045" class="Bound">a</a><a id="9058" class="Symbol">}</a> <a id="9060" class="Symbol">→</a> <a id="9062" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9067" class="Symbol">→</a> <a id="9069" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="9072" href="Tactic.RingSolver.html#9049" class="Bound">A</a>
<a id="9074" href="Tactic.RingSolver.html#9015" class="Function">malformedForallTypeError</a> <a id="9099" href="Tactic.RingSolver.html#9099" class="Bound">found</a> <a id="9105" class="Symbol">=</a> <a id="9107" href="Agda.Builtin.Reflection.html#8815" class="Postulate">typeError</a>
  <a id="9119" class="Symbol">(</a> <a id="9121" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="9128" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="9157" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9159" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="9166" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a>
  <a id="9226" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9228" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="9235" class="String">&quot;Instead: &quot;</a>
  <a id="9249" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9251" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="9259" href="Tactic.RingSolver.html#9099" class="Bound">found</a>
  <a id="9267" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9269" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9271" class="Symbol">)</a>

<a id="quantifiedVarMap"></a><a id="9274" href="Tactic.RingSolver.html#9274" class="Function">quantifiedVarMap</a> <a id="9291" class="Symbol">:</a> <a id="9293" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="9295" class="Symbol">→</a> <a id="9297" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a>
<a id="9304" href="Tactic.RingSolver.html#9274" class="Function">quantifiedVarMap</a> <a id="9321" href="Tactic.RingSolver.html#9321" class="Bound">numVars</a> <a id="9329" href="Tactic.RingSolver.html#9329" class="Bound">i</a> <a id="9331" class="Symbol">=</a>
  <a id="9335" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="9338" href="Tactic.RingSolver.html#9329" class="Bound">i</a> <a id="9340" href="Data.Nat.Base.html#1457" class="Primitive Operator">&lt;ᵇ</a> <a id="9343" href="Tactic.RingSolver.html#9321" class="Bound">numVars</a>
    <a id="9355" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="9360" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="9365" class="Symbol">(</a><a id="9366" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="9370" href="Tactic.RingSolver.html#9329" class="Bound">i</a> <a id="9372" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9374" class="Symbol">)</a>
    <a id="9380" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="9385" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

<a id="constructCallToSolver"></a><a id="9394" href="Tactic.RingSolver.html#9394" class="Function">constructCallToSolver</a> <a id="9416" class="Symbol">:</a> <a id="9418" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9423" class="Symbol">→</a> <a id="9425" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a> <a id="9443" class="Symbol">→</a> <a id="9445" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="9450" href="Agda.Builtin.String.html#335" class="Postulate">String</a> <a id="9457" class="Symbol">→</a> <a id="9459" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9464" class="Symbol">→</a> <a id="9466" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9471" class="Symbol">→</a> <a id="9473" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="9476" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="9481" href="Tactic.RingSolver.html#9394" class="Function">constructCallToSolver</a> <a id="9503" href="Tactic.RingSolver.html#9503" class="Bound">`ring</a> <a id="9509" href="Tactic.RingSolver.html#9509" class="Bound">opNames</a> <a id="9517" href="Tactic.RingSolver.html#9517" class="Bound">variables</a> <a id="9527" href="Tactic.RingSolver.html#9527" class="Bound">`lhs</a> <a id="9532" href="Tactic.RingSolver.html#9532" class="Bound">`rhs</a> <a id="9537" class="Symbol">=</a> <a id="9539" class="Keyword">do</a>
  <a id="9544" href="Tactic.RingSolver.html#9544" class="Bound">`lhsExpr</a> <a id="9553" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9555" href="Tactic.RingSolver.html#9822" class="Function">conv</a> <a id="9560" href="Tactic.RingSolver.html#9527" class="Bound">`lhs</a>
  <a id="9567" href="Tactic.RingSolver.html#9567" class="Bound">`rhsExpr</a> <a id="9576" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9578" href="Tactic.RingSolver.html#9822" class="Function">conv</a> <a id="9583" href="Tactic.RingSolver.html#9532" class="Bound">`rhs</a>

  <a id="9591" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="9596" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="9598" href="Tactic.RingSolver.html#4980" class="Function">`solver</a> <a id="9606" href="Tactic.RingSolver.html#9503" class="Bound">`ring</a> <a id="9612" href="Tactic.RingSolver.html#9773" class="Function">numVars</a>
                    <a id="9640" class="Symbol">(</a><a id="9641" href="Reflection.AST.Term.html#3860" class="Function">prependVLams</a> <a id="9654" href="Tactic.RingSolver.html#9517" class="Bound">variables</a> <a id="9664" class="Symbol">(</a><a id="9665" href="Tactic.RingSolver.html#4791" class="Function Operator">_`⊜_</a> <a id="9670" href="Tactic.RingSolver.html#9503" class="Bound">`ring</a> <a id="9676" href="Tactic.RingSolver.html#9773" class="Function">numVars</a> <a id="9684" href="Tactic.RingSolver.html#9544" class="Bound">`lhsExpr</a> <a id="9693" href="Tactic.RingSolver.html#9567" class="Bound">`rhsExpr</a><a id="9701" class="Symbol">))</a>
                    <a id="9724" class="Symbol">(</a><a id="9725" href="Reflection.AST.Term.html#3762" class="Function">prependHLams</a> <a id="9738" href="Tactic.RingSolver.html#9517" class="Bound">variables</a> <a id="9748" class="Symbol">(</a><a id="9749" href="Tactic.RingSolver.html#3212" class="Function">`refl</a> <a id="9755" href="Tactic.RingSolver.html#9503" class="Bound">`ring</a><a id="9760" class="Symbol">))</a>
  <a id="9765" class="Keyword">where</a>
  <a id="9773" href="Tactic.RingSolver.html#9773" class="Function">numVars</a> <a id="9781" class="Symbol">:</a> <a id="9783" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="9787" href="Tactic.RingSolver.html#9773" class="Function">numVars</a> <a id="9795" class="Symbol">=</a> <a id="9797" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="9809" href="Tactic.RingSolver.html#9517" class="Bound">variables</a>

  <a id="9822" href="Tactic.RingSolver.html#9822" class="Function">conv</a> <a id="9827" class="Symbol">:</a> <a id="9829" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9834" class="Symbol">→</a> <a id="9836" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="9839" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="9846" href="Tactic.RingSolver.html#9822" class="Function">conv</a> <a id="9851" class="Symbol">=</a> <a id="9853" href="Tactic.RingSolver.html#5830" class="Function">convertTerm</a> <a id="9865" href="Tactic.RingSolver.html#9503" class="Bound">`ring</a> <a id="9871" href="Tactic.RingSolver.html#9773" class="Function">numVars</a> <a id="9879" href="Tactic.RingSolver.html#9509" class="Bound">opNames</a> <a id="9887" class="Symbol">(</a><a id="9888" href="Tactic.RingSolver.html#9274" class="Function">quantifiedVarMap</a> <a id="9905" href="Tactic.RingSolver.html#9773" class="Function">numVars</a><a id="9912" class="Symbol">)</a>

<a id="9915" class="Comment">-- This is the main macro which solves for equations in which the</a>
<a id="9981" class="Comment">-- variables are universally quantified over:</a>
<a id="10027" class="Comment">--</a>
<a id="10030" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="10065" class="Comment">--   lemma = solve-∀ ring</a>
<a id="10091" class="Comment">--</a>
<a id="10094" class="Comment">-- where ring is your implementation of AlmostCommutativeRing.</a>
<a id="10157" class="Comment">-- (Find some example implementations in</a>
<a id="10198" class="Comment">-- Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>
<a id="solve-∀-macro"></a><a id="10258" href="Tactic.RingSolver.html#10258" class="Function">solve-∀-macro</a> <a id="10272" class="Symbol">:</a> <a id="10274" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="10279" class="Symbol">→</a> <a id="10281" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="10286" class="Symbol">→</a> <a id="10288" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="10291" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="10293" href="Tactic.RingSolver.html#10258" class="Function">solve-∀-macro</a> <a id="10307" href="Tactic.RingSolver.html#10307" class="Bound">ring</a> <a id="10312" href="Tactic.RingSolver.html#10312" class="Bound">hole</a> <a id="10317" class="Symbol">=</a> <a id="10319" class="Keyword">do</a>
  <a id="10324" href="Tactic.RingSolver.html#10324" class="Bound">`ring</a> <a id="10330" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10332" href="Tactic.RingSolver.html#2715" class="Function">checkIsRing</a> <a id="10344" class="Symbol">(</a><a id="10345" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="10349" href="Tactic.RingSolver.html#10307" class="Bound">ring</a> <a id="10354" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10356" class="Symbol">)</a>
  <a id="10360" href="Agda.Builtin.Reflection.html#9830" class="Postulate">commitTC</a>
  <a id="10371" href="Tactic.RingSolver.html#10371" class="Bound">operatorTerms</a> <a id="10385" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10387" href="Tactic.RingSolver.html#3616" class="Function">getRingOperatorTerms</a> <a id="10408" href="Tactic.RingSolver.html#10324" class="Bound">`ring</a>

  <a id="10417" class="Comment">-- Obtain and sanitise the goal type</a>
  <a id="10456" href="Tactic.RingSolver.html#10456" class="Bound">`hole</a> <a id="10462" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10464" href="Agda.Builtin.Reflection.html#8878" class="Postulate">inferType</a> <a id="10474" href="Tactic.RingSolver.html#10312" class="Bound">hole</a> <a id="10479" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="10483" href="Agda.Builtin.Reflection.html#8993" class="Postulate">reduce</a>
  <a id="10492" class="Keyword">let</a> <a id="10496" href="Tactic.RingSolver.html#10496" class="Bound">variablesAndTypes</a> <a id="10514" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10516" href="Tactic.RingSolver.html#10516" class="Bound">equation</a> <a id="10525" class="Symbol">=</a> <a id="10527" href="Reflection.AST.Term.html#3491" class="Function">stripPis</a> <a id="10536" href="Tactic.RingSolver.html#10456" class="Bound">`hole</a>

  <a id="10545" class="Keyword">let</a> <a id="10549" href="Tactic.RingSolver.html#10549" class="Bound">variables</a> <a id="10559" class="Symbol">=</a> <a id="10561" href="Data.List.Base.html#1634" class="Function">List.map</a> <a id="10570" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="10576" href="Tactic.RingSolver.html#10496" class="Bound">variablesAndTypes</a>
  <a id="10596" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="10601" class="Symbol">(</a><a id="10602" href="Tactic.RingSolver.html#10602" class="Bound">lhs</a> <a id="10606" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="10608" href="Tactic.RingSolver.html#10608" class="Bound">rhs</a> <a id="10612" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="10614" href="Data.Vec.Base.html#1150" class="InductiveConstructor">[]</a><a id="10616" class="Symbol">)</a> <a id="10618" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10620" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="10625" class="Symbol">(</a><a id="10626" href="Tactic.RingSolver.html#1810" class="Function">getVisibleArgs</a> <a id="10641" class="Number">2</a> <a id="10643" href="Tactic.RingSolver.html#10516" class="Bound">equation</a><a id="10651" class="Symbol">)</a>
    <a id="10657" class="Keyword">where</a> <a id="10663" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="10671" class="Symbol">→</a> <a id="10673" href="Tactic.RingSolver.html#9015" class="Function">malformedForallTypeError</a> <a id="10698" href="Tactic.RingSolver.html#10456" class="Bound">`hole</a>

  <a id="10707" href="Tactic.RingSolver.html#10707" class="Bound">solverCall</a> <a id="10718" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10720" href="Tactic.RingSolver.html#9394" class="Function">constructCallToSolver</a> <a id="10742" href="Tactic.RingSolver.html#10324" class="Bound">`ring</a> <a id="10748" href="Tactic.RingSolver.html#10371" class="Bound">operatorTerms</a> <a id="10762" href="Tactic.RingSolver.html#10549" class="Bound">variables</a> <a id="10772" href="Tactic.RingSolver.html#10602" class="Bound">lhs</a> <a id="10776" href="Tactic.RingSolver.html#10608" class="Bound">rhs</a>
  <a id="10782" href="Agda.Builtin.Reflection.html#8775" class="Postulate">unify</a> <a id="10788" href="Tactic.RingSolver.html#10312" class="Bound">hole</a> <a id="10793" href="Tactic.RingSolver.html#10707" class="Bound">solverCall</a>

<a id="10805" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="10813" href="Tactic.RingSolver.html#10813" class="Function">solve-∀</a> <a id="10821" class="Symbol">:</a> <a id="10823" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="10828" class="Symbol">→</a> <a id="10830" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="10835" class="Symbol">→</a> <a id="10837" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="10840" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="10844" href="Tactic.RingSolver.html#10813" class="Function">solve-∀</a> <a id="10852" class="Symbol">=</a> <a id="10854" href="Tactic.RingSolver.html#10258" class="Function">solve-∀-macro</a>

<a id="10869" class="Comment">------------------------------------------------------------------------</a>
<a id="10942" class="Comment">-- Unquantified macro</a>

<a id="malformedArgumentListError"></a><a id="10965" href="Tactic.RingSolver.html#10965" class="Function">malformedArgumentListError</a> <a id="10992" class="Symbol">:</a> <a id="10994" class="Symbol">∀</a> <a id="10996" class="Symbol">{</a><a id="10997" href="Tactic.RingSolver.html#10997" class="Bound">a</a><a id="10998" class="Symbol">}</a> <a id="11000" class="Symbol">{</a><a id="11001" href="Tactic.RingSolver.html#11001" class="Bound">A</a> <a id="11003" class="Symbol">:</a> <a id="11005" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="11009" href="Tactic.RingSolver.html#10997" class="Bound">a</a><a id="11010" class="Symbol">}</a> <a id="11012" class="Symbol">→</a> <a id="11014" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11019" class="Symbol">→</a> <a id="11021" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="11024" href="Tactic.RingSolver.html#11001" class="Bound">A</a>
<a id="11026" href="Tactic.RingSolver.html#10965" class="Function">malformedArgumentListError</a> <a id="11053" href="Tactic.RingSolver.html#11053" class="Bound">found</a> <a id="11059" class="Symbol">=</a> <a id="11061" href="Agda.Builtin.Reflection.html#8815" class="Postulate">typeError</a>
  <a id="11073" class="Symbol">(</a> <a id="11075" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="11082" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11111" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11113" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="11120" class="String">&quot;First argument should be a list of free variables.&quot;</a>
  <a id="11175" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11177" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="11184" class="String">&quot;Instead: &quot;</a>
  <a id="11198" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11200" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="11208" href="Tactic.RingSolver.html#11053" class="Bound">found</a>
  <a id="11216" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11218" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11220" class="Symbol">)</a>

<a id="malformedGoalError"></a><a id="11223" href="Tactic.RingSolver.html#11223" class="Function">malformedGoalError</a> <a id="11242" class="Symbol">:</a> <a id="11244" class="Symbol">∀</a> <a id="11246" class="Symbol">{</a><a id="11247" href="Tactic.RingSolver.html#11247" class="Bound">a</a><a id="11248" class="Symbol">}</a> <a id="11250" class="Symbol">{</a><a id="11251" href="Tactic.RingSolver.html#11251" class="Bound">A</a> <a id="11253" class="Symbol">:</a> <a id="11255" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="11259" href="Tactic.RingSolver.html#11247" class="Bound">a</a><a id="11260" class="Symbol">}</a> <a id="11262" class="Symbol">→</a> <a id="11264" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11269" class="Symbol">→</a> <a id="11271" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="11274" href="Tactic.RingSolver.html#11251" class="Bound">A</a>
<a id="11276" href="Tactic.RingSolver.html#11223" class="Function">malformedGoalError</a> <a id="11295" href="Tactic.RingSolver.html#11295" class="Bound">found</a> <a id="11301" class="Symbol">=</a> <a id="11303" href="Agda.Builtin.Reflection.html#8815" class="Postulate">typeError</a>
  <a id="11315" class="Symbol">(</a> <a id="11317" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="11324" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11353" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11355" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="11362" class="String">&quot;Goal type should be of the form: LHS ≈ RHS&quot;</a>
  <a id="11409" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11411" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="11418" class="String">&quot;Instead: &quot;</a>
  <a id="11432" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11434" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="11442" href="Tactic.RingSolver.html#11295" class="Bound">found</a>
  <a id="11450" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11452" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11454" class="Symbol">)</a>

<a id="checkIsListOfVariables"></a><a id="11457" href="Tactic.RingSolver.html#11457" class="Function">checkIsListOfVariables</a> <a id="11480" class="Symbol">:</a> <a id="11482" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11487" class="Symbol">→</a> <a id="11489" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11494" class="Symbol">→</a> <a id="11496" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="11499" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="11504" href="Tactic.RingSolver.html#11457" class="Function">checkIsListOfVariables</a> <a id="11527" href="Tactic.RingSolver.html#11527" class="Bound">`ring</a> <a id="11533" href="Tactic.RingSolver.html#11533" class="Bound">`xs</a> <a id="11537" class="Symbol">=</a> <a id="11539" href="Agda.Builtin.Reflection.html#8914" class="Postulate">checkType</a> <a id="11549" href="Tactic.RingSolver.html#11533" class="Bound">`xs</a> <a id="11553" class="Symbol">(</a><a id="11554" href="Data.List.Reflection.html#471" class="Function">`List</a> <a id="11560" class="Symbol">(</a><a id="11561" href="Tactic.RingSolver.html#3160" class="Function">`Carrier</a> <a id="11570" href="Tactic.RingSolver.html#11527" class="Bound">`ring</a><a id="11575" class="Symbol">))</a> <a id="11578" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="11582" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a>

<a id="11593" class="Comment">-- Extracts the deBruijn indices from a list of variables</a>
<a id="getVariableIndices"></a><a id="11651" href="Tactic.RingSolver.html#11651" class="Function">getVariableIndices</a> <a id="11670" class="Symbol">:</a> <a id="11672" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11677" class="Symbol">→</a> <a id="11679" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="11685" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a>
<a id="11692" href="Tactic.RingSolver.html#11651" class="Function">getVariableIndices</a> <a id="11711" class="Symbol">=</a> <a id="11713" href="Tactic.RingSolver.html#11729" class="Function">go</a> <a id="11716" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="11721" class="Keyword">where</a>
  <a id="11729" href="Tactic.RingSolver.html#11729" class="Function">go</a> <a id="11732" class="Symbol">:</a> <a id="11734" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a> <a id="11741" class="Symbol">→</a> <a id="11743" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11748" class="Symbol">→</a> <a id="11750" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="11756" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a>
  <a id="11765" href="Tactic.RingSolver.html#11729" class="Function">go</a> <a id="11768" href="Tactic.RingSolver.html#11768" class="Bound">t</a> <a id="11770" class="Symbol">(</a><a id="11771" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="11775" href="Tactic.RingSolver.html#11775" class="Bound">i</a> <a id="11777" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="11780" href="Data.List.Reflection.html#980" class="InductiveConstructor Operator">`∷`</a> <a id="11784" href="Tactic.RingSolver.html#11784" class="Bound">xs</a><a id="11786" class="Symbol">)</a> <a id="11788" class="Symbol">=</a> <a id="11790" href="Tactic.RingSolver.html#11729" class="Function">go</a> <a id="11793" class="Symbol">(</a><a id="11794" href="Tactic.RingSolver.Core.NatSet.html#2292" class="Function">insert</a> <a id="11801" href="Tactic.RingSolver.html#11775" class="Bound">i</a> <a id="11803" href="Tactic.RingSolver.html#11768" class="Bound">t</a><a id="11804" class="Symbol">)</a> <a id="11806" href="Tactic.RingSolver.html#11784" class="Bound">xs</a>
  <a id="11811" href="Tactic.RingSolver.html#11729" class="Function">go</a> <a id="11814" href="Tactic.RingSolver.html#11814" class="Bound">t</a> <a id="11816" href="Data.List.Reflection.html#936" class="InductiveConstructor">`[]`</a>              <a id="11834" class="Symbol">=</a> <a id="11836" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="11841" href="Tactic.RingSolver.html#11814" class="Bound">t</a>
  <a id="11845" href="Tactic.RingSolver.html#11729" class="CatchallClause Function">go</a><a id="11847" class="CatchallClause"> </a><a id="11848" class="CatchallClause Symbol">_</a><a id="11849" class="CatchallClause"> </a><a id="11850" class="CatchallClause Symbol">_</a>                 <a id="11868" class="Symbol">=</a> <a id="11870" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

<a id="constructSolution"></a><a id="11879" href="Tactic.RingSolver.html#11879" class="Function">constructSolution</a> <a id="11897" class="Symbol">:</a> <a id="11899" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11904" class="Symbol">→</a> <a id="11906" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a> <a id="11924" class="Symbol">→</a> <a id="11926" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a> <a id="11933" class="Symbol">→</a> <a id="11935" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11940" class="Symbol">→</a> <a id="11942" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="11947" class="Symbol">→</a> <a id="11949" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="11952" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="11957" href="Tactic.RingSolver.html#11879" class="Function">constructSolution</a> <a id="11975" href="Tactic.RingSolver.html#11975" class="Bound">`ring</a> <a id="11981" href="Tactic.RingSolver.html#11981" class="Bound">opTerms</a> <a id="11989" href="Tactic.RingSolver.html#11989" class="Bound">variables</a> <a id="11999" href="Tactic.RingSolver.html#11999" class="Bound">`lhs</a> <a id="12004" href="Tactic.RingSolver.html#12004" class="Bound">`rhs</a> <a id="12009" class="Symbol">=</a> <a id="12011" class="Keyword">do</a>
  <a id="12016" href="Tactic.RingSolver.html#12016" class="Bound">`lhsExpr</a> <a id="12025" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="12027" href="Tactic.RingSolver.html#12300" class="Function">conv</a> <a id="12032" href="Tactic.RingSolver.html#11999" class="Bound">`lhs</a>
  <a id="12039" href="Tactic.RingSolver.html#12039" class="Bound">`rhsExpr</a> <a id="12048" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="12050" href="Tactic.RingSolver.html#12300" class="Function">conv</a> <a id="12055" href="Tactic.RingSolver.html#12004" class="Bound">`rhs</a>
  <a id="12062" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="12067" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="12069" href="Tactic.RingSolver.html#3332" class="Function">`trans</a> <a id="12076" href="Tactic.RingSolver.html#11975" class="Bound">`ring</a> <a id="12082" class="Symbol">(</a><a id="12083" href="Tactic.RingSolver.html#3264" class="Function">`sym</a> <a id="12088" href="Tactic.RingSolver.html#11975" class="Bound">`ring</a> <a id="12094" href="Tactic.RingSolver.html#12016" class="Bound">`lhsExpr</a><a id="12102" class="Symbol">)</a> <a id="12104" href="Tactic.RingSolver.html#12039" class="Bound">`rhsExpr</a>
  <a id="12115" class="Keyword">where</a>
  <a id="12123" href="Tactic.RingSolver.html#12123" class="Function">numVars</a> <a id="12131" class="Symbol">=</a> <a id="12133" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="12145" href="Tactic.RingSolver.html#11989" class="Bound">variables</a>

  <a id="12158" href="Tactic.RingSolver.html#12158" class="Function">varMap</a> <a id="12165" class="Symbol">:</a> <a id="12167" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a>
  <a id="12176" href="Tactic.RingSolver.html#12158" class="Function">varMap</a> <a id="12183" href="Tactic.RingSolver.html#12183" class="Bound">i</a> <a id="12185" class="Symbol">=</a> <a id="12187" href="Data.Maybe.Base.html#2110" class="Function">Maybe.map</a> <a id="12197" class="Symbol">(λ</a> <a id="12200" href="Tactic.RingSolver.html#12200" class="Bound">x</a> <a id="12202" class="Symbol">→</a> <a id="12204" href="Tactic.RingSolver.html#4723" class="Function">`I</a> <a id="12207" href="Tactic.RingSolver.html#11975" class="Bound">`ring</a> <a id="12213" href="Tactic.RingSolver.html#12123" class="Function">numVars</a> <a id="12221" class="Symbol">(</a><a id="12222" href="Data.Nat.Reflection.html#728" class="Function">toFinTerm</a> <a id="12232" href="Tactic.RingSolver.html#12200" class="Bound">x</a><a id="12233" class="Symbol">))</a> <a id="12236" class="Symbol">(</a><a id="12237" href="Tactic.RingSolver.Core.NatSet.html#2940" class="Function">lookup</a> <a id="12244" href="Tactic.RingSolver.html#11989" class="Bound">variables</a> <a id="12254" href="Tactic.RingSolver.html#12183" class="Bound">i</a><a id="12255" class="Symbol">)</a>

  <a id="12260" href="Tactic.RingSolver.html#12260" class="Function">ρ</a> <a id="12262" class="Symbol">:</a> <a id="12264" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="12271" href="Tactic.RingSolver.html#12260" class="Function">ρ</a> <a id="12273" class="Symbol">=</a> <a id="12275" href="Tactic.RingSolver.html#2237" class="Function">curriedTerm</a> <a id="12287" href="Tactic.RingSolver.html#11989" class="Bound">variables</a>

  <a id="12300" href="Tactic.RingSolver.html#12300" class="Function">conv</a> <a id="12305" class="Symbol">=</a> <a id="12307" class="Symbol">λ</a> <a id="12309" href="Tactic.RingSolver.html#12309" class="Bound">t</a> <a id="12311" class="Symbol">→</a> <a id="12313" class="Keyword">do</a>
    <a id="12320" href="Tactic.RingSolver.html#12320" class="Bound">t&#39;</a> <a id="12323" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="12325" href="Tactic.RingSolver.html#5830" class="Function">convertTerm</a> <a id="12337" href="Tactic.RingSolver.html#11975" class="Bound">`ring</a> <a id="12343" href="Tactic.RingSolver.html#12123" class="Function">numVars</a> <a id="12351" href="Tactic.RingSolver.html#11981" class="Bound">opTerms</a> <a id="12359" href="Tactic.RingSolver.html#12158" class="Function">varMap</a> <a id="12366" href="Tactic.RingSolver.html#12309" class="Bound">t</a>
    <a id="12372" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="12377" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="12379" href="Tactic.RingSolver.html#4885" class="Function">`correct</a> <a id="12388" href="Tactic.RingSolver.html#11975" class="Bound">`ring</a> <a id="12394" href="Tactic.RingSolver.html#12123" class="Function">numVars</a> <a id="12402" href="Tactic.RingSolver.html#12320" class="Bound">t&#39;</a> <a id="12405" href="Tactic.RingSolver.html#12260" class="Function">ρ</a>

<a id="12408" class="Comment">-- Use this macro when you want to solve something *under* a lambda.</a>
<a id="12477" class="Comment">-- For example: say you have a long proof, and you just want the solver</a>
<a id="12549" class="Comment">-- to deal with an intermediate step. Call it like so:</a>
<a id="12604" class="Comment">--</a>
<a id="12607" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="12659" class="Comment">--   lemma₃ x y = begin</a>
<a id="12683" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="12742" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="12796" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="12827" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="12850" class="Comment">--</a>
<a id="12853" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="12920" class="Comment">-- ring implementation (as before).</a>
<a id="solve-macro"></a><a id="12956" href="Tactic.RingSolver.html#12956" class="Function">solve-macro</a> <a id="12968" class="Symbol">:</a> <a id="12970" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="12975" class="Symbol">→</a> <a id="12977" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="12982" class="Symbol">→</a> <a id="12984" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="12989" class="Symbol">→</a> <a id="12991" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="12994" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="12996" href="Tactic.RingSolver.html#12956" class="Function">solve-macro</a> <a id="13008" href="Tactic.RingSolver.html#13008" class="Bound">variables</a> <a id="13018" href="Tactic.RingSolver.html#13018" class="Bound">ring</a> <a id="13023" href="Tactic.RingSolver.html#13023" class="Bound">hole</a> <a id="13028" class="Symbol">=</a> <a id="13030" class="Keyword">do</a>
  <a id="13035" href="Tactic.RingSolver.html#13035" class="Bound">`ring</a> <a id="13041" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13043" href="Tactic.RingSolver.html#2715" class="Function">checkIsRing</a> <a id="13055" class="Symbol">(</a><a id="13056" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="13060" href="Tactic.RingSolver.html#13018" class="Bound">ring</a> <a id="13065" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13067" class="Symbol">)</a>
  <a id="13071" href="Agda.Builtin.Reflection.html#9830" class="Postulate">commitTC</a>
  <a id="13082" href="Tactic.RingSolver.html#13082" class="Bound">operatorTerms</a> <a id="13096" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13098" href="Tactic.RingSolver.html#3616" class="Function">getRingOperatorTerms</a> <a id="13119" href="Tactic.RingSolver.html#13035" class="Bound">`ring</a>

  <a id="13128" class="Comment">-- Obtain and sanitise the list of variables</a>
  <a id="13175" href="Tactic.RingSolver.html#13175" class="Bound">listOfVariables′</a> <a id="13192" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13194" href="Tactic.RingSolver.html#11457" class="Function">checkIsListOfVariables</a> <a id="13217" href="Tactic.RingSolver.html#13035" class="Bound">`ring</a> <a id="13223" href="Tactic.RingSolver.html#13008" class="Bound">variables</a>
  <a id="13235" href="Agda.Builtin.Reflection.html#9830" class="Postulate">commitTC</a>
  <a id="13246" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="13251" href="Tactic.RingSolver.html#13251" class="Bound">variableIndices</a> <a id="13267" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13269" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="13274" class="Symbol">(</a><a id="13275" href="Tactic.RingSolver.html#11651" class="Function">getVariableIndices</a> <a id="13294" href="Tactic.RingSolver.html#13175" class="Bound">listOfVariables′</a><a id="13310" class="Symbol">)</a>
    <a id="13316" class="Keyword">where</a> <a id="13322" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="13330" class="Symbol">→</a> <a id="13332" href="Tactic.RingSolver.html#10965" class="Function">malformedArgumentListError</a> <a id="13359" href="Tactic.RingSolver.html#13175" class="Bound">listOfVariables′</a>

  <a id="13379" class="Comment">-- Obtain and santise the goal type</a>
  <a id="13417" href="Tactic.RingSolver.html#13417" class="Bound">hole′</a> <a id="13423" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13425" href="Agda.Builtin.Reflection.html#8878" class="Postulate">inferType</a> <a id="13435" href="Tactic.RingSolver.html#13023" class="Bound">hole</a> <a id="13440" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="13444" href="Agda.Builtin.Reflection.html#8993" class="Postulate">reduce</a>
  <a id="13453" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="13458" class="Symbol">(</a><a id="13459" href="Tactic.RingSolver.html#13459" class="Bound">lhs</a> <a id="13463" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="13465" href="Tactic.RingSolver.html#13465" class="Bound">rhs</a> <a id="13469" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="13471" href="Data.Vec.Base.html#1150" class="InductiveConstructor">[]</a><a id="13473" class="Symbol">)</a> <a id="13475" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13477" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="13482" class="Symbol">(</a><a id="13483" href="Tactic.RingSolver.html#1810" class="Function">getVisibleArgs</a> <a id="13498" class="Number">2</a> <a id="13500" href="Tactic.RingSolver.html#13417" class="Bound">hole′</a><a id="13505" class="Symbol">)</a>
    <a id="13511" class="Keyword">where</a> <a id="13517" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="13525" class="Symbol">→</a> <a id="13527" href="Tactic.RingSolver.html#11223" class="Function">malformedGoalError</a> <a id="13546" href="Tactic.RingSolver.html#13417" class="Bound">hole′</a>

  <a id="13555" href="Tactic.RingSolver.html#13555" class="Bound">solution</a> <a id="13564" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13566" href="Tactic.RingSolver.html#11879" class="Function">constructSolution</a> <a id="13584" href="Tactic.RingSolver.html#13035" class="Bound">`ring</a> <a id="13590" href="Tactic.RingSolver.html#13082" class="Bound">operatorTerms</a> <a id="13604" href="Tactic.RingSolver.html#13251" class="Bound">variableIndices</a> <a id="13620" href="Tactic.RingSolver.html#13459" class="Bound">lhs</a> <a id="13624" href="Tactic.RingSolver.html#13465" class="Bound">rhs</a>
  <a id="13630" href="Agda.Builtin.Reflection.html#8775" class="Postulate">unify</a> <a id="13636" href="Tactic.RingSolver.html#13023" class="Bound">hole</a> <a id="13641" href="Tactic.RingSolver.html#13555" class="Bound">solution</a>

<a id="13651" class="Keyword">macro</a>
  <a id="solve"></a><a id="13659" href="Tactic.RingSolver.html#13659" class="Function">solve</a> <a id="13665" class="Symbol">:</a> <a id="13667" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="13672" class="Symbol">→</a> <a id="13674" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="13679" class="Symbol">→</a> <a id="13681" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="13686" class="Symbol">→</a> <a id="13688" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="13691" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="13695" href="Tactic.RingSolver.html#13659" class="Function">solve</a> <a id="13701" class="Symbol">=</a> <a id="13703" href="Tactic.RingSolver.html#12956" class="Function">solve-macro</a>
</pre></body></html>