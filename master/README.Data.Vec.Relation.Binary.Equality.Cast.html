<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Vec.Relation.Binary.Equality.Cast</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- An equational reasoning library for propositional equality over</a>
<a id="173" class="Comment">-- vectors of different indices using cast.</a>
<a id="217" class="Comment">--</a>
<a id="220" class="Comment">-- To see example usages of this library, scroll to the `Combinators`</a>
<a id="290" class="Comment">-- section.</a>
<a id="302" class="Comment">------------------------------------------------------------------------</a>

<a id="376" class="Symbol">{-#</a> <a id="380" class="Keyword">OPTIONS</a> <a id="388" class="Pragma">--cubical-compatible</a> <a id="409" class="Pragma">--safe</a> <a id="416" class="Symbol">#-}</a>

<a id="421" class="Keyword">module</a> <a id="428" href="README.Data.Vec.Relation.Binary.Equality.Cast.html" class="Module">README.Data.Vec.Relation.Binary.Equality.Cast</a> <a id="474" class="Keyword">where</a>

<a id="481" class="Keyword">open</a> <a id="486" class="Keyword">import</a> <a id="493" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>
<a id="508" class="Keyword">open</a> <a id="513" class="Keyword">import</a> <a id="520" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="535" class="Symbol">as</a> <a id="538" class="Module">List</a> <a id="543" class="Keyword">using</a> <a id="549" class="Symbol">(</a><a id="550" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="554" class="Symbol">)</a>
<a id="556" class="Keyword">import</a> <a id="563" href="Data.List.Properties.html" class="Module">Data.List.Properties</a> <a id="584" class="Symbol">as</a> <a id="587" class="Module">List</a>
<a id="592" class="Keyword">open</a> <a id="597" class="Keyword">import</a> <a id="604" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="618" class="Keyword">open</a> <a id="623" class="Keyword">import</a> <a id="630" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="650" class="Keyword">open</a> <a id="655" class="Keyword">import</a> <a id="662" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>
<a id="676" class="Keyword">open</a> <a id="681" class="Keyword">import</a> <a id="688" href="Data.Vec.Properties.html" class="Module">Data.Vec.Properties</a>
<a id="708" class="Keyword">open</a> <a id="713" class="Keyword">import</a> <a id="720" href="Data.Vec.Relation.Binary.Equality.Cast.html" class="Module">Data.Vec.Relation.Binary.Equality.Cast</a>
<a id="759" class="Keyword">open</a> <a id="764" class="Keyword">import</a> <a id="771" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="811" class="Keyword">using</a> <a id="817" class="Symbol">(</a><a id="818" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="821" class="Symbol">;</a> <a id="823" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="827" class="Symbol">;</a> <a id="829" href="Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="832" class="Symbol">;</a> <a id="834" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="838" class="Symbol">;</a> <a id="840" class="Keyword">module</a> <a id="847" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a><a id="858" class="Symbol">)</a>

<a id="861" class="Keyword">private</a> <a id="869" class="Keyword">variable</a>
  <a id="880" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#880" class="Generalizable">a</a> <a id="882" class="Symbol">:</a> <a id="884" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="892" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="894" class="Symbol">:</a> <a id="896" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="900" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#880" class="Generalizable">a</a>
  <a id="904" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#904" class="Generalizable">l</a> <a id="906" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="908" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="910" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#910" class="Generalizable">o</a> <a id="912" class="Symbol">:</a> <a id="914" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#918" class="Generalizable">xs</a> <a id="921" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#921" class="Generalizable">ys</a> <a id="924" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#924" class="Generalizable">zs</a> <a id="927" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#927" class="Generalizable">ws</a> <a id="930" class="Symbol">:</a> <a id="932" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="936" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="938" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a>


<a id="942" class="Comment">------------------------------------------------------------------------</a>
<a id="1015" class="Comment">-- Motivation</a>
<a id="1029" class="Comment">--</a>
<a id="1032" class="Comment">-- The `cast` function is the computational variant of `subst` for</a>
<a id="1099" class="Comment">-- vectors. Since `cast` computes under vector constructors, it</a>
<a id="1163" class="Comment">-- enables reasoning about vectors with non-definitionally equal indices</a>
<a id="1236" class="Comment">-- by induction. See, e.g., Jacques Carette&#39;s comment in issue #1668.</a>
<a id="1306" class="Comment">-- &lt;https://github.com/agda/agda-stdlib/pull/1668#issuecomment-1003449509&gt;</a>
<a id="1381" class="Comment">--</a>
<a id="1384" class="Comment">-- Suppose we want to prove that ‘xs ++ [] ≡ xs’. Because `xs ++ []`</a>
<a id="1453" class="Comment">-- has type `Vec A (n + 0)` while `xs` has type `Vec A n`, they cannot</a>
<a id="1524" class="Comment">-- be directly related by homogeneous equality.</a>
<a id="1572" class="Comment">-- To resolve the issue, `++-right-identity` uses `cast` to recast</a>
<a id="1639" class="Comment">-- `xs ++ []` as a vector in `Vec A n`.</a>
<a id="1679" class="Comment">--</a>
<a id="++-right-identity"></a><a id="1682" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1682" class="Function">++-right-identity</a> <a id="1700" class="Symbol">:</a> <a id="1702" class="Symbol">∀</a> <a id="1704" class="Symbol">.(</a><a id="1706" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1706" class="Bound">eq</a> <a id="1709" class="Symbol">:</a> <a id="1711" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="1713" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="1715" class="Number">0</a> <a id="1717" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1719" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="1720" class="Symbol">)</a> <a id="1722" class="Symbol">(</a><a id="1723" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1723" class="Bound">xs</a> <a id="1726" class="Symbol">:</a> <a id="1728" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="1732" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="1734" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="1735" class="Symbol">)</a> <a id="1737" class="Symbol">→</a> <a id="1739" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="1744" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1706" class="Bound">eq</a> <a id="1747" class="Symbol">(</a><a id="1748" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1723" class="Bound">xs</a> <a id="1751" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="1754" href="Data.Vec.Base.html#1150" class="InductiveConstructor">[]</a><a id="1756" class="Symbol">)</a> <a id="1758" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1760" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1723" class="Bound">xs</a>
<a id="1763" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1682" class="Function">++-right-identity</a> <a id="1781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1781" class="Bound">eq</a> <a id="1784" href="Data.Vec.Base.html#1150" class="InductiveConstructor">[]</a>       <a id="1793" class="Symbol">=</a> <a id="1795" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="1800" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1682" class="Function">++-right-identity</a> <a id="1818" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1818" class="Bound">eq</a> <a id="1821" class="Symbol">(</a><a id="1822" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1822" class="Bound">x</a> <a id="1824" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="1826" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1826" class="Bound">xs</a><a id="1828" class="Symbol">)</a> <a id="1830" class="Symbol">=</a> <a id="1832" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1837" class="Symbol">(</a><a id="1838" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1822" class="Bound">x</a> <a id="1840" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷_</a><a id="1842" class="Symbol">)</a> <a id="1844" class="Symbol">(</a><a id="1845" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1682" class="Function">++-right-identity</a> <a id="1863" class="Symbol">(</a><a id="1864" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1869" href="Data.Nat.Base.html#5266" class="Function">pred</a> <a id="1874" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1818" class="Bound">eq</a><a id="1876" class="Symbol">)</a> <a id="1878" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1826" class="Bound">xs</a><a id="1880" class="Symbol">)</a>
<a id="1882" class="Comment">--</a>
<a id="1885" class="Comment">-- When the input is `x ∷ xs`, because `cast eq (x ∷ _)` equals</a>
<a id="1949" class="Comment">-- `x ∷ cast (cong pred eq) _`, the proof obligation</a>
<a id="2002" class="Comment">--     cast eq (x ∷ xs ++ []) ≡ x ∷ xs</a>
<a id="2041" class="Comment">-- simplifies to</a>
<a id="2058" class="Comment">--     x :: cast (cong pred eq) (xs ++ []) ≡ x ∷ xs</a>


<a id="2112" class="Comment">-- Although `cast` makes it possible to prove vector identities by ind-</a>
<a id="2184" class="Comment">-- uction, the explicit type-casting nature poses a significant barrier</a>
<a id="2256" class="Comment">-- to code reuse in larger proofs. For example, consider the identity</a>
<a id="2326" class="Comment">-- ‘fromList (xs List.∷ʳ x) ≡ (fromList xs) ∷ʳ x’ where `List._∷ʳ_` is the</a>
<a id="2401" class="Comment">-- snoc function of lists. We have</a>
<a id="2436" class="Comment">--</a>
<a id="2439" class="Comment">--     fromList (xs List.∷ʳ x)            : Vec A (List.length (xs List.∷ʳ x))</a>
<a id="2518" class="Comment">--   =   {- by definition -}</a>
<a id="2547" class="Comment">--     fromList (xs List.++ List.[ x ])   : Vec A (List.length (xs List.++ List.[ x ]))</a>
<a id="2635" class="Comment">--   =   {- by fromList-++ -}</a>
<a id="2665" class="Comment">--     fromList xs ++ fromList List.[ x ] : Vec A (List.length xs + List.length [ x ])</a>
<a id="2752" class="Comment">--   =   {- by definition -}</a>
<a id="2781" class="Comment">--     fromList xs ++ [ x ]               : Vec A (List.length xs + 1)</a>
<a id="2852" class="Comment">--   =   {- by unfold-∷ʳ -}</a>
<a id="2880" class="Comment">--     fromList xs ∷ʳ x                   : Vec A (suc (List.length xs))</a>
<a id="2953" class="Comment">-- where</a>
<a id="2962" class="Comment">--     fromList-++ : cast _ (fromList (xs List.++ ys)) ≡ fromList xs ++ fromList ys</a>
<a id="3046" class="Comment">--     unfold-∷ʳ   : cast _ (xs ∷ʳ x) ≡ xs ++ [ x ]</a>
<a id="3098" class="Comment">--</a>
<a id="3101" class="Comment">-- Although the identity itself is simple, the reasoning process changes</a>
<a id="3174" class="Comment">-- the index in the type twice. Consequently, its Agda translation must</a>
<a id="3246" class="Comment">-- insert two `cast`s in the proof. Moreover, the proof first has to</a>
<a id="3315" class="Comment">-- rearrange (the Agda version of) the identity into one with two</a>
<a id="3381" class="Comment">-- `cast`s, resulting in lots of boilerplate code as demonstrated by</a>
<a id="3450" class="Comment">-- `example1a-fromList-∷ʳ`.</a>
<a id="example1a-fromList-∷ʳ"></a><a id="3478" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3478" class="Function">example1a-fromList-∷ʳ</a> <a id="3500" class="Symbol">:</a> <a id="3502" class="Symbol">∀</a> <a id="3504" class="Symbol">(</a><a id="3505" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3505" class="Bound">x</a> <a id="3507" class="Symbol">:</a> <a id="3509" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="3510" class="Symbol">)</a> <a id="3512" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a> <a id="3515" class="Symbol">→</a>
                        <a id="3541" class="Symbol">.(</a><a id="3543" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3543" class="Bound">eq</a> <a id="3546" class="Symbol">:</a> <a id="3548" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="3560" class="Symbol">(</a><a id="3561" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a> <a id="3564" href="Data.List.Base.html#7660" class="Function Operator">List.∷ʳ</a> <a id="3572" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3505" class="Bound">x</a><a id="3573" class="Symbol">)</a> <a id="3575" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3577" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3581" class="Symbol">(</a><a id="3582" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="3594" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a><a id="3596" class="Symbol">))</a> <a id="3599" class="Symbol">→</a>
                        <a id="3625" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="3630" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3543" class="Bound">eq</a> <a id="3633" class="Symbol">(</a><a id="3634" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="3643" class="Symbol">(</a><a id="3644" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a> <a id="3647" href="Data.List.Base.html#7660" class="Function Operator">List.∷ʳ</a> <a id="3655" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3505" class="Bound">x</a><a id="3656" class="Symbol">))</a> <a id="3659" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3661" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="3670" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a> <a id="3673" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="3676" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3505" class="Bound">x</a>
<a id="3678" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3478" class="Function">example1a-fromList-∷ʳ</a> <a id="3700" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3702" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3705" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3705" class="Bound">eq</a> <a id="3708" class="Symbol">=</a> <a id="3710" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="3718" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="3723" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3705" class="Bound">eq</a> <a id="3726" class="Symbol">(</a><a id="3727" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="3736" class="Symbol">(</a><a id="3737" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3740" href="Data.List.Base.html#7660" class="Function Operator">List.∷ʳ</a> <a id="3748" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a><a id="3749" class="Symbol">))</a>
    <a id="3756" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
  <a id="3762" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="3767" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3705" class="Bound">eq</a> <a id="3770" class="Symbol">(</a><a id="3771" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="3780" class="Symbol">(</a><a id="3781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3784" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="3792" href="Data.List.Base.html#5259" class="Function Operator">List.[</a> <a id="3799" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3801" href="Data.List.Base.html#5259" class="Function Operator">]</a><a id="3802" class="Symbol">))</a>
    <a id="3809" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="3812" href="Data.Vec.Relation.Binary.Equality.Cast.html#1139" class="Function">cast-trans</a> <a id="3823" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4108" class="Function">eq₁</a> <a id="3827" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4147" class="Function">eq₂</a> <a id="3831" class="Symbol">(</a><a id="3832" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="3841" class="Symbol">(</a><a id="3842" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3845" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="3853" href="Data.List.Base.html#5259" class="Function Operator">List.[</a> <a id="3860" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3862" href="Data.List.Base.html#5259" class="Function Operator">]</a><a id="3863" class="Symbol">))</a> <a id="3866" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="3870" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="3875" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4147" class="Function">eq₂</a> <a id="3879" class="Symbol">(</a><a id="3880" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="3885" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4108" class="Function">eq₁</a> <a id="3889" class="Symbol">(</a><a id="3890" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="3899" class="Symbol">(</a><a id="3900" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3903" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="3911" href="Data.List.Base.html#5259" class="Function Operator">List.[</a> <a id="3918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3920" href="Data.List.Base.html#5259" class="Function Operator">]</a><a id="3921" class="Symbol">)))</a>
    <a id="3929" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="3932" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="3937" class="Symbol">(</a><a id="3938" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="3943" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4147" class="Function">eq₂</a><a id="3946" class="Symbol">)</a> <a id="3948" class="Symbol">(</a><a id="3949" href="Data.Vec.Properties.html#53408" class="Function">fromList-++</a> <a id="3961" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a><a id="3963" class="Symbol">)</a> <a id="3965" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="3969" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="3974" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4147" class="Function">eq₂</a> <a id="3978" class="Symbol">(</a><a id="3979" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="3988" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3991" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="3994" href="Data.Vec.Base.html#6481" class="Function Operator">[</a> <a id="3996" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3998" href="Data.Vec.Base.html#6481" class="Function Operator">]</a><a id="3999" class="Symbol">)</a>
    <a id="4005" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="4008" href="Data.Vec.Relation.Binary.Equality.Cast.html#1820" class="Function">≈-sym</a> <a id="4014" class="Symbol">(</a><a id="4015" href="Data.Vec.Properties.html#34664" class="Function">unfold-∷ʳ</a> <a id="4025" class="Symbol">(</a><a id="4026" href="Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="4030" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4147" class="Function">eq₂</a><a id="4033" class="Symbol">)</a> <a id="4035" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="4037" class="Symbol">(</a><a id="4038" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4047" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a><a id="4049" class="Symbol">))</a> <a id="4052" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="4056" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4065" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="4068" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="4071" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a>
    <a id="4077" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
  <a id="4081" class="Keyword">where</a>
  <a id="4089" class="Keyword">open</a> <a id="4094" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
  <a id="4108" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4108" class="Function">eq₁</a> <a id="4112" class="Symbol">=</a> <a id="4114" href="Data.List.Properties.html#5523" class="Function">List.length-++</a> <a id="4129" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="4132" class="Symbol">{</a><a id="4133" href="Data.List.Base.html#5259" class="Function Operator">List.[</a> <a id="4140" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="4142" href="Data.List.Base.html#5259" class="Function Operator">]</a><a id="4143" class="Symbol">}</a>
  <a id="4147" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4147" class="Function">eq₂</a> <a id="4151" class="Symbol">=</a> <a id="4153" href="Data.Nat.Properties.html#14888" class="Function">+-comm</a> <a id="4160" class="Symbol">(</a><a id="4161" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="4173" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a><a id="4175" class="Symbol">)</a> <a id="4177" class="Number">1</a>

<a id="4180" class="Comment">-- The `cast`s are irrelevant to core of the proof. At the same time,</a>
<a id="4250" class="Comment">-- they can be inferred from the lemmas used during the reasoning steps</a>
<a id="4322" class="Comment">-- (e.g. `fromList-++` and `unfold-∷ʳ`). To eliminate the boilerplate,</a>
<a id="4393" class="Comment">-- this library provides a set of equational reasoning combinators for</a>
<a id="4464" class="Comment">-- equality of the form `cast eq xs ≡ ys`.</a>
<a id="example1b-fromList-∷ʳ"></a><a id="4507" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4507" class="Function">example1b-fromList-∷ʳ</a> <a id="4529" class="Symbol">:</a> <a id="4531" class="Symbol">∀</a> <a id="4533" class="Symbol">(</a><a id="4534" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4534" class="Bound">x</a> <a id="4536" class="Symbol">:</a> <a id="4538" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="4539" class="Symbol">)</a> <a id="4541" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4541" class="Bound">xs</a> <a id="4544" class="Symbol">→</a>
                        <a id="4570" class="Symbol">.(</a><a id="4572" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4572" class="Bound">eq</a> <a id="4575" class="Symbol">:</a> <a id="4577" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="4589" class="Symbol">(</a><a id="4590" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4541" class="Bound">xs</a> <a id="4593" href="Data.List.Base.html#7660" class="Function Operator">List.∷ʳ</a> <a id="4601" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4534" class="Bound">x</a><a id="4602" class="Symbol">)</a> <a id="4604" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4606" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4610" class="Symbol">(</a><a id="4611" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="4623" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4541" class="Bound">xs</a><a id="4625" class="Symbol">))</a> <a id="4628" class="Symbol">→</a>
                        <a id="4654" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="4659" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4572" class="Bound">eq</a> <a id="4662" class="Symbol">(</a><a id="4663" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4672" class="Symbol">(</a><a id="4673" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4541" class="Bound">xs</a> <a id="4676" href="Data.List.Base.html#7660" class="Function Operator">List.∷ʳ</a> <a id="4684" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4534" class="Bound">x</a><a id="4685" class="Symbol">))</a> <a id="4688" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4690" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4699" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4541" class="Bound">xs</a> <a id="4702" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="4705" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4534" class="Bound">x</a>
<a id="4707" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4507" class="Function">example1b-fromList-∷ʳ</a> <a id="4729" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4729" class="Bound">x</a> <a id="4731" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">xs</a> <a id="4734" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4734" class="Bound">eq</a> <a id="4737" class="Symbol">=</a> <a id="4739" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="4747" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4756" class="Symbol">(</a><a id="4757" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">xs</a> <a id="4760" href="Data.List.Base.html#7660" class="Function Operator">List.∷ʳ</a> <a id="4768" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4729" class="Bound">x</a><a id="4769" class="Symbol">)</a>
    <a id="4775" href="Data.Vec.Relation.Binary.Equality.Cast.html#2910" class="Function Operator">≈⟨⟩</a>
  <a id="4781" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4790" class="Symbol">(</a><a id="4791" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">xs</a> <a id="4794" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="4802" href="Data.List.Base.html#5259" class="Function Operator">List.[</a> <a id="4809" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4729" class="Bound">x</a> <a id="4811" href="Data.List.Base.html#5259" class="Function Operator">]</a><a id="4812" class="Symbol">)</a>
    <a id="4818" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="4821" href="Data.Vec.Properties.html#53408" class="Function">fromList-++</a> <a id="4833" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">xs</a> <a id="4836" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="4840" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4849" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">xs</a> <a id="4852" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="4855" href="Data.Vec.Base.html#6481" class="Function Operator">[</a> <a id="4857" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4729" class="Bound">x</a> <a id="4859" href="Data.Vec.Base.html#6481" class="Function Operator">]</a>
    <a id="4865" href="Data.Vec.Relation.Binary.Equality.Cast.html#3258" class="Function">≈⟨</a> <a id="4868" href="Data.Vec.Properties.html#34664" class="Function">unfold-∷ʳ</a> <a id="4878" class="Symbol">(</a><a id="4879" href="Data.Nat.Properties.html#14888" class="Function">+-comm</a> <a id="4886" class="Number">1</a> <a id="4888" class="Symbol">(</a><a id="4889" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="4901" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">xs</a><a id="4903" class="Symbol">))</a> <a id="4906" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4729" class="Bound">x</a> <a id="4908" class="Symbol">(</a><a id="4909" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">xs</a><a id="4920" class="Symbol">)</a> <a id="4922" href="Data.Vec.Relation.Binary.Equality.Cast.html#3258" class="Function">⟨</a>
  <a id="4926" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="4935" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">xs</a> <a id="4938" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="4941" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4729" class="Bound">x</a>
    <a id="4947" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="4951" class="Keyword">where</a> <a id="4957" class="Keyword">open</a> <a id="4962" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>


<a id="4978" class="Comment">------------------------------------------------------------------------</a>
<a id="5051" class="Comment">-- Combinators</a>
<a id="5066" class="Comment">--</a>
<a id="5069" class="Comment">-- Let `xs ≈[ m≡n ] ys` denote `cast m≡n xs ≡ ys`. We have reflexivity,</a>
<a id="5141" class="Comment">-- symmetry and transitivity:</a>
<a id="5171" class="Comment">--     ≈-reflexive : xs ≈[ refl ] xs</a>
<a id="5208" class="Comment">--     ≈-sym       : xs ≈[ m≡n ] ys → ys ≈[ sym m≡n ] xs</a>
<a id="5265" class="Comment">--     ≈-trans     : xs ≈[ m≡n ] ys → ys ≈[ n≡o ] zs → xs ≈[ trans m≡n n≡o ] zs</a>
<a id="5345" class="Comment">-- Accordingly, `_≈[_]_` admits the standard set of equational reasoning</a>
<a id="5418" class="Comment">-- combinators. Suppose `≈-eqn : xs ≈[ m≡n ] ys`,</a>
<a id="5468" class="Comment">--     xs ≈⟨ ≈-eqn ⟩   -- `_≈⟨_⟩_` takes a `_≈[_]_` step, adjusting</a>
<a id="5536" class="Comment">--     ys              -- the index at the same time</a>
<a id="5589" class="Comment">--</a>
<a id="5592" class="Comment">--     ys ≈⟨ ≈-eqn ⟨   -- `_≈⟨_⟨_` takes a symmetric `_≈[_]_` step</a>
<a id="5659" class="Comment">--     xs</a>
<a id="example2a"></a><a id="5669" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5669" class="Function">example2a</a> <a id="5679" class="Symbol">:</a> <a id="5681" class="Symbol">∀</a> <a id="5683" class="Symbol">.(</a><a id="5685" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5685" class="Bound">eq</a> <a id="5688" class="Symbol">:</a> <a id="5690" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5694" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="5696" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="5698" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="5700" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5702" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="5704" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="5706" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5710" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="5711" class="Symbol">)</a> <a id="5713" class="Symbol">(</a><a id="5714" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5714" class="Bound">xs</a> <a id="5717" class="Symbol">:</a> <a id="5719" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="5723" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="5725" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a><a id="5726" class="Symbol">)</a> <a id="5728" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5728" class="Bound">a</a> <a id="5730" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5730" class="Bound">ys</a> <a id="5733" class="Symbol">→</a>
            <a id="5747" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="5752" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5685" class="Bound">eq</a> <a id="5755" class="Symbol">((</a><a id="5757" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="5765" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5714" class="Bound">xs</a> <a id="5768" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="5771" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5728" class="Bound">a</a><a id="5772" class="Symbol">)</a> <a id="5774" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="5777" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5730" class="Bound">ys</a><a id="5779" class="Symbol">)</a> <a id="5781" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5783" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="5791" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5714" class="Bound">xs</a> <a id="5794" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="5797" class="Symbol">(</a><a id="5798" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5728" class="Bound">a</a> <a id="5800" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="5802" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5730" class="Bound">ys</a><a id="5804" class="Symbol">)</a>
<a id="5806" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5669" class="Function">example2a</a> <a id="5816" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5816" class="Bound">eq</a> <a id="5819" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5819" class="Bound">xs</a> <a id="5822" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5822" class="Bound">a</a> <a id="5824" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5824" class="Bound">ys</a> <a id="5827" class="Symbol">=</a> <a id="5829" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="5837" class="Symbol">(</a><a id="5838" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="5846" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5819" class="Bound">xs</a> <a id="5849" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="5852" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5822" class="Bound">a</a><a id="5853" class="Symbol">)</a> <a id="5855" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="5858" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5824" class="Bound">ys</a> <a id="5861" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="5864" href="Data.Vec.Properties.html#36835" class="Function">∷ʳ-++</a> <a id="5870" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5816" class="Bound">eq</a> <a id="5873" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5822" class="Bound">a</a> <a id="5875" class="Symbol">(</a><a id="5876" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="5884" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5819" class="Bound">xs</a><a id="5886" class="Symbol">)</a> <a id="5888" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a> <a id="5890" class="Comment">-- index: suc m + n</a>
  <a id="5912" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="5920" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5819" class="Bound">xs</a> <a id="5923" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="5926" class="Symbol">(</a><a id="5927" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5822" class="Bound">a</a> <a id="5929" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="5931" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5824" class="Bound">ys</a><a id="5933" class="Symbol">)</a>  <a id="5936" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>                            <a id="5965" class="Comment">-- index: m + suc n</a>
  <a id="5987" class="Keyword">where</a> <a id="5993" class="Keyword">open</a> <a id="5998" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="6013" class="Comment">-- To interoperate with `_≡_`, this library provides `_≂⟨_⟩_` (\-~) for</a>
<a id="6085" class="Comment">-- taking a `_≡_` step during equational reasoning.</a>
<a id="6137" class="Comment">-- Let `≡-eqn : xs ≡ ys`, then</a>
<a id="6168" class="Comment">--     xs ≂⟨ ≡-eqn  ⟩    -- Takes a `_≡_` step; no change to the index</a>
<a id="6239" class="Comment">--     ys</a>
<a id="6249" class="Comment">--</a>
<a id="6252" class="Comment">--     ys ≂⟨ ≡-eqn ⟨    -- Takes a symmetric `_≡_` step</a>
<a id="6308" class="Comment">--     xs</a>
<a id="6318" class="Comment">-- Equivalently, `≈-reflexive` injects `_≡_` into `_≈[_]_`. That is,</a>
<a id="6387" class="Comment">-- `xs ≂⟨ ≡-eqn ⟩ ys` is the same as `xs ≈⟨ ≈-reflexive ≡-eqn ⟩ ys`.</a>
<a id="6456" class="Comment">-- Extending `example2a`, we have:</a>
<a id="example2b"></a><a id="6491" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6491" class="Function">example2b</a> <a id="6501" class="Symbol">:</a> <a id="6503" class="Symbol">∀</a> <a id="6505" class="Symbol">.(</a><a id="6507" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6507" class="Bound">eq</a> <a id="6510" class="Symbol">:</a> <a id="6512" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6516" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="6518" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="6520" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="6522" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6524" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="6526" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="6528" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6532" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="6533" class="Symbol">)</a> <a id="6535" class="Symbol">(</a><a id="6536" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6536" class="Bound">xs</a> <a id="6539" class="Symbol">:</a> <a id="6541" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="6545" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="6547" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a><a id="6548" class="Symbol">)</a> <a id="6550" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6550" class="Bound">a</a> <a id="6552" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6552" class="Bound">ys</a> <a id="6555" class="Symbol">→</a>
            <a id="6569" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="6574" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6507" class="Bound">eq</a> <a id="6577" class="Symbol">((</a><a id="6579" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6550" class="Bound">a</a> <a id="6581" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="6583" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6536" class="Bound">xs</a><a id="6585" class="Symbol">)</a> <a id="6587" href="Data.Vec.Base.html#8994" class="Function Operator">ʳ++</a> <a id="6591" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6552" class="Bound">ys</a><a id="6593" class="Symbol">)</a> <a id="6595" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6597" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6536" class="Bound">xs</a> <a id="6600" href="Data.Vec.Base.html#8994" class="Function Operator">ʳ++</a> <a id="6604" class="Symbol">(</a><a id="6605" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6550" class="Bound">a</a> <a id="6607" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="6609" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6552" class="Bound">ys</a><a id="6611" class="Symbol">)</a>
<a id="6613" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6491" class="Function">example2b</a> <a id="6623" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6623" class="Bound">eq</a> <a id="6626" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a> <a id="6629" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6631" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a> <a id="6634" class="Symbol">=</a> <a id="6636" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="6644" class="Symbol">(</a><a id="6645" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6647" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="6649" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a><a id="6651" class="Symbol">)</a> <a id="6653" href="Data.Vec.Base.html#8994" class="Function Operator">ʳ++</a> <a id="6657" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a>         <a id="6668" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">≂⟨</a> <a id="6671" href="Data.Vec.Properties.html#41474" class="Function">unfold-ʳ++</a> <a id="6682" class="Symbol">(</a><a id="6683" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6685" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="6687" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a><a id="6689" class="Symbol">)</a> <a id="6691" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a> <a id="6694" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">⟩</a>          <a id="6705" class="Comment">-- index: suc m + n</a>
  <a id="6727" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="6735" class="Symbol">(</a><a id="6736" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6738" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="6740" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a><a id="6742" class="Symbol">)</a> <a id="6744" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="6747" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a>  <a id="6751" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">≂⟨</a> <a id="6754" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="6759" class="Symbol">(</a><a id="6760" href="Data.Vec.Base.html#3071" class="Function Operator">_++</a> <a id="6764" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a><a id="6766" class="Symbol">)</a> <a id="6768" class="Symbol">(</a><a id="6769" href="Data.Vec.Properties.html#37215" class="Function">reverse-∷</a> <a id="6779" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a><a id="6783" class="Symbol">)</a> <a id="6785" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">⟩</a>  <a id="6788" class="Comment">-- index: suc m + n</a>
  <a id="6810" class="Symbol">(</a><a id="6811" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="6819" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a> <a id="6822" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="6825" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a><a id="6826" class="Symbol">)</a> <a id="6828" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="6831" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a> <a id="6834" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="6837" href="Data.Vec.Properties.html#36835" class="Function">∷ʳ-++</a> <a id="6843" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6623" class="Bound">eq</a> <a id="6846" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6848" class="Symbol">(</a><a id="6849" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="6857" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a><a id="6859" class="Symbol">)</a> <a id="6861" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>         <a id="6871" class="Comment">-- index: suc m + n</a>
  <a id="6893" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="6901" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a> <a id="6904" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="6907" class="Symbol">(</a><a id="6908" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6910" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="6912" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a><a id="6914" class="Symbol">)</a>  <a id="6917" href="Data.Vec.Relation.Binary.Equality.Cast.html#4137" class="Function">≂⟨</a> <a id="6920" href="Data.Vec.Properties.html#41474" class="Function">unfold-ʳ++</a> <a id="6931" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a> <a id="6934" class="Symbol">(</a><a id="6935" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6937" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="6939" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a><a id="6941" class="Symbol">)</a> <a id="6943" href="Data.Vec.Relation.Binary.Equality.Cast.html#4137" class="Function">⟨</a>          <a id="6954" class="Comment">-- index: m + suc n</a>
  <a id="6976" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6626" class="Bound">xs</a> <a id="6979" href="Data.Vec.Base.html#8994" class="Function Operator">ʳ++</a> <a id="6983" class="Symbol">(</a><a id="6984" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6629" class="Bound">a</a> <a id="6986" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="6988" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6631" class="Bound">ys</a><a id="6990" class="Symbol">)</a>         <a id="7000" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>                                    <a id="7037" class="Comment">-- index: m + suc n</a>
  <a id="7059" class="Keyword">where</a> <a id="7065" class="Keyword">open</a> <a id="7070" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="7085" class="Comment">-- Oftentimes index-changing identities apply to only part of the proof</a>
<a id="7157" class="Comment">-- term. When reasoning about `_≡_`, `cong` shifts the focus to the</a>
<a id="7225" class="Comment">-- subterm of interest. In this library, `≈-cong` does a similar job.</a>
<a id="7295" class="Comment">-- Suppose `f : A → B`, `xs : B`, `ys zs : A`, `ys≈zs : ys ≈[ _ ] zs`</a>
<a id="7365" class="Comment">-- and `xs≈f⟨c·ys⟩ : xs ≈[ _ ] f (cast _ ys)`, we have</a>
<a id="7420" class="Comment">--     xs ≈⟨ ≈-cong f xs≈f⟨c·ys⟩ ys≈zs ⟩</a>
<a id="7461" class="Comment">--     f zs</a>
<a id="7473" class="Comment">-- The reason for having the extra argument `xs≈f⟨c·ys⟩` is to expose</a>
<a id="7543" class="Comment">-- `cast` in the subterm in order to apply the step `ys≈zs`. When using</a>
<a id="7615" class="Comment">-- ordinary `cong` the proof has to explicitly push `cast` inside:</a>
<a id="7682" class="Comment">--     xs            ≈⟨ xs≈f⟨c·ys⟩ ⟩</a>
<a id="7719" class="Comment">--     f (cast _ ys) ≂⟨ cong f ys≈zs ⟩</a>
<a id="7758" class="Comment">--     f zs</a>
<a id="7770" class="Comment">-- Note. Technically, `A` and `B` should be vectors of different length</a>
<a id="7842" class="Comment">-- and that `ys`, `zs` are vectors of non-definitionally equal index.</a>
<a id="example3a-fromList-++-++"></a><a id="7912" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7912" class="Function">example3a-fromList-++-++</a> <a id="7937" class="Symbol">:</a> <a id="7939" class="Symbol">{</a><a id="7940" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7940" class="Bound">xs</a> <a id="7943" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7943" class="Bound">ys</a> <a id="7946" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7946" class="Bound">zs</a> <a id="7949" class="Symbol">:</a> <a id="7951" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="7956" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="7957" class="Symbol">}</a> <a id="7959" class="Symbol">→</a>
                           <a id="7988" class="Symbol">.(</a><a id="7990" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7990" class="Bound">eq</a> <a id="7993" class="Symbol">:</a> <a id="7995" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="8007" class="Symbol">(</a><a id="8008" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7940" class="Bound">xs</a> <a id="8011" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8019" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7943" class="Bound">ys</a> <a id="8022" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8030" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7946" class="Bound">zs</a><a id="8032" class="Symbol">)</a> <a id="8034" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                  <a id="8070" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="8082" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7940" class="Bound">xs</a> <a id="8085" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8087" class="Symbol">(</a><a id="8088" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="8100" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7943" class="Bound">ys</a> <a id="8103" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8105" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="8117" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7946" class="Bound">zs</a><a id="8119" class="Symbol">))</a> <a id="8122" class="Symbol">→</a>
                           <a id="8151" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="8156" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7990" class="Bound">eq</a> <a id="8159" class="Symbol">(</a><a id="8160" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8169" class="Symbol">(</a><a id="8170" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7940" class="Bound">xs</a> <a id="8173" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8181" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7943" class="Bound">ys</a> <a id="8184" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8192" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7946" class="Bound">zs</a><a id="8194" class="Symbol">))</a> <a id="8197" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="8234" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8243" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7940" class="Bound">xs</a> <a id="8246" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="8249" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8258" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7943" class="Bound">ys</a> <a id="8261" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="8264" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8273" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7946" class="Bound">zs</a>
<a id="8276" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7912" class="Function">example3a-fromList-++-++</a> <a id="8301" class="Symbol">{</a><a id="8302" class="Argument">xs</a> <a id="8305" class="Symbol">=</a> <a id="8307" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8307" class="Bound">xs</a><a id="8309" class="Symbol">}</a> <a id="8311" class="Symbol">{</a><a id="8312" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8312" class="Bound">ys</a><a id="8314" class="Symbol">}</a> <a id="8316" class="Symbol">{</a><a id="8317" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8317" class="Bound">zs</a><a id="8319" class="Symbol">}</a> <a id="8321" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8321" class="Bound">eq</a> <a id="8324" class="Symbol">=</a> <a id="8326" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="8334" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8343" class="Symbol">(</a><a id="8344" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8307" class="Bound">xs</a> <a id="8347" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8355" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8312" class="Bound">ys</a> <a id="8358" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8366" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8317" class="Bound">zs</a><a id="8368" class="Symbol">)</a>
    <a id="8374" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="8377" href="Data.Vec.Properties.html#53408" class="Function">fromList-++</a> <a id="8389" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8307" class="Bound">xs</a> <a id="8392" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="8396" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8405" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8307" class="Bound">xs</a> <a id="8408" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="8411" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8420" class="Symbol">(</a><a id="8421" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8312" class="Bound">ys</a> <a id="8424" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8432" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8317" class="Bound">zs</a><a id="8434" class="Symbol">)</a>
    <a id="8440" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="8443" href="Data.Vec.Relation.Binary.Equality.Cast.html#4380" class="Function">≈-cong</a> <a id="8450" class="Symbol">(</a><a id="8451" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8460" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8307" class="Bound">xs</a> <a id="8463" href="Data.Vec.Base.html#3071" class="Function Operator">++_</a><a id="8466" class="Symbol">)</a> <a id="8468" class="Symbol">(</a><a id="8469" href="Data.Vec.Properties.html#19324" class="Function">cast-++ʳ</a> <a id="8478" class="Symbol">(</a><a id="8479" href="Data.List.Properties.html#5523" class="Function">List.length-++</a> <a id="8494" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8312" class="Bound">ys</a><a id="8496" class="Symbol">)</a> <a id="8498" class="Symbol">(</a><a id="8499" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8508" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8307" class="Bound">xs</a><a id="8510" class="Symbol">))</a> <a id="8513" class="Symbol">(</a><a id="8514" href="Data.Vec.Properties.html#53408" class="Function">fromList-++</a> <a id="8526" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8312" class="Bound">ys</a><a id="8528" class="Symbol">)</a> <a id="8530" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="8534" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8543" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8307" class="Bound">xs</a> <a id="8546" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="8549" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8558" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8312" class="Bound">ys</a> <a id="8561" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="8564" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="8573" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8317" class="Bound">zs</a>
    <a id="8580" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="8584" class="Keyword">where</a> <a id="8590" class="Keyword">open</a> <a id="8595" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="8610" class="Comment">-- As an alternative, one can manually apply `cast-++ʳ` to expose `cast`</a>
<a id="8683" class="Comment">-- in the subterm. However, this unavoidably duplicates the proof term.</a>
<a id="example3b-fromList-++-++′"></a><a id="8755" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8755" class="Function">example3b-fromList-++-++′</a> <a id="8781" class="Symbol">:</a> <a id="8783" class="Symbol">{</a><a id="8784" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8784" class="Bound">xs</a> <a id="8787" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8787" class="Bound">ys</a> <a id="8790" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8790" class="Bound">zs</a> <a id="8793" class="Symbol">:</a> <a id="8795" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="8800" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="8801" class="Symbol">}</a> <a id="8803" class="Symbol">→</a>
                            <a id="8833" class="Symbol">.(</a><a id="8835" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8835" class="Bound">eq</a> <a id="8838" class="Symbol">:</a> <a id="8840" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="8852" class="Symbol">(</a><a id="8853" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8784" class="Bound">xs</a> <a id="8856" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8864" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8787" class="Bound">ys</a> <a id="8867" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="8875" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8790" class="Bound">zs</a><a id="8877" class="Symbol">)</a> <a id="8879" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="8916" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="8928" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8784" class="Bound">xs</a> <a id="8931" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8933" class="Symbol">(</a><a id="8934" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="8946" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8787" class="Bound">ys</a> <a id="8949" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8951" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="8963" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8790" class="Bound">zs</a><a id="8965" class="Symbol">))</a> <a id="8968" class="Symbol">→</a>
                            <a id="8998" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="9003" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8835" class="Bound">eq</a> <a id="9006" class="Symbol">(</a><a id="9007" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9016" class="Symbol">(</a><a id="9017" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8784" class="Bound">xs</a> <a id="9020" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="9028" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8787" class="Bound">ys</a> <a id="9031" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="9039" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8790" class="Bound">zs</a><a id="9041" class="Symbol">))</a> <a id="9044" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                    <a id="9082" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9091" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8784" class="Bound">xs</a> <a id="9094" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9097" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9106" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8787" class="Bound">ys</a> <a id="9109" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9112" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9121" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8790" class="Bound">zs</a>
<a id="9124" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8755" class="Function">example3b-fromList-++-++′</a> <a id="9150" class="Symbol">{</a><a id="9151" class="Argument">xs</a> <a id="9154" class="Symbol">=</a> <a id="9156" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9156" class="Bound">xs</a><a id="9158" class="Symbol">}</a> <a id="9160" class="Symbol">{</a><a id="9161" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9161" class="Bound">ys</a><a id="9163" class="Symbol">}</a> <a id="9165" class="Symbol">{</a><a id="9166" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9166" class="Bound">zs</a><a id="9168" class="Symbol">}</a> <a id="9170" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9170" class="Bound">eq</a> <a id="9173" class="Symbol">=</a> <a id="9175" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="9183" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9192" class="Symbol">(</a><a id="9193" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9156" class="Bound">xs</a> <a id="9196" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="9204" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9161" class="Bound">ys</a> <a id="9207" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="9215" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9166" class="Bound">zs</a><a id="9217" class="Symbol">)</a>
    <a id="9223" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="9226" href="Data.Vec.Properties.html#53408" class="Function">fromList-++</a> <a id="9238" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9156" class="Bound">xs</a> <a id="9241" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="9245" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9254" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9156" class="Bound">xs</a> <a id="9257" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9260" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9269" class="Symbol">(</a><a id="9270" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9161" class="Bound">ys</a> <a id="9273" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="9281" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9166" class="Bound">zs</a><a id="9283" class="Symbol">)</a>
    <a id="9289" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="9292" href="Data.Vec.Properties.html#19324" class="Function">cast-++ʳ</a> <a id="9301" class="Symbol">(</a><a id="9302" href="Data.List.Properties.html#5523" class="Function">List.length-++</a> <a id="9317" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9161" class="Bound">ys</a><a id="9319" class="Symbol">)</a> <a id="9321" class="Symbol">(</a><a id="9322" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9331" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9156" class="Bound">xs</a><a id="9333" class="Symbol">)</a> <a id="9335" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="9339" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9348" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9156" class="Bound">xs</a> <a id="9351" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9354" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="9359" class="Symbol">_</a> <a id="9361" class="Symbol">(</a><a id="9362" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9371" class="Symbol">(</a><a id="9372" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9161" class="Bound">ys</a> <a id="9375" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="9383" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9166" class="Bound">zs</a><a id="9385" class="Symbol">))</a>
    <a id="9392" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">≂⟨</a> <a id="9395" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="9400" class="Symbol">(</a><a id="9401" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9410" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9156" class="Bound">xs</a> <a id="9413" href="Data.Vec.Base.html#3071" class="Function Operator">++_</a><a id="9416" class="Symbol">)</a> <a id="9418" class="Symbol">(</a><a id="9419" href="Data.Vec.Properties.html#53408" class="Function">fromList-++</a> <a id="9431" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9161" class="Bound">ys</a><a id="9433" class="Symbol">)</a> <a id="9435" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">⟩</a>
  <a id="9439" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9448" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9156" class="Bound">xs</a> <a id="9451" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9454" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9463" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9161" class="Bound">ys</a> <a id="9466" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9469" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="9478" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9166" class="Bound">zs</a>
    <a id="9485" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="9489" class="Keyword">where</a> <a id="9495" class="Keyword">open</a> <a id="9500" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="9515" class="Comment">-- `≈-cong` can be chained together much like how `cong` can be nested.</a>
<a id="9587" class="Comment">-- In this example, `unfold-∷ʳ` is applied to the term `xs ++ [ a ]`</a>
<a id="9656" class="Comment">-- in `(_++ ys)` inside of `reverse`. Thus the proof employs two</a>
<a id="9721" class="Comment">-- `≈-cong`.</a>
<a id="example4-cong²"></a><a id="9734" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9734" class="Function">example4-cong²</a> <a id="9749" class="Symbol">:</a> <a id="9751" class="Symbol">∀</a> <a id="9753" class="Symbol">.(</a><a id="9755" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9755" class="Bound">eq</a> <a id="9758" class="Symbol">:</a> <a id="9760" class="Symbol">(</a><a id="9761" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="9763" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9765" class="Number">1</a><a id="9766" class="Symbol">)</a> <a id="9768" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9770" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="9772" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9774" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="9776" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9778" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9782" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a><a id="9783" class="Symbol">)</a> <a id="9785" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9785" class="Bound">a</a> <a id="9787" class="Symbol">(</a><a id="9788" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9788" class="Bound">xs</a> <a id="9791" class="Symbol">:</a> <a id="9793" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="9797" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="9799" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a><a id="9800" class="Symbol">)</a> <a id="9802" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9802" class="Bound">ys</a> <a id="9805" class="Symbol">→</a>
          <a id="9817" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="9822" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9755" class="Bound">eq</a> <a id="9825" class="Symbol">(</a><a id="9826" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="9834" class="Symbol">((</a><a id="9836" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9788" class="Bound">xs</a> <a id="9839" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9842" href="Data.Vec.Base.html#6481" class="Function Operator">[</a> <a id="9844" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9785" class="Bound">a</a> <a id="9846" href="Data.Vec.Base.html#6481" class="Function Operator">]</a><a id="9847" class="Symbol">)</a> <a id="9849" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9852" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9802" class="Bound">ys</a><a id="9854" class="Symbol">))</a> <a id="9857" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9859" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9802" class="Bound">ys</a> <a id="9862" href="Data.Vec.Base.html#8994" class="Function Operator">ʳ++</a> <a id="9866" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="9874" class="Symbol">(</a><a id="9875" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9788" class="Bound">xs</a> <a id="9878" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="9881" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9785" class="Bound">a</a><a id="9882" class="Symbol">)</a>
<a id="9884" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9734" class="Function">example4-cong²</a> <a id="9899" class="Symbol">{</a><a id="9900" class="Argument">m</a> <a id="9902" class="Symbol">=</a> <a id="9904" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9904" class="Bound">m</a><a id="9905" class="Symbol">}</a> <a id="9907" class="Symbol">{</a><a id="9908" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9908" class="Bound">n</a><a id="9909" class="Symbol">}</a> <a id="9911" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9911" class="Bound">eq</a> <a id="9914" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a> <a id="9916" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="9919" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a> <a id="9922" class="Symbol">=</a> <a id="9924" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="9932" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="9940" class="Symbol">((</a><a id="9942" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="9945" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9948" href="Data.Vec.Base.html#6481" class="Function Operator">[</a> <a id="9950" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a> <a id="9952" href="Data.Vec.Base.html#6481" class="Function Operator">]</a><a id="9953" class="Symbol">)</a> <a id="9955" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="9958" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a><a id="9960" class="Symbol">)</a>
    <a id="9966" href="Data.Vec.Relation.Binary.Equality.Cast.html#3258" class="Function">≈⟨</a> <a id="9969" href="Data.Vec.Relation.Binary.Equality.Cast.html#4380" class="Function">≈-cong</a> <a id="9976" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="9984" class="Symbol">(</a><a id="9985" href="Data.Vec.Properties.html#40813" class="Function">cast-reverse</a> <a id="9998" class="Symbol">(</a><a id="9999" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="10004" class="Symbol">(</a><a id="10005" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">_+</a> <a id="10008" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9908" class="Bound">n</a><a id="10009" class="Symbol">)</a> <a id="10011" class="Symbol">(</a><a id="10012" href="Data.Nat.Properties.html#14888" class="Function">+-comm</a> <a id="10019" class="Number">1</a> <a id="10021" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9904" class="Bound">m</a><a id="10022" class="Symbol">))</a> <a id="10025" class="Symbol">((</a><a id="10027" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="10030" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="10033" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a><a id="10034" class="Symbol">)</a> <a id="10036" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="10039" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a><a id="10041" class="Symbol">))</a>
                                             <a id="10089" class="Symbol">(</a><a id="10090" href="Data.Vec.Relation.Binary.Equality.Cast.html#4380" class="Function">≈-cong</a> <a id="10097" class="Symbol">(</a><a id="10098" href="Data.Vec.Base.html#3071" class="Function Operator">_++</a> <a id="10102" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a><a id="10104" class="Symbol">)</a> <a id="10106" class="Symbol">(</a><a id="10107" href="Data.Vec.Properties.html#19045" class="Function">cast-++ˡ</a> <a id="10116" class="Symbol">(</a><a id="10117" href="Data.Nat.Properties.html#14888" class="Function">+-comm</a> <a id="10124" class="Number">1</a> <a id="10126" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9904" class="Bound">m</a><a id="10127" class="Symbol">)</a> <a id="10129" class="Symbol">(</a><a id="10130" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="10133" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="10136" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a><a id="10137" class="Symbol">))</a>
                                                     <a id="10193" class="Symbol">(</a><a id="10194" href="Data.Vec.Properties.html#34664" class="Function">unfold-∷ʳ</a> <a id="10204" class="Symbol">_</a> <a id="10206" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a> <a id="10208" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a><a id="10210" class="Symbol">))</a> <a id="10213" href="Data.Vec.Relation.Binary.Equality.Cast.html#3258" class="Function">⟨</a>
  <a id="10217" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="10225" class="Symbol">((</a><a id="10227" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="10230" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="10233" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a><a id="10234" class="Symbol">)</a> <a id="10236" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="10239" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a><a id="10241" class="Symbol">)</a>
    <a id="10247" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="10250" href="Data.Vec.Properties.html#40035" class="Function">reverse-++</a> <a id="10261" class="Symbol">(</a><a id="10262" href="Data.Nat.Properties.html#14888" class="Function">+-comm</a> <a id="10269" class="Symbol">(</a><a id="10270" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10274" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9904" class="Bound">m</a><a id="10275" class="Symbol">)</a> <a id="10277" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9908" class="Bound">n</a><a id="10278" class="Symbol">)</a> <a id="10280" class="Symbol">(</a><a id="10281" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="10284" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="10287" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a><a id="10288" class="Symbol">)</a> <a id="10290" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a> <a id="10293" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="10297" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="10305" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a> <a id="10308" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="10311" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="10319" class="Symbol">(</a><a id="10320" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="10323" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="10326" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a><a id="10327" class="Symbol">)</a>
    <a id="10333" href="Data.Vec.Relation.Binary.Equality.Cast.html#4137" class="Function">≂⟨</a> <a id="10336" href="Data.Vec.Properties.html#41474" class="Function">unfold-ʳ++</a> <a id="10347" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a> <a id="10350" class="Symbol">(</a><a id="10351" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="10359" class="Symbol">(</a><a id="10360" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="10363" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="10366" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a><a id="10367" class="Symbol">))</a> <a id="10370" href="Data.Vec.Relation.Binary.Equality.Cast.html#4137" class="Function">⟨</a>
  <a id="10374" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9919" class="Bound">ys</a> <a id="10377" href="Data.Vec.Base.html#8994" class="Function Operator">ʳ++</a> <a id="10381" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="10389" class="Symbol">(</a><a id="10390" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9916" class="Bound">xs</a> <a id="10393" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="10396" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9914" class="Bound">a</a><a id="10397" class="Symbol">)</a>
    <a id="10403" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="10407" class="Keyword">where</a> <a id="10413" class="Keyword">open</a> <a id="10418" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="10433" class="Comment">------------------------------------------------------------------------</a>
<a id="10506" class="Comment">-- Interoperation between `_≈[_]_` and `_≡_`</a>
<a id="10551" class="Comment">--</a>
<a id="10554" class="Comment">-- This library is designed to interoperate with `_≡_`. Examples in the</a>
<a id="10626" class="Comment">-- combinators section showed how to apply `_≂⟨_⟩_` to take an `_≡_`</a>
<a id="10695" class="Comment">-- step during equational reasoning about `_≈[_]_`. Recall that</a>
<a id="10759" class="Comment">-- `xs ≈[ m≡n ] ys` is a shorthand for `cast m≡n xs ≡ ys`, the</a>
<a id="10822" class="Comment">-- combinator is essentially the composition of `_≡_` on the left-hand</a>
<a id="10893" class="Comment">-- side of `_≈[_]_`. Dually, the combinator `_≃⟨_⟩_` composes `_≡_` on</a>
<a id="10964" class="Comment">-- the right-hand side of `_≈[_]_`. Thus `_≃⟨_⟩_` intuitively ends the</a>
<a id="11035" class="Comment">-- reasoning system of `_≈[_]_` and switches back to the reasoning</a>
<a id="11102" class="Comment">-- system of `_≡_`.</a>
<a id="example5-fromList-++-++′"></a><a id="11122" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11122" class="Function">example5-fromList-++-++′</a> <a id="11147" class="Symbol">:</a> <a id="11149" class="Symbol">{</a><a id="11150" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11150" class="Bound">xs</a> <a id="11153" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11153" class="Bound">ys</a> <a id="11156" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11156" class="Bound">zs</a> <a id="11159" class="Symbol">:</a> <a id="11161" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="11166" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="11167" class="Symbol">}</a> <a id="11169" class="Symbol">→</a>
                           <a id="11198" class="Symbol">.(</a><a id="11200" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11200" class="Bound">eq</a> <a id="11203" class="Symbol">:</a> <a id="11205" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="11217" class="Symbol">(</a><a id="11218" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11150" class="Bound">xs</a> <a id="11221" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="11229" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11153" class="Bound">ys</a> <a id="11232" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="11240" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11156" class="Bound">zs</a><a id="11242" class="Symbol">)</a> <a id="11244" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                  <a id="11280" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="11292" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11150" class="Bound">xs</a> <a id="11295" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="11297" class="Symbol">(</a><a id="11298" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="11310" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11153" class="Bound">ys</a> <a id="11313" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="11315" href="Data.List.Base.html#5098" class="Function">List.length</a> <a id="11327" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11156" class="Bound">zs</a><a id="11329" class="Symbol">))</a> <a id="11332" class="Symbol">→</a>
                           <a id="11361" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="11366" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11200" class="Bound">eq</a> <a id="11369" class="Symbol">(</a><a id="11370" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11379" class="Symbol">(</a><a id="11380" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11150" class="Bound">xs</a> <a id="11383" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="11391" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11153" class="Bound">ys</a> <a id="11394" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="11402" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11156" class="Bound">zs</a><a id="11404" class="Symbol">))</a> <a id="11407" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="11444" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11453" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11150" class="Bound">xs</a> <a id="11456" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="11459" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11468" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11153" class="Bound">ys</a> <a id="11471" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="11474" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11483" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11156" class="Bound">zs</a>
<a id="11486" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11122" class="Function">example5-fromList-++-++′</a> <a id="11511" class="Symbol">{</a><a id="11512" class="Argument">xs</a> <a id="11515" class="Symbol">=</a> <a id="11517" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11517" class="Bound">xs</a><a id="11519" class="Symbol">}</a> <a id="11521" class="Symbol">{</a><a id="11522" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11522" class="Bound">ys</a><a id="11524" class="Symbol">}</a> <a id="11526" class="Symbol">{</a><a id="11527" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11527" class="Bound">zs</a><a id="11529" class="Symbol">}</a> <a id="11531" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11531" class="Bound">eq</a> <a id="11534" class="Symbol">=</a> <a id="11536" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="11544" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11553" class="Symbol">(</a><a id="11554" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11517" class="Bound">xs</a> <a id="11557" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="11565" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11522" class="Bound">ys</a> <a id="11568" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="11576" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11527" class="Bound">zs</a><a id="11578" class="Symbol">)</a>
    <a id="11584" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="11587" href="Data.Vec.Properties.html#53408" class="Function">fromList-++</a> <a id="11599" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11517" class="Bound">xs</a> <a id="11602" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="11606" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11615" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11517" class="Bound">xs</a> <a id="11618" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="11621" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11630" class="Symbol">(</a><a id="11631" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11522" class="Bound">ys</a> <a id="11634" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="11642" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11527" class="Bound">zs</a><a id="11644" class="Symbol">)</a>
    <a id="11650" href="Data.Vec.Relation.Binary.Equality.Cast.html#3585" class="Function">≃⟨</a> <a id="11653" href="Data.Vec.Properties.html#19324" class="Function">cast-++ʳ</a> <a id="11662" class="Symbol">(</a><a id="11663" href="Data.List.Properties.html#5523" class="Function">List.length-++</a> <a id="11678" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11522" class="Bound">ys</a><a id="11680" class="Symbol">)</a> <a id="11682" class="Symbol">(</a><a id="11683" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11692" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11517" class="Bound">xs</a><a id="11694" class="Symbol">)</a> <a id="11696" href="Data.Vec.Relation.Binary.Equality.Cast.html#3585" class="Function">⟩</a>
  <a id="11700" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11709" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11517" class="Bound">xs</a> <a id="11712" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="11715" href="Data.Vec.Base.html#2816" class="Function">cast</a> <a id="11720" class="Symbol">_</a> <a id="11722" class="Symbol">(</a><a id="11723" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11732" class="Symbol">(</a><a id="11733" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11522" class="Bound">ys</a> <a id="11736" href="Data.List.Base.html#1957" class="Function Operator">List.++</a> <a id="11744" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11527" class="Bound">zs</a><a id="11746" class="Symbol">))</a>
    <a id="11753" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="11756" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="11761" class="Symbol">(</a><a id="11762" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11771" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11517" class="Bound">xs</a> <a id="11774" href="Data.Vec.Base.html#3071" class="Function Operator">++_</a><a id="11777" class="Symbol">)</a> <a id="11779" class="Symbol">(</a><a id="11780" href="Data.Vec.Properties.html#53408" class="Function">fromList-++</a> <a id="11792" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11522" class="Bound">ys</a><a id="11794" class="Symbol">)</a> <a id="11796" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="11800" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11809" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11517" class="Bound">xs</a> <a id="11812" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="11815" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11824" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11522" class="Bound">ys</a> <a id="11827" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="11830" href="Data.Vec.Base.html#8518" class="Function">fromList</a> <a id="11839" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11527" class="Bound">zs</a>
    <a id="11846" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">≡-∎</a>
  <a id="11852" class="Keyword">where</a> <a id="11858" class="Keyword">open</a> <a id="11863" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="11878" class="Comment">-- Of course, it is possible to start with the reasoning system of `_≡_`</a>
<a id="11951" class="Comment">-- and then switch to the reasoning system of `_≈[_]_`.</a>
<a id="example6a-reverse-∷ʳ"></a><a id="12007" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12007" class="Function">example6a-reverse-∷ʳ</a> <a id="12028" class="Symbol">:</a> <a id="12030" class="Symbol">∀</a> <a id="12032" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12032" class="Bound">x</a> <a id="12034" class="Symbol">(</a><a id="12035" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12035" class="Bound">xs</a> <a id="12038" class="Symbol">:</a> <a id="12040" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="12044" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="12046" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="12047" class="Symbol">)</a> <a id="12049" class="Symbol">→</a> <a id="12051" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12059" class="Symbol">(</a><a id="12060" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12035" class="Bound">xs</a> <a id="12063" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12066" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12032" class="Bound">x</a><a id="12067" class="Symbol">)</a> <a id="12069" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12071" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12032" class="Bound">x</a> <a id="12073" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12075" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12083" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12035" class="Bound">xs</a>
<a id="12086" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12007" class="Function">example6a-reverse-∷ʳ</a> <a id="12107" class="Symbol">{</a><a id="12108" class="Argument">n</a> <a id="12110" class="Symbol">=</a> <a id="12112" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12112" class="Bound">n</a><a id="12113" class="Symbol">}</a> <a id="12115" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12115" class="Bound">x</a> <a id="12117" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12117" class="Bound">xs</a> <a id="12120" class="Symbol">=</a> <a id="12122" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin-≡</a>
  <a id="12132" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12140" class="Symbol">(</a><a id="12141" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12117" class="Bound">xs</a> <a id="12144" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12147" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12115" class="Bound">x</a><a id="12148" class="Symbol">)</a>
    <a id="12154" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="12157" href="Data.Vec.Relation.Binary.Equality.Cast.html#1703" class="Function">≈-reflexive</a> <a id="12169" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="12174" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="12178" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12186" class="Symbol">(</a><a id="12187" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12117" class="Bound">xs</a> <a id="12190" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12193" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12115" class="Bound">x</a><a id="12194" class="Symbol">)</a>
    <a id="12200" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="12203" href="Data.Vec.Relation.Binary.Equality.Cast.html#4380" class="Function">≈-cong</a> <a id="12210" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12218" class="Symbol">(</a><a id="12219" href="Data.Vec.Properties.html#40813" class="Function">cast-reverse</a> <a id="12232" class="Symbol">_</a> <a id="12234" class="Symbol">_)</a> <a id="12237" class="Symbol">(</a><a id="12238" href="Data.Vec.Properties.html#34664" class="Function">unfold-∷ʳ</a> <a id="12248" class="Symbol">(</a><a id="12249" href="Data.Nat.Properties.html#14888" class="Function">+-comm</a> <a id="12256" class="Number">1</a> <a id="12258" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12112" class="Bound">n</a><a id="12259" class="Symbol">)</a> <a id="12261" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12115" class="Bound">x</a> <a id="12263" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12117" class="Bound">xs</a><a id="12265" class="Symbol">)</a> <a id="12267" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="12271" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12279" class="Symbol">(</a><a id="12280" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12117" class="Bound">xs</a> <a id="12283" href="Data.Vec.Base.html#3071" class="Function Operator">++</a> <a id="12286" href="Data.Vec.Base.html#6481" class="Function Operator">[</a> <a id="12288" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12115" class="Bound">x</a> <a id="12290" href="Data.Vec.Base.html#6481" class="Function Operator">]</a><a id="12291" class="Symbol">)</a>
    <a id="12297" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="12300" href="Data.Vec.Properties.html#40035" class="Function">reverse-++</a> <a id="12311" class="Symbol">(</a><a id="12312" href="Data.Nat.Properties.html#14888" class="Function">+-comm</a> <a id="12319" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12112" class="Bound">n</a> <a id="12321" class="Number">1</a><a id="12322" class="Symbol">)</a> <a id="12324" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12117" class="Bound">xs</a> <a id="12327" href="Data.Vec.Base.html#6481" class="Function Operator">[</a> <a id="12329" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12115" class="Bound">x</a> <a id="12331" href="Data.Vec.Base.html#6481" class="Function Operator">]</a> <a id="12333" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="12337" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12115" class="Bound">x</a> <a id="12339" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12341" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12349" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12117" class="Bound">xs</a>
    <a id="12356" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="12360" class="Keyword">where</a> <a id="12366" class="Keyword">open</a> <a id="12371" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="example6b-reverse-∷ʳ-by-induction"></a><a id="12386" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12386" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12420" class="Symbol">:</a> <a id="12422" class="Symbol">∀</a> <a id="12424" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12424" class="Bound">x</a> <a id="12426" class="Symbol">(</a><a id="12427" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12427" class="Bound">xs</a> <a id="12430" class="Symbol">:</a> <a id="12432" href="Data.Vec.Base.html#1114" class="Datatype">Vec</a> <a id="12436" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="12438" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="12439" class="Symbol">)</a> <a id="12441" class="Symbol">→</a> <a id="12443" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12451" class="Symbol">(</a><a id="12452" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12427" class="Bound">xs</a> <a id="12455" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12458" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12424" class="Bound">x</a><a id="12459" class="Symbol">)</a> <a id="12461" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12463" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12424" class="Bound">x</a> <a id="12465" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12467" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12475" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12427" class="Bound">xs</a>
<a id="12478" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12386" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12512" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12512" class="Bound">x</a> <a id="12514" href="Data.Vec.Base.html#1150" class="InductiveConstructor">[]</a>       <a id="12523" class="Symbol">=</a> <a id="12525" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="12530" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12386" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12564" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a> <a id="12566" class="Symbol">(</a><a id="12567" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a> <a id="12569" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12571" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a><a id="12573" class="Symbol">)</a> <a id="12575" class="Symbol">=</a> <a id="12577" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="12585" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12593" class="Symbol">(</a><a id="12594" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a> <a id="12596" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12598" class="Symbol">(</a><a id="12599" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a> <a id="12602" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12605" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a><a id="12606" class="Symbol">))</a> <a id="12609" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="12612" href="Data.Vec.Properties.html#37215" class="Function">reverse-∷</a> <a id="12622" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a> <a id="12624" class="Symbol">(</a><a id="12625" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a> <a id="12628" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12631" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a><a id="12632" class="Symbol">)</a> <a id="12634" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="12638" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12646" class="Symbol">(</a><a id="12647" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a> <a id="12650" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12653" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a><a id="12654" class="Symbol">)</a> <a id="12656" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12659" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a>  <a id="12662" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="12665" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="12670" class="Symbol">(</a><a id="12671" href="Data.Vec.Base.html#8776" class="Function Operator">_∷ʳ</a> <a id="12675" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a><a id="12676" class="Symbol">)</a> <a id="12678" class="Symbol">(</a><a id="12679" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12386" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12713" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a> <a id="12715" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a><a id="12717" class="Symbol">)</a> <a id="12719" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="12723" class="Symbol">(</a><a id="12724" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a> <a id="12726" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12728" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12736" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a><a id="12738" class="Symbol">)</a> <a id="12740" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12743" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a>   <a id="12747" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
  <a id="12753" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a> <a id="12755" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12757" class="Symbol">(</a><a id="12758" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12766" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a> <a id="12769" href="Data.Vec.Base.html#8776" class="Function Operator">∷ʳ</a> <a id="12772" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a><a id="12773" class="Symbol">)</a>   <a id="12777" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="12780" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="12785" class="Symbol">(</a><a id="12786" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a> <a id="12788" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷_</a><a id="12790" class="Symbol">)</a> <a id="12792" class="Symbol">(</a><a id="12793" href="Data.Vec.Properties.html#37215" class="Function">reverse-∷</a> <a id="12803" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a> <a id="12805" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a><a id="12807" class="Symbol">)</a> <a id="12809" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="12813" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12564" class="Bound">x</a> <a id="12815" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12817" href="Data.Vec.Base.html#8884" class="Function">reverse</a> <a id="12825" class="Symbol">(</a><a id="12826" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12567" class="Bound">y</a> <a id="12828" href="Data.Vec.Base.html#1169" class="InductiveConstructor Operator">∷</a> <a id="12830" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12571" class="Bound">xs</a><a id="12832" class="Symbol">)</a>    <a id="12837" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
  <a id="12841" class="Keyword">where</a> <a id="12847" class="Keyword">open</a> <a id="12852" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
</pre></body></html>