<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Vec.Relation.Binary.Equality.Cast</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- An equational reasoning library for propositional equality over</a>
<a id="173" class="Comment">-- vectors of different indices using cast.</a>
<a id="217" class="Comment">--</a>
<a id="220" class="Comment">-- To see example usages of this library, scroll to the `Combinators`</a>
<a id="290" class="Comment">-- section.</a>
<a id="302" class="Comment">------------------------------------------------------------------------</a>

<a id="376" class="Symbol">{-#</a> <a id="380" class="Keyword">OPTIONS</a> <a id="388" class="Pragma">--cubical-compatible</a> <a id="409" class="Pragma">--safe</a> <a id="416" class="Symbol">#-}</a>

<a id="421" class="Keyword">module</a> <a id="428" href="README.Data.Vec.Relation.Binary.Equality.Cast.html" class="Module">README.Data.Vec.Relation.Binary.Equality.Cast</a> <a id="474" class="Keyword">where</a>

<a id="481" class="Keyword">open</a> <a id="486" class="Keyword">import</a> <a id="493" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>
<a id="508" class="Keyword">open</a> <a id="513" class="Keyword">import</a> <a id="520" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="535" class="Symbol">as</a> <a id="538" class="Module">List</a> <a id="543" class="Keyword">using</a> <a id="549" class="Symbol">(</a><a id="550" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="554" class="Symbol">)</a>
<a id="556" class="Keyword">import</a> <a id="563" href="Data.List.Properties.html" class="Module">Data.List.Properties</a> <a id="584" class="Symbol">as</a> <a id="587" class="Module">List</a>
<a id="592" class="Keyword">open</a> <a id="597" class="Keyword">import</a> <a id="604" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="618" class="Keyword">open</a> <a id="623" class="Keyword">import</a> <a id="630" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="650" class="Keyword">open</a> <a id="655" class="Keyword">import</a> <a id="662" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>
<a id="676" class="Keyword">open</a> <a id="681" class="Keyword">import</a> <a id="688" href="Data.Vec.Properties.html" class="Module">Data.Vec.Properties</a>
<a id="708" class="Keyword">open</a> <a id="713" class="Keyword">import</a> <a id="720" href="Data.Vec.Relation.Binary.Equality.Cast.html" class="Module">Data.Vec.Relation.Binary.Equality.Cast</a>
<a id="759" class="Keyword">open</a> <a id="764" class="Keyword">import</a> <a id="771" href="Function.html" class="Module">Function</a> <a id="780" class="Keyword">using</a> <a id="786" class="Symbol">(</a><a id="787" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="790" class="Symbol">)</a>
<a id="792" class="Keyword">open</a> <a id="797" class="Keyword">import</a> <a id="804" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="844" class="Keyword">using</a> <a id="850" class="Symbol">(</a><a id="851" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="854" class="Symbol">;</a> <a id="856" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="860" class="Symbol">;</a> <a id="862" href="Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="865" class="Symbol">;</a> <a id="867" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="871" class="Symbol">;</a> <a id="873" class="Keyword">module</a> <a id="880" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a><a id="891" class="Symbol">)</a>

<a id="894" class="Keyword">private</a> <a id="902" class="Keyword">variable</a>
  <a id="913" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#913" class="Generalizable">a</a> <a id="915" class="Symbol">:</a> <a id="917" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="925" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="927" class="Symbol">:</a> <a id="929" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="933" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#913" class="Generalizable">a</a>
  <a id="937" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#937" class="Generalizable">l</a> <a id="939" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="941" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="943" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#943" class="Generalizable">o</a> <a id="945" class="Symbol">:</a> <a id="947" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="951" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#951" class="Generalizable">xs</a> <a id="954" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#954" class="Generalizable">ys</a> <a id="957" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#957" class="Generalizable">zs</a> <a id="960" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#960" class="Generalizable">ws</a> <a id="963" class="Symbol">:</a> <a id="965" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="969" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="971" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a>


<a id="975" class="Comment">------------------------------------------------------------------------</a>
<a id="1048" class="Comment">-- Motivation</a>
<a id="1062" class="Comment">--</a>
<a id="1065" class="Comment">-- The `cast` function is the computational variant of `subst` for</a>
<a id="1132" class="Comment">-- vectors. Since `cast` computes under vector constructors, it</a>
<a id="1196" class="Comment">-- enables reasoning about vectors with non-definitionally equal indices</a>
<a id="1269" class="Comment">-- by induction. See, e.g., Jacques Carette&#39;s comment in issue #1668.</a>
<a id="1339" class="Comment">-- &lt;https://github.com/agda/agda-stdlib/pull/1668#issuecomment-1003449509&gt;</a>
<a id="1414" class="Comment">--</a>
<a id="1417" class="Comment">-- Suppose we want to prove that ‘xs ++ [] ≡ xs’. Because `xs ++ []`</a>
<a id="1486" class="Comment">-- has type `Vec A (n + 0)` while `xs` has type `Vec A n`, they cannot</a>
<a id="1557" class="Comment">-- be directly related by homogeneous equality.</a>
<a id="1605" class="Comment">-- To resolve the issue, `++-right-identity` uses `cast` to recast</a>
<a id="1672" class="Comment">-- `xs ++ []` as a vector in `Vec A n`.</a>
<a id="1712" class="Comment">--</a>
<a id="++-right-identity"></a><a id="1715" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1715" class="Function">++-right-identity</a> <a id="1733" class="Symbol">:</a> <a id="1735" class="Symbol">∀</a> <a id="1737" class="Symbol">.(</a><a id="1739" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1739" class="Bound">eq</a> <a id="1742" class="Symbol">:</a> <a id="1744" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="1746" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="1748" class="Number">0</a> <a id="1750" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1752" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="1753" class="Symbol">)</a> <a id="1755" class="Symbol">(</a><a id="1756" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1756" class="Bound">xs</a> <a id="1759" class="Symbol">:</a> <a id="1761" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="1765" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="1767" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="1768" class="Symbol">)</a> <a id="1770" class="Symbol">→</a> <a id="1772" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="1777" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1739" class="Bound">eq</a> <a id="1780" class="Symbol">(</a><a id="1781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1756" class="Bound">xs</a> <a id="1784" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="1787" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a><a id="1789" class="Symbol">)</a> <a id="1791" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1793" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1756" class="Bound">xs</a>
<a id="1796" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1715" class="Function">++-right-identity</a> <a id="1814" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1814" class="Bound">eq</a> <a id="1817" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a>       <a id="1826" class="Symbol">=</a> <a id="1828" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="1833" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1715" class="Function">++-right-identity</a> <a id="1851" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1851" class="Bound">eq</a> <a id="1854" class="Symbol">(</a><a id="1855" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1855" class="Bound">x</a> <a id="1857" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="1859" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1859" class="Bound">xs</a><a id="1861" class="Symbol">)</a> <a id="1863" class="Symbol">=</a> <a id="1865" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1870" class="Symbol">(</a><a id="1871" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1855" class="Bound">x</a> <a id="1873" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷_</a><a id="1875" class="Symbol">)</a> <a id="1877" class="Symbol">(</a><a id="1878" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1715" class="Function">++-right-identity</a> <a id="1896" class="Symbol">(</a><a id="1897" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1902" href="Data.Nat.Base.html#5272" class="Function">pred</a> <a id="1907" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1851" class="Bound">eq</a><a id="1909" class="Symbol">)</a> <a id="1911" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1859" class="Bound">xs</a><a id="1913" class="Symbol">)</a>
<a id="1915" class="Comment">--</a>
<a id="1918" class="Comment">-- When the input is `x ∷ xs`, because `cast eq (x ∷ _)` equals</a>
<a id="1982" class="Comment">-- `x ∷ cast (cong pred eq) _`, the proof obligation</a>
<a id="2035" class="Comment">--     cast eq (x ∷ xs ++ []) ≡ x ∷ xs</a>
<a id="2074" class="Comment">-- simplifies to</a>
<a id="2091" class="Comment">--     x :: cast (cong pred eq) (xs ++ []) ≡ x ∷ xs</a>


<a id="2145" class="Comment">-- Although `cast` makes it possible to prove vector identities by ind-</a>
<a id="2217" class="Comment">-- uction, the explicit type-casting nature poses a significant barrier</a>
<a id="2289" class="Comment">-- to code reuse in larger proofs. For example, consider the identity</a>
<a id="2359" class="Comment">-- ‘fromList (xs List.∷ʳ x) ≡ (fromList xs) ∷ʳ x’ where `List._∷ʳ_` is the</a>
<a id="2434" class="Comment">-- snoc function of lists. We have</a>
<a id="2469" class="Comment">--</a>
<a id="2472" class="Comment">--     fromList (xs List.∷ʳ x)            : Vec A (List.length (xs List.∷ʳ x))</a>
<a id="2551" class="Comment">--   =   {- by definition -}</a>
<a id="2580" class="Comment">--     fromList (xs List.++ List.[ x ])   : Vec A (List.length (xs List.++ List.[ x ]))</a>
<a id="2668" class="Comment">--   =   {- by fromList-++ -}</a>
<a id="2698" class="Comment">--     fromList xs ++ fromList List.[ x ] : Vec A (List.length xs + List.length [ x ])</a>
<a id="2785" class="Comment">--   =   {- by definition -}</a>
<a id="2814" class="Comment">--     fromList xs ++ [ x ]               : Vec A (List.length xs + 1)</a>
<a id="2885" class="Comment">--   =   {- by unfold-∷ʳ -}</a>
<a id="2913" class="Comment">--     fromList xs ∷ʳ x                   : Vec A (suc (List.length xs))</a>
<a id="2986" class="Comment">-- where</a>
<a id="2995" class="Comment">--     fromList-++ : cast _ (fromList (xs List.++ ys)) ≡ fromList xs ++ fromList ys</a>
<a id="3079" class="Comment">--     unfold-∷ʳ   : cast _ (xs ∷ʳ x) ≡ xs ++ [ x ]</a>
<a id="3131" class="Comment">--</a>
<a id="3134" class="Comment">-- Although the identity itself is simple, the reasoning process changes</a>
<a id="3207" class="Comment">-- the index in the type twice. Consequently, its Agda translation must</a>
<a id="3279" class="Comment">-- insert two `cast`s in the proof. Moreover, the proof first has to</a>
<a id="3348" class="Comment">-- rearrange (the Agda version of) the identity into one with two</a>
<a id="3414" class="Comment">-- `cast`s, resulting in lots of boilerplate code as demonstrated by</a>
<a id="3483" class="Comment">-- `example1a-fromList-∷ʳ`.</a>
<a id="example1a-fromList-∷ʳ"></a><a id="3511" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3511" class="Function">example1a-fromList-∷ʳ</a> <a id="3533" class="Symbol">:</a> <a id="3535" class="Symbol">∀</a> <a id="3537" class="Symbol">(</a><a id="3538" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3538" class="Bound">x</a> <a id="3540" class="Symbol">:</a> <a id="3542" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="3543" class="Symbol">)</a> <a id="3545" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a> <a id="3548" class="Symbol">→</a>
                        <a id="3574" class="Symbol">.(</a><a id="3576" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3576" class="Bound">eq</a> <a id="3579" class="Symbol">:</a> <a id="3581" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="3593" class="Symbol">(</a><a id="3594" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a> <a id="3597" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3605" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3538" class="Bound">x</a><a id="3606" class="Symbol">)</a> <a id="3608" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3610" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3614" class="Symbol">(</a><a id="3615" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="3627" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a><a id="3629" class="Symbol">))</a> <a id="3632" class="Symbol">→</a>
                        <a id="3658" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3663" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3576" class="Bound">eq</a> <a id="3666" class="Symbol">(</a><a id="3667" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3676" class="Symbol">(</a><a id="3677" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a> <a id="3680" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3688" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3538" class="Bound">x</a><a id="3689" class="Symbol">))</a> <a id="3692" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3694" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3703" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a> <a id="3706" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="3709" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3538" class="Bound">x</a>
<a id="3711" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3511" class="Function">example1a-fromList-∷ʳ</a> <a id="3733" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="3735" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3738" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3738" class="Bound">eq</a> <a id="3741" class="Symbol">=</a> <a id="3743" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="3751" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3756" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3738" class="Bound">eq</a> <a id="3759" class="Symbol">(</a><a id="3760" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3769" class="Symbol">(</a><a id="3770" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3773" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a><a id="3782" class="Symbol">))</a>
    <a id="3789" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
  <a id="3795" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3800" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3738" class="Bound">eq</a> <a id="3803" class="Symbol">(</a><a id="3804" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3813" class="Symbol">(</a><a id="3814" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3817" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3825" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3832" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="3834" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3835" class="Symbol">))</a>
    <a id="3842" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="3845" href="Data.Vec.Relation.Binary.Equality.Cast.html#1225" class="Function">cast-trans</a> <a id="3856" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4138" class="Function">eq₁</a> <a id="3860" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a> <a id="3864" class="Symbol">(</a><a id="3865" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3874" class="Symbol">(</a><a id="3875" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3878" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3886" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3893" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="3895" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3896" class="Symbol">))</a> <a id="3899" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="3903" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3908" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a> <a id="3912" class="Symbol">(</a><a id="3913" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4138" class="Function">eq₁</a> <a id="3922" class="Symbol">(</a><a id="3923" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3932" class="Symbol">(</a><a id="3933" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3936" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3944" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3951" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="3953" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3954" class="Symbol">)))</a>
    <a id="3962" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="3965" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="3970" class="Symbol">(</a><a id="3971" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3976" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a><a id="3979" class="Symbol">)</a> <a id="3981" class="Symbol">(</a><a id="3982" href="Data.Vec.Properties.html#53222" class="Function">fromList-++</a> <a id="3994" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a><a id="3996" class="Symbol">)</a> <a id="3998" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="4002" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="4007" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a> <a id="4011" class="Symbol">(</a><a id="4012" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4021" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="4024" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="4027" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="4029" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="4031" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="4032" class="Symbol">)</a>
    <a id="4038" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="4041" href="Data.Vec.Relation.Binary.Equality.Cast.html#1914" class="Function">≈-sym</a> <a id="4047" class="Symbol">(</a><a id="4048" href="Data.Vec.Properties.html#35213" class="Function">unfold-∷ʳ-eqFree</a> <a id="4065" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="4067" class="Symbol">(</a><a id="4068" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4077" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a><a id="4079" class="Symbol">))</a> <a id="4082" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="4086" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4095" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="4098" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4101" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a>
    <a id="4107" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
  <a id="4111" class="Keyword">where</a>
  <a id="4119" class="Keyword">open</a> <a id="4124" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
  <a id="4138" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4138" class="Function">eq₁</a> <a id="4142" class="Symbol">=</a> <a id="4144" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="4159" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="4162" class="Symbol">{</a><a id="4163" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="4170" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="4172" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="4173" class="Symbol">}</a>
  <a id="4177" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a> <a id="4181" class="Symbol">=</a> <a id="4183" href="Data.Nat.Properties.html#15642" class="Function">+-comm</a> <a id="4190" class="Symbol">(</a><a id="4191" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4203" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a><a id="4205" class="Symbol">)</a> <a id="4207" class="Number">1</a>

<a id="4210" class="Comment">-- The `cast`s are irrelevant to core of the proof. At the same time,</a>
<a id="4280" class="Comment">-- they can be inferred from the lemmas used during the reasoning steps</a>
<a id="4352" class="Comment">-- (e.g. `fromList-++` and `unfold-∷ʳ`). To eliminate the boilerplate,</a>
<a id="4423" class="Comment">-- this library provides a set of equational reasoning combinators for</a>
<a id="4494" class="Comment">-- equality of the form `cast eq xs ≡ ys`.</a>
<a id="example1b-fromList-∷ʳ"></a><a id="4537" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4537" class="Function">example1b-fromList-∷ʳ</a> <a id="4559" class="Symbol">:</a> <a id="4561" class="Symbol">∀</a> <a id="4563" class="Symbol">(</a><a id="4564" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4564" class="Bound">x</a> <a id="4566" class="Symbol">:</a> <a id="4568" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="4569" class="Symbol">)</a> <a id="4571" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a> <a id="4574" class="Symbol">→</a>
                        <a id="4600" class="Symbol">.(</a><a id="4602" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4602" class="Bound">eq</a> <a id="4605" class="Symbol">:</a> <a id="4607" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4619" class="Symbol">(</a><a id="4620" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a> <a id="4623" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4631" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4564" class="Bound">x</a><a id="4632" class="Symbol">)</a> <a id="4634" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4636" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4640" class="Symbol">(</a><a id="4641" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4653" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a><a id="4655" class="Symbol">))</a> <a id="4658" class="Symbol">→</a>
                        <a id="4684" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="4689" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4602" class="Bound">eq</a> <a id="4692" class="Symbol">(</a><a id="4693" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4702" class="Symbol">(</a><a id="4703" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a> <a id="4706" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4714" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4564" class="Bound">x</a><a id="4715" class="Symbol">))</a> <a id="4718" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4720" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4729" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a> <a id="4732" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4735" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4564" class="Bound">x</a>
<a id="4737" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4537" class="Function">example1b-fromList-∷ʳ</a> <a id="4759" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a> <a id="4761" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4764" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4764" class="Bound">eq</a> <a id="4767" class="Symbol">=</a> <a id="4769" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="4777" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4786" class="Symbol">(</a><a id="4787" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4790" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4798" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a><a id="4799" class="Symbol">)</a>
    <a id="4805" href="Data.Vec.Relation.Binary.Equality.Cast.html#3407" class="Function Operator">≈⟨⟩</a>
  <a id="4811" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4820" class="Symbol">(</a><a id="4821" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4824" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="4832" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="4839" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a> <a id="4841" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="4842" class="Symbol">)</a>
    <a id="4848" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="4851" href="Data.Vec.Properties.html#53222" class="Function">fromList-++</a> <a id="4863" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4866" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="4870" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4879" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4882" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="4885" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="4887" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a> <a id="4889" href="Data.Vec.Base.html#6459" class="Function Operator">]</a>
    <a id="4895" href="Data.Vec.Relation.Binary.Equality.Cast.html#3755" class="Function">≈⟨</a> <a id="4898" href="Data.Vec.Properties.html#35213" class="Function">unfold-∷ʳ-eqFree</a> <a id="4915" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a> <a id="4917" class="Symbol">(</a><a id="4918" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4927" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a><a id="4929" class="Symbol">)</a> <a id="4931" href="Data.Vec.Relation.Binary.Equality.Cast.html#3755" class="Function">⟨</a>
  <a id="4935" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4944" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4947" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4950" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a>
    <a id="4956" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="4960" class="Keyword">where</a> <a id="4966" class="Keyword">open</a> <a id="4971" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>


<a id="4987" class="Comment">------------------------------------------------------------------------</a>
<a id="5060" class="Comment">-- Combinators</a>
<a id="5075" class="Comment">--</a>
<a id="5078" class="Comment">-- Let `xs ≈[ m≡n ] ys` denote `cast m≡n xs ≡ ys`. We have reflexivity,</a>
<a id="5150" class="Comment">-- symmetry and transitivity:</a>
<a id="5180" class="Comment">--     ≈-reflexive : xs ≈[ refl ] xs</a>
<a id="5217" class="Comment">--     ≈-sym       : xs ≈[ m≡n ] ys → ys ≈[ sym m≡n ] xs</a>
<a id="5274" class="Comment">--     ≈-trans     : xs ≈[ m≡n ] ys → ys ≈[ n≡o ] zs → xs ≈[ trans m≡n n≡o ] zs</a>
<a id="5354" class="Comment">-- Accordingly, `_≈[_]_` admits the standard set of equational reasoning</a>
<a id="5427" class="Comment">-- combinators. Suppose `≈-eqn : xs ≈[ m≡n ] ys`,</a>
<a id="5477" class="Comment">--     xs ≈⟨ ≈-eqn ⟩   -- `_≈⟨_⟩_` takes a `_≈[_]_` step, adjusting</a>
<a id="5545" class="Comment">--     ys              -- the index at the same time</a>
<a id="5598" class="Comment">--</a>
<a id="5601" class="Comment">--     ys ≈⟨ ≈-eqn ⟨   -- `_≈⟨_⟨_` takes a symmetric `_≈[_]_` step</a>
<a id="5668" class="Comment">--     xs</a>
<a id="example2a"></a><a id="5678" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5678" class="Function">example2a</a> <a id="5688" class="Symbol">:</a> <a id="5690" class="Symbol">∀</a> <a id="5692" class="Symbol">.(</a><a id="5694" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5694" class="Bound">eq</a> <a id="5697" class="Symbol">:</a> <a id="5699" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5703" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="5705" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="5707" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="5709" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5711" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="5713" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="5715" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5719" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="5720" class="Symbol">)</a> <a id="5722" class="Symbol">(</a><a id="5723" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5723" class="Bound">xs</a> <a id="5726" class="Symbol">:</a> <a id="5728" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="5732" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="5734" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a><a id="5735" class="Symbol">)</a> <a id="5737" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5737" class="Bound">a</a> <a id="5739" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5739" class="Bound">ys</a> <a id="5742" class="Symbol">→</a>
            <a id="5756" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="5761" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5694" class="Bound">eq</a> <a id="5764" class="Symbol">((</a><a id="5766" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5774" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5723" class="Bound">xs</a> <a id="5777" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="5780" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5737" class="Bound">a</a><a id="5781" class="Symbol">)</a> <a id="5783" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5786" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5739" class="Bound">ys</a><a id="5788" class="Symbol">)</a> <a id="5790" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5792" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5800" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5723" class="Bound">xs</a> <a id="5803" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5806" class="Symbol">(</a><a id="5807" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5737" class="Bound">a</a> <a id="5809" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="5811" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5739" class="Bound">ys</a><a id="5813" class="Symbol">)</a>
<a id="5815" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5678" class="Function">example2a</a> <a id="5825" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5825" class="Bound">eq</a> <a id="5828" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5828" class="Bound">xs</a> <a id="5831" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5831" class="Bound">a</a> <a id="5833" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5833" class="Bound">ys</a> <a id="5836" class="Symbol">=</a> <a id="5838" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="5846" class="Symbol">(</a><a id="5847" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5855" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5828" class="Bound">xs</a> <a id="5858" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="5861" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5831" class="Bound">a</a><a id="5862" class="Symbol">)</a> <a id="5864" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5867" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5833" class="Bound">ys</a> <a id="5870" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="5873" href="Data.Vec.Properties.html#37313" class="Function">∷ʳ-++-eqFree</a> <a id="5886" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5831" class="Bound">a</a> <a id="5888" class="Symbol">(</a><a id="5889" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5897" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5828" class="Bound">xs</a><a id="5899" class="Symbol">)</a> <a id="5901" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a> <a id="5903" class="Comment">-- index: suc m + n</a>
  <a id="5925" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5933" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5828" class="Bound">xs</a> <a id="5936" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5939" class="Symbol">(</a><a id="5940" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5831" class="Bound">a</a> <a id="5942" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="5944" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5833" class="Bound">ys</a><a id="5946" class="Symbol">)</a>  <a id="5949" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>                                <a id="5982" class="Comment">-- index: m + suc n</a>
  <a id="6004" class="Keyword">where</a> <a id="6010" class="Keyword">open</a> <a id="6015" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="6030" class="Comment">-- To interoperate with `_≡_`, this library provides `_≂⟨_⟩_` (\-~) for</a>
<a id="6102" class="Comment">-- taking a `_≡_` step during equational reasoning.</a>
<a id="6154" class="Comment">-- Let `≡-eqn : xs ≡ ys`, then</a>
<a id="6185" class="Comment">--     xs ≂⟨ ≡-eqn  ⟩    -- Takes a `_≡_` step; no change to the index</a>
<a id="6256" class="Comment">--     ys</a>
<a id="6266" class="Comment">--</a>
<a id="6269" class="Comment">--     ys ≂⟨ ≡-eqn ⟨    -- Takes a symmetric `_≡_` step</a>
<a id="6325" class="Comment">--     xs</a>
<a id="6335" class="Comment">-- Equivalently, `≈-reflexive` injects `_≡_` into `_≈[_]_`. That is,</a>
<a id="6404" class="Comment">-- `xs ≂⟨ ≡-eqn ⟩ ys` is the same as `xs ≈⟨ ≈-reflexive ≡-eqn ⟩ ys`.</a>
<a id="6473" class="Comment">-- Extending `example2a`, we have:</a>
<a id="example2b"></a><a id="6508" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6508" class="Function">example2b</a> <a id="6518" class="Symbol">:</a> <a id="6520" class="Symbol">∀</a> <a id="6522" class="Symbol">.(</a><a id="6524" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6524" class="Bound">eq</a> <a id="6527" class="Symbol">:</a> <a id="6529" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6533" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="6535" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="6537" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="6539" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6541" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="6543" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="6545" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6549" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="6550" class="Symbol">)</a> <a id="6552" class="Symbol">(</a><a id="6553" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6553" class="Bound">xs</a> <a id="6556" class="Symbol">:</a> <a id="6558" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="6562" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="6564" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a><a id="6565" class="Symbol">)</a> <a id="6567" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6567" class="Bound">a</a> <a id="6569" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6569" class="Bound">ys</a> <a id="6572" class="Symbol">→</a>
            <a id="6586" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="6591" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6524" class="Bound">eq</a> <a id="6594" class="Symbol">((</a><a id="6596" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6567" class="Bound">a</a> <a id="6598" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6600" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6553" class="Bound">xs</a><a id="6602" class="Symbol">)</a> <a id="6604" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6608" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6569" class="Bound">ys</a><a id="6610" class="Symbol">)</a> <a id="6612" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6614" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6553" class="Bound">xs</a> <a id="6617" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6621" class="Symbol">(</a><a id="6622" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6567" class="Bound">a</a> <a id="6624" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6626" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6569" class="Bound">ys</a><a id="6628" class="Symbol">)</a>
<a id="6630" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6508" class="Function">example2b</a> <a id="6640" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6640" class="Bound">eq</a> <a id="6643" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6646" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6648" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a> <a id="6651" class="Symbol">=</a> <a id="6653" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="6661" class="Symbol">(</a><a id="6662" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6664" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6666" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6668" class="Symbol">)</a> <a id="6670" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6674" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a>         <a id="6685" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">≂⟨</a> <a id="6688" href="Data.Vec.Properties.html#41464" class="Function">unfold-ʳ++</a> <a id="6699" class="Symbol">(</a><a id="6700" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6702" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6704" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6706" class="Symbol">)</a> <a id="6708" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a> <a id="6711" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">⟩</a>          <a id="6722" class="Comment">-- index: suc m + n</a>
  <a id="6744" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6752" class="Symbol">(</a><a id="6753" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6755" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6757" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6759" class="Symbol">)</a> <a id="6761" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6764" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a>  <a id="6768" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">≂⟨</a> <a id="6771" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="6776" class="Symbol">(</a><a id="6777" href="Data.Vec.Base.html#3076" class="Function Operator">_++</a> <a id="6781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a><a id="6783" class="Symbol">)</a> <a id="6785" class="Symbol">(</a><a id="6786" href="Data.Vec.Properties.html#37703" class="Function">reverse-∷</a> <a id="6796" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6798" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6800" class="Symbol">)</a> <a id="6802" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">⟩</a>  <a id="6805" class="Comment">-- index: suc m + n</a>
  <a id="6827" class="Symbol">(</a><a id="6828" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6836" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6839" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="6842" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a><a id="6843" class="Symbol">)</a> <a id="6845" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6848" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a> <a id="6851" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="6854" href="Data.Vec.Properties.html#37313" class="Function">∷ʳ-++-eqFree</a> <a id="6867" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6869" class="Symbol">(</a><a id="6870" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6878" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6880" class="Symbol">)</a> <a id="6882" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>     <a id="6888" class="Comment">-- index: suc m + n</a>
  <a id="6910" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6921" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6924" class="Symbol">(</a><a id="6925" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6927" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6929" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a><a id="6931" class="Symbol">)</a>  <a id="6934" href="Data.Vec.Relation.Binary.Equality.Cast.html#4634" class="Function">≂⟨</a> <a id="6937" href="Data.Vec.Properties.html#41464" class="Function">unfold-ʳ++</a> <a id="6948" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6951" class="Symbol">(</a><a id="6952" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6954" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6956" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a><a id="6958" class="Symbol">)</a> <a id="6960" href="Data.Vec.Relation.Binary.Equality.Cast.html#4634" class="Function">⟨</a>          <a id="6971" class="Comment">-- index: m + suc n</a>
  <a id="6993" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6996" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="7000" class="Symbol">(</a><a id="7001" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="7003" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="7005" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a><a id="7007" class="Symbol">)</a>         <a id="7017" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>                                    <a id="7054" class="Comment">-- index: m + suc n</a>
  <a id="7076" class="Keyword">where</a> <a id="7082" class="Keyword">open</a> <a id="7087" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="7102" class="Comment">-- Oftentimes index-changing identities apply to only part of the proof</a>
<a id="7174" class="Comment">-- term. When reasoning about `_≡_`, `cong` shifts the focus to the</a>
<a id="7242" class="Comment">-- subterm of interest. In this library, `≈-cong` does a similar job.</a>
<a id="7312" class="Comment">-- Suppose `f : A → B`, `xs : B`, `ys zs : A`, `ys≈zs : ys ≈[ _ ] zs`</a>
<a id="7382" class="Comment">-- and `xs≈f⟨c·ys⟩ : xs ≈[ _ ] f (cast _ ys)`, we have</a>
<a id="7437" class="Comment">--     xs ≈⟨ ≈-cong f xs≈f⟨c·ys⟩ ys≈zs ⟩</a>
<a id="7478" class="Comment">--     f zs</a>
<a id="7490" class="Comment">-- The reason for having the extra argument `xs≈f⟨c·ys⟩` is to expose</a>
<a id="7560" class="Comment">-- `cast` in the subterm in order to apply the step `ys≈zs`. When using</a>
<a id="7632" class="Comment">-- ordinary `cong` the proof has to explicitly push `cast` inside:</a>
<a id="7699" class="Comment">--     xs            ≈⟨ xs≈f⟨c·ys⟩ ⟩</a>
<a id="7736" class="Comment">--     f (cast _ ys) ≂⟨ cong f ys≈zs ⟩</a>
<a id="7775" class="Comment">--     f zs</a>
<a id="7787" class="Comment">-- Note. Technically, `A` and `B` should be vectors of different length</a>
<a id="7859" class="Comment">-- and that `ys`, `zs` are vectors of non-definitionally equal index.</a>
<a id="example3a-fromList-++-++"></a><a id="7929" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7929" class="Function">example3a-fromList-++-++</a> <a id="7954" class="Symbol">:</a> <a id="7956" class="Symbol">{</a><a id="7957" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7957" class="Bound">xs</a> <a id="7960" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7960" class="Bound">ys</a> <a id="7963" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7963" class="Bound">zs</a> <a id="7966" class="Symbol">:</a> <a id="7968" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="7973" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="7974" class="Symbol">}</a> <a id="7976" class="Symbol">→</a>
                           <a id="8005" class="Symbol">.(</a><a id="8007" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8007" class="Bound">eq</a> <a id="8010" class="Symbol">:</a> <a id="8012" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8024" class="Symbol">(</a><a id="8025" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7957" class="Bound">xs</a> <a id="8028" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8036" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7960" class="Bound">ys</a> <a id="8039" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8047" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7963" class="Bound">zs</a><a id="8049" class="Symbol">)</a> <a id="8051" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                  <a id="8087" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8099" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7957" class="Bound">xs</a> <a id="8102" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8104" class="Symbol">(</a><a id="8105" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8117" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7960" class="Bound">ys</a> <a id="8120" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8122" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8134" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7963" class="Bound">zs</a><a id="8136" class="Symbol">))</a> <a id="8139" class="Symbol">→</a>
                           <a id="8168" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="8173" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8007" class="Bound">eq</a> <a id="8176" class="Symbol">(</a><a id="8177" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8186" class="Symbol">(</a><a id="8187" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7957" class="Bound">xs</a> <a id="8190" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8198" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7960" class="Bound">ys</a> <a id="8201" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8209" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7963" class="Bound">zs</a><a id="8211" class="Symbol">))</a> <a id="8214" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="8251" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8260" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7957" class="Bound">xs</a> <a id="8263" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8266" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8275" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7960" class="Bound">ys</a> <a id="8278" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8281" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8290" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7963" class="Bound">zs</a>
<a id="8293" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7929" class="Function">example3a-fromList-++-++</a> <a id="8318" class="Symbol">{</a><a id="8319" class="Argument">xs</a> <a id="8322" class="Symbol">=</a> <a id="8324" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8324" class="Bound">xs</a><a id="8326" class="Symbol">}</a> <a id="8328" class="Symbol">{</a><a id="8329" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8329" class="Bound">ys</a><a id="8331" class="Symbol">}</a> <a id="8333" class="Symbol">{</a><a id="8334" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8334" class="Bound">zs</a><a id="8336" class="Symbol">}</a> <a id="8338" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8338" class="Bound">eq</a> <a id="8341" class="Symbol">=</a> <a id="8343" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="8351" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8360" class="Symbol">(</a><a id="8361" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8324" class="Bound">xs</a> <a id="8364" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8372" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8329" class="Bound">ys</a> <a id="8375" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8383" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8334" class="Bound">zs</a><a id="8385" class="Symbol">)</a>
    <a id="8391" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="8394" href="Data.Vec.Properties.html#53222" class="Function">fromList-++</a> <a id="8406" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8324" class="Bound">xs</a> <a id="8409" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="8413" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8422" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8324" class="Bound">xs</a> <a id="8425" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8428" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8437" class="Symbol">(</a><a id="8438" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8329" class="Bound">ys</a> <a id="8441" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8449" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8334" class="Bound">zs</a><a id="8451" class="Symbol">)</a>
    <a id="8457" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="8460" href="Data.Vec.Relation.Binary.Equality.Cast.html#2663" class="Function">≈-cong′</a> <a id="8468" class="Symbol">(</a><a id="8469" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8478" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8324" class="Bound">xs</a> <a id="8481" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="8484" class="Symbol">)</a> <a id="8486" class="Symbol">(</a><a id="8487" href="Data.Vec.Properties.html#53222" class="Function">fromList-++</a> <a id="8499" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8329" class="Bound">ys</a><a id="8501" class="Symbol">)</a> <a id="8503" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="8507" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8516" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8324" class="Bound">xs</a> <a id="8519" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8522" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8531" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8329" class="Bound">ys</a> <a id="8534" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8537" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8546" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8334" class="Bound">zs</a>
    <a id="8553" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="8557" class="Keyword">where</a> <a id="8563" class="Keyword">open</a> <a id="8568" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="8583" class="Comment">-- As an alternative, one can manually apply `cast-++ʳ` to expose `cast`</a>
<a id="8656" class="Comment">-- in the subterm. However, this unavoidably duplicates the proof term.</a>
<a id="example3b-fromList-++-++′"></a><a id="8728" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8728" class="Function">example3b-fromList-++-++′</a> <a id="8754" class="Symbol">:</a> <a id="8756" class="Symbol">{</a><a id="8757" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8757" class="Bound">xs</a> <a id="8760" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8760" class="Bound">ys</a> <a id="8763" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8763" class="Bound">zs</a> <a id="8766" class="Symbol">:</a> <a id="8768" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="8773" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="8774" class="Symbol">}</a> <a id="8776" class="Symbol">→</a>
                            <a id="8806" class="Symbol">.(</a><a id="8808" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8808" class="Bound">eq</a> <a id="8811" class="Symbol">:</a> <a id="8813" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8825" class="Symbol">(</a><a id="8826" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8757" class="Bound">xs</a> <a id="8829" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8837" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8760" class="Bound">ys</a> <a id="8840" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8848" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8763" class="Bound">zs</a><a id="8850" class="Symbol">)</a> <a id="8852" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="8889" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8901" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8757" class="Bound">xs</a> <a id="8904" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8906" class="Symbol">(</a><a id="8907" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8919" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8760" class="Bound">ys</a> <a id="8922" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8924" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8936" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8763" class="Bound">zs</a><a id="8938" class="Symbol">))</a> <a id="8941" class="Symbol">→</a>
                            <a id="8971" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="8976" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8808" class="Bound">eq</a> <a id="8979" class="Symbol">(</a><a id="8980" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8989" class="Symbol">(</a><a id="8990" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8757" class="Bound">xs</a> <a id="8993" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9001" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8760" class="Bound">ys</a> <a id="9004" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9012" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8763" class="Bound">zs</a><a id="9014" class="Symbol">))</a> <a id="9017" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                    <a id="9055" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9064" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8757" class="Bound">xs</a> <a id="9067" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9070" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9079" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8760" class="Bound">ys</a> <a id="9082" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9085" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9094" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8763" class="Bound">zs</a>
<a id="9097" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8728" class="Function">example3b-fromList-++-++′</a> <a id="9123" class="Symbol">{</a><a id="9124" class="Argument">xs</a> <a id="9127" class="Symbol">=</a> <a id="9129" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9129" class="Bound">xs</a><a id="9131" class="Symbol">}</a> <a id="9133" class="Symbol">{</a><a id="9134" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9134" class="Bound">ys</a><a id="9136" class="Symbol">}</a> <a id="9138" class="Symbol">{</a><a id="9139" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9139" class="Bound">zs</a><a id="9141" class="Symbol">}</a> <a id="9143" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9143" class="Bound">eq</a> <a id="9146" class="Symbol">=</a> <a id="9148" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="9156" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9165" class="Symbol">(</a><a id="9166" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9129" class="Bound">xs</a> <a id="9169" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9177" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9134" class="Bound">ys</a> <a id="9180" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9188" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9139" class="Bound">zs</a><a id="9190" class="Symbol">)</a>
    <a id="9196" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="9199" href="Data.Vec.Properties.html#53222" class="Function">fromList-++</a> <a id="9211" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9129" class="Bound">xs</a> <a id="9214" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="9218" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9227" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9129" class="Bound">xs</a> <a id="9230" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9233" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9242" class="Symbol">(</a><a id="9243" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9134" class="Bound">ys</a> <a id="9246" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9254" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9139" class="Bound">zs</a><a id="9256" class="Symbol">)</a>
    <a id="9262" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="9265" href="Data.Vec.Properties.html#19949" class="Function">cast-++ʳ</a> <a id="9274" class="Symbol">(</a><a id="9275" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="9290" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9134" class="Bound">ys</a><a id="9292" class="Symbol">)</a> <a id="9294" class="Symbol">(</a><a id="9295" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9304" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9129" class="Bound">xs</a><a id="9306" class="Symbol">)</a> <a id="9308" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="9312" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9321" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9129" class="Bound">xs</a> <a id="9324" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9327" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="9332" class="Symbol">_</a> <a id="9334" class="Symbol">(</a><a id="9335" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9344" class="Symbol">(</a><a id="9345" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9134" class="Bound">ys</a> <a id="9348" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9356" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9139" class="Bound">zs</a><a id="9358" class="Symbol">))</a>
    <a id="9365" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">≂⟨</a> <a id="9368" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="9373" class="Symbol">(</a><a id="9374" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9383" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9129" class="Bound">xs</a> <a id="9386" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="9389" class="Symbol">)</a> <a id="9391" class="Symbol">(</a><a id="9392" href="Data.Vec.Properties.html#53222" class="Function">fromList-++</a> <a id="9404" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9134" class="Bound">ys</a><a id="9406" class="Symbol">)</a> <a id="9408" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">⟩</a>
  <a id="9412" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9421" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9129" class="Bound">xs</a> <a id="9424" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9427" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9436" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9134" class="Bound">ys</a> <a id="9439" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9442" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9451" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9139" class="Bound">zs</a>
    <a id="9458" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="9462" class="Keyword">where</a> <a id="9468" class="Keyword">open</a> <a id="9473" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="9488" class="Comment">-- `≈-cong` can be chained together much like how `cong` can be nested.</a>
<a id="9560" class="Comment">-- In this example, `unfold-∷ʳ` is applied to the term `xs ++ [ a ]`</a>
<a id="9629" class="Comment">-- in `(_++ ys)` inside of `reverse`. Thus the proof employs two</a>
<a id="9694" class="Comment">-- `≈-cong`.</a>
<a id="example4-cong²"></a><a id="9707" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9707" class="Function">example4-cong²</a> <a id="9722" class="Symbol">:</a> <a id="9724" class="Symbol">∀</a> <a id="9726" class="Symbol">.(</a><a id="9728" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9728" class="Bound">eq</a> <a id="9731" class="Symbol">:</a> <a id="9733" class="Symbol">(</a><a id="9734" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="9736" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9738" class="Number">1</a><a id="9739" class="Symbol">)</a> <a id="9741" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9743" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="9745" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9747" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="9749" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9751" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9755" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a><a id="9756" class="Symbol">)</a> <a id="9758" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9758" class="Bound">a</a> <a id="9760" class="Symbol">(</a><a id="9761" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9761" class="Bound">xs</a> <a id="9764" class="Symbol">:</a> <a id="9766" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="9770" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="9772" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a><a id="9773" class="Symbol">)</a> <a id="9775" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9775" class="Bound">ys</a> <a id="9778" class="Symbol">→</a>
          <a id="9790" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="9795" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9728" class="Bound">eq</a> <a id="9798" class="Symbol">(</a><a id="9799" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9807" class="Symbol">((</a><a id="9809" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9761" class="Bound">xs</a> <a id="9812" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9815" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="9817" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9758" class="Bound">a</a> <a id="9819" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="9820" class="Symbol">)</a> <a id="9822" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9825" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9775" class="Bound">ys</a><a id="9827" class="Symbol">))</a> <a id="9830" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9832" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9775" class="Bound">ys</a> <a id="9835" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="9839" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9847" class="Symbol">(</a><a id="9848" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9761" class="Bound">xs</a> <a id="9851" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="9854" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9758" class="Bound">a</a><a id="9855" class="Symbol">)</a>
<a id="9857" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9707" class="Function">example4-cong²</a> <a id="9872" class="Symbol">{</a><a id="9873" class="Argument">m</a> <a id="9875" class="Symbol">=</a> <a id="9877" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9877" class="Bound">m</a><a id="9878" class="Symbol">}</a> <a id="9880" class="Symbol">{</a><a id="9881" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9881" class="Bound">n</a><a id="9882" class="Symbol">}</a> <a id="9884" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9884" class="Bound">eq</a> <a id="9887" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9887" class="Bound">a</a> <a id="9889" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9889" class="Bound">xs</a> <a id="9892" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">ys</a> <a id="9895" class="Symbol">=</a> <a id="9897" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="9905" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9913" class="Symbol">((</a><a id="9915" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9889" class="Bound">xs</a> <a id="9918" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9921" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="9923" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9887" class="Bound">a</a> <a id="9925" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="9926" class="Symbol">)</a> <a id="9928" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9931" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">ys</a><a id="9933" class="Symbol">)</a>
    <a id="9939" href="Data.Vec.Relation.Binary.Equality.Cast.html#3755" class="Function">≈⟨</a> <a id="9942" href="Data.Vec.Relation.Binary.Equality.Cast.html#2663" class="Function">≈-cong′</a> <a id="9950" class="Symbol">(</a><a id="9951" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9959" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="9961" class="Symbol">(</a><a id="9962" href="Data.Vec.Base.html#3076" class="Function Operator">_++</a> <a id="9966" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">ys</a><a id="9968" class="Symbol">))</a> <a id="9971" class="Symbol">(</a><a id="9972" href="Data.Vec.Properties.html#35213" class="Function">unfold-∷ʳ-eqFree</a> <a id="9989" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9887" class="Bound">a</a> <a id="9991" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9889" class="Bound">xs</a><a id="9993" class="Symbol">)</a> <a id="9995" href="Data.Vec.Relation.Binary.Equality.Cast.html#3755" class="Function">⟨</a>
  <a id="9999" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10007" class="Symbol">((</a><a id="10009" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9889" class="Bound">xs</a> <a id="10012" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10015" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9887" class="Bound">a</a><a id="10016" class="Symbol">)</a> <a id="10018" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="10021" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">ys</a><a id="10023" class="Symbol">)</a>
    <a id="10029" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="10032" href="Data.Vec.Properties.html#40523" class="Function">reverse-++-eqFree</a> <a id="10050" class="Symbol">(</a><a id="10051" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9889" class="Bound">xs</a> <a id="10054" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10057" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9887" class="Bound">a</a><a id="10058" class="Symbol">)</a> <a id="10060" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">ys</a> <a id="10063" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="10067" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10075" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">ys</a> <a id="10078" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="10081" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10089" class="Symbol">(</a><a id="10090" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9889" class="Bound">xs</a> <a id="10093" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10096" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9887" class="Bound">a</a><a id="10097" class="Symbol">)</a>
    <a id="10103" href="Data.Vec.Relation.Binary.Equality.Cast.html#4634" class="Function">≂⟨</a> <a id="10106" href="Data.Vec.Properties.html#41464" class="Function">unfold-ʳ++</a> <a id="10117" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">ys</a> <a id="10120" class="Symbol">(</a><a id="10121" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10129" class="Symbol">(</a><a id="10130" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9889" class="Bound">xs</a> <a id="10133" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10136" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9887" class="Bound">a</a><a id="10137" class="Symbol">))</a> <a id="10140" href="Data.Vec.Relation.Binary.Equality.Cast.html#4634" class="Function">⟨</a>
  <a id="10144" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">ys</a> <a id="10147" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="10151" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10159" class="Symbol">(</a><a id="10160" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9889" class="Bound">xs</a> <a id="10163" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10166" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9887" class="Bound">a</a><a id="10167" class="Symbol">)</a>
    <a id="10173" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="10177" class="Keyword">where</a> <a id="10183" class="Keyword">open</a> <a id="10188" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="10203" class="Comment">------------------------------------------------------------------------</a>
<a id="10276" class="Comment">-- Interoperation between `_≈[_]_` and `_≡_`</a>
<a id="10321" class="Comment">--</a>
<a id="10324" class="Comment">-- This library is designed to interoperate with `_≡_`. Examples in the</a>
<a id="10396" class="Comment">-- combinators section showed how to apply `_≂⟨_⟩_` to take an `_≡_`</a>
<a id="10465" class="Comment">-- step during equational reasoning about `_≈[_]_`. Recall that</a>
<a id="10529" class="Comment">-- `xs ≈[ m≡n ] ys` is a shorthand for `cast m≡n xs ≡ ys`, the</a>
<a id="10592" class="Comment">-- combinator is essentially the composition of `_≡_` on the left-hand</a>
<a id="10663" class="Comment">-- side of `_≈[_]_`. Dually, the combinator `_≃⟨_⟩_` composes `_≡_` on</a>
<a id="10734" class="Comment">-- the right-hand side of `_≈[_]_`. Thus `_≃⟨_⟩_` intuitively ends the</a>
<a id="10805" class="Comment">-- reasoning system of `_≈[_]_` and switches back to the reasoning</a>
<a id="10872" class="Comment">-- system of `_≡_`.</a>
<a id="example5-fromList-++-++′"></a><a id="10892" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10892" class="Function">example5-fromList-++-++′</a> <a id="10917" class="Symbol">:</a> <a id="10919" class="Symbol">{</a><a id="10920" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10920" class="Bound">xs</a> <a id="10923" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10923" class="Bound">ys</a> <a id="10926" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10926" class="Bound">zs</a> <a id="10929" class="Symbol">:</a> <a id="10931" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="10936" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="10937" class="Symbol">}</a> <a id="10939" class="Symbol">→</a>
                           <a id="10968" class="Symbol">.(</a><a id="10970" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10970" class="Bound">eq</a> <a id="10973" class="Symbol">:</a> <a id="10975" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="10987" class="Symbol">(</a><a id="10988" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10920" class="Bound">xs</a> <a id="10991" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="10999" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10923" class="Bound">ys</a> <a id="11002" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11010" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10926" class="Bound">zs</a><a id="11012" class="Symbol">)</a> <a id="11014" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                  <a id="11050" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="11062" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10920" class="Bound">xs</a> <a id="11065" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="11067" class="Symbol">(</a><a id="11068" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="11080" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10923" class="Bound">ys</a> <a id="11083" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="11085" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="11097" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10926" class="Bound">zs</a><a id="11099" class="Symbol">))</a> <a id="11102" class="Symbol">→</a>
                           <a id="11131" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="11136" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10970" class="Bound">eq</a> <a id="11139" class="Symbol">(</a><a id="11140" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11149" class="Symbol">(</a><a id="11150" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10920" class="Bound">xs</a> <a id="11153" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11161" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10923" class="Bound">ys</a> <a id="11164" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11172" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10926" class="Bound">zs</a><a id="11174" class="Symbol">))</a> <a id="11177" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="11214" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11223" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10920" class="Bound">xs</a> <a id="11226" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11229" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11238" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10923" class="Bound">ys</a> <a id="11241" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11244" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11253" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10926" class="Bound">zs</a>
<a id="11256" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10892" class="Function">example5-fromList-++-++′</a> <a id="11281" class="Symbol">{</a><a id="11282" class="Argument">xs</a> <a id="11285" class="Symbol">=</a> <a id="11287" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11287" class="Bound">xs</a><a id="11289" class="Symbol">}</a> <a id="11291" class="Symbol">{</a><a id="11292" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11292" class="Bound">ys</a><a id="11294" class="Symbol">}</a> <a id="11296" class="Symbol">{</a><a id="11297" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11297" class="Bound">zs</a><a id="11299" class="Symbol">}</a> <a id="11301" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11301" class="Bound">eq</a> <a id="11304" class="Symbol">=</a> <a id="11306" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="11314" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11323" class="Symbol">(</a><a id="11324" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11287" class="Bound">xs</a> <a id="11327" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11335" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11292" class="Bound">ys</a> <a id="11338" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11346" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11297" class="Bound">zs</a><a id="11348" class="Symbol">)</a>
    <a id="11354" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="11357" href="Data.Vec.Properties.html#53222" class="Function">fromList-++</a> <a id="11369" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11287" class="Bound">xs</a> <a id="11372" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="11376" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11385" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11287" class="Bound">xs</a> <a id="11388" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11391" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11400" class="Symbol">(</a><a id="11401" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11292" class="Bound">ys</a> <a id="11404" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11412" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11297" class="Bound">zs</a><a id="11414" class="Symbol">)</a>
    <a id="11420" href="Data.Vec.Relation.Binary.Equality.Cast.html#4082" class="Function">≃⟨</a> <a id="11423" href="Data.Vec.Properties.html#19949" class="Function">cast-++ʳ</a> <a id="11432" class="Symbol">(</a><a id="11433" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="11448" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11292" class="Bound">ys</a><a id="11450" class="Symbol">)</a> <a id="11452" class="Symbol">(</a><a id="11453" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11462" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11287" class="Bound">xs</a><a id="11464" class="Symbol">)</a> <a id="11466" href="Data.Vec.Relation.Binary.Equality.Cast.html#4082" class="Function">⟩</a>
  <a id="11470" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11479" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11287" class="Bound">xs</a> <a id="11482" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11485" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="11490" class="Symbol">_</a> <a id="11492" class="Symbol">(</a><a id="11493" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11502" class="Symbol">(</a><a id="11503" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11292" class="Bound">ys</a> <a id="11506" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11514" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11297" class="Bound">zs</a><a id="11516" class="Symbol">))</a>
    <a id="11523" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="11526" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="11531" class="Symbol">(</a><a id="11532" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11541" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11287" class="Bound">xs</a> <a id="11544" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="11547" class="Symbol">)</a> <a id="11549" class="Symbol">(</a><a id="11550" href="Data.Vec.Properties.html#53222" class="Function">fromList-++</a> <a id="11562" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11292" class="Bound">ys</a><a id="11564" class="Symbol">)</a> <a id="11566" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="11570" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11579" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11287" class="Bound">xs</a> <a id="11582" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11585" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11594" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11292" class="Bound">ys</a> <a id="11597" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11600" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11609" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11297" class="Bound">zs</a>
    <a id="11616" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">≡-∎</a>
  <a id="11622" class="Keyword">where</a> <a id="11628" class="Keyword">open</a> <a id="11633" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="11648" class="Comment">-- Of course, it is possible to start with the reasoning system of `_≡_`</a>
<a id="11721" class="Comment">-- and then switch to the reasoning system of `_≈[_]_`.</a>
<a id="example6a-reverse-∷ʳ"></a><a id="11777" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11777" class="Function">example6a-reverse-∷ʳ</a> <a id="11798" class="Symbol">:</a> <a id="11800" class="Symbol">∀</a> <a id="11802" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11802" class="Bound">x</a> <a id="11804" class="Symbol">(</a><a id="11805" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11805" class="Bound">xs</a> <a id="11808" class="Symbol">:</a> <a id="11810" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="11814" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="11816" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="11817" class="Symbol">)</a> <a id="11819" class="Symbol">→</a> <a id="11821" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11829" class="Symbol">(</a><a id="11830" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11805" class="Bound">xs</a> <a id="11833" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="11836" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11802" class="Bound">x</a><a id="11837" class="Symbol">)</a> <a id="11839" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11841" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11802" class="Bound">x</a> <a id="11843" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11845" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11853" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11805" class="Bound">xs</a>
<a id="11856" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11777" class="Function">example6a-reverse-∷ʳ</a> <a id="11877" class="Symbol">{</a><a id="11878" class="Argument">n</a> <a id="11880" class="Symbol">=</a> <a id="11882" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11882" class="Bound">n</a><a id="11883" class="Symbol">}</a> <a id="11885" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11885" class="Bound">x</a> <a id="11887" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11887" class="Bound">xs</a> <a id="11890" class="Symbol">=</a> <a id="11892" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin-≡</a>
  <a id="11902" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11910" class="Symbol">(</a><a id="11911" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11887" class="Bound">xs</a> <a id="11914" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="11917" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11885" class="Bound">x</a><a id="11918" class="Symbol">)</a>
    <a id="11924" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="11927" href="Data.Vec.Relation.Binary.Equality.Cast.html#1789" class="Function">≈-reflexive</a> <a id="11939" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="11944" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="11948" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11956" class="Symbol">(</a><a id="11957" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11887" class="Bound">xs</a> <a id="11960" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="11963" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11885" class="Bound">x</a><a id="11964" class="Symbol">)</a>
    <a id="11970" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="11973" href="Data.Vec.Relation.Binary.Equality.Cast.html#2663" class="Function">≈-cong′</a> <a id="11981" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11989" class="Symbol">(</a><a id="11990" href="Data.Vec.Properties.html#35213" class="Function">unfold-∷ʳ-eqFree</a> <a id="12007" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11885" class="Bound">x</a> <a id="12009" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11887" class="Bound">xs</a><a id="12011" class="Symbol">)</a> <a id="12013" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="12017" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12025" class="Symbol">(</a><a id="12026" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11887" class="Bound">xs</a> <a id="12029" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="12032" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="12034" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11885" class="Bound">x</a> <a id="12036" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="12037" class="Symbol">)</a>
    <a id="12043" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="12046" href="Data.Vec.Properties.html#40523" class="Function">reverse-++-eqFree</a> <a id="12064" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11887" class="Bound">xs</a> <a id="12067" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="12069" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11885" class="Bound">x</a> <a id="12071" href="Data.Vec.Base.html#6459" class="Function Operator">]</a> <a id="12073" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="12077" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11885" class="Bound">x</a> <a id="12079" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12081" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12089" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11887" class="Bound">xs</a>
    <a id="12096" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="12100" class="Keyword">where</a> <a id="12106" class="Keyword">open</a> <a id="12111" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="example6b-reverse-∷ʳ-by-induction"></a><a id="12126" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12126" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12160" class="Symbol">:</a> <a id="12162" class="Symbol">∀</a> <a id="12164" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12164" class="Bound">x</a> <a id="12166" class="Symbol">(</a><a id="12167" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12167" class="Bound">xs</a> <a id="12170" class="Symbol">:</a> <a id="12172" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="12176" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="12178" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="12179" class="Symbol">)</a> <a id="12181" class="Symbol">→</a> <a id="12183" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12191" class="Symbol">(</a><a id="12192" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12167" class="Bound">xs</a> <a id="12195" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12198" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12164" class="Bound">x</a><a id="12199" class="Symbol">)</a> <a id="12201" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12203" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12164" class="Bound">x</a> <a id="12205" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12207" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12215" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12167" class="Bound">xs</a>
<a id="12218" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12126" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12252" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12252" class="Bound">x</a> <a id="12254" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a>       <a id="12263" class="Symbol">=</a> <a id="12265" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="12270" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12126" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12304" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a> <a id="12306" class="Symbol">(</a><a id="12307" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a> <a id="12309" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12311" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a><a id="12313" class="Symbol">)</a> <a id="12315" class="Symbol">=</a> <a id="12317" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="12325" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12333" class="Symbol">(</a><a id="12334" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a> <a id="12336" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12338" class="Symbol">(</a><a id="12339" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a> <a id="12342" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12345" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a><a id="12346" class="Symbol">))</a> <a id="12349" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="12352" href="Data.Vec.Properties.html#37703" class="Function">reverse-∷</a> <a id="12362" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a> <a id="12364" class="Symbol">(</a><a id="12365" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a> <a id="12368" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12371" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a><a id="12372" class="Symbol">)</a> <a id="12374" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="12378" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12386" class="Symbol">(</a><a id="12387" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a> <a id="12390" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12393" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a><a id="12394" class="Symbol">)</a> <a id="12396" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12399" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a>  <a id="12402" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="12405" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="12410" class="Symbol">(</a><a id="12411" href="Data.Vec.Base.html#8754" class="Function Operator">_∷ʳ</a> <a id="12415" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a><a id="12416" class="Symbol">)</a> <a id="12418" class="Symbol">(</a><a id="12419" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12126" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12453" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a> <a id="12455" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a><a id="12457" class="Symbol">)</a> <a id="12459" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="12463" class="Symbol">(</a><a id="12464" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a> <a id="12466" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12468" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12476" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a><a id="12478" class="Symbol">)</a> <a id="12480" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12483" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a>   <a id="12487" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
  <a id="12493" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a> <a id="12495" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12497" class="Symbol">(</a><a id="12498" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12506" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a> <a id="12509" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12512" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a><a id="12513" class="Symbol">)</a>   <a id="12517" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="12520" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="12525" class="Symbol">(</a><a id="12526" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a> <a id="12528" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷_</a><a id="12530" class="Symbol">)</a> <a id="12532" class="Symbol">(</a><a id="12533" href="Data.Vec.Properties.html#37703" class="Function">reverse-∷</a> <a id="12543" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a> <a id="12545" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a><a id="12547" class="Symbol">)</a> <a id="12549" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="12553" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12304" class="Bound">x</a> <a id="12555" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12557" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12565" class="Symbol">(</a><a id="12566" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12307" class="Bound">y</a> <a id="12568" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12570" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12311" class="Bound">xs</a><a id="12572" class="Symbol">)</a>    <a id="12577" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
  <a id="12581" class="Keyword">where</a> <a id="12587" class="Keyword">open</a> <a id="12592" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
</pre></body></html>