<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Vec.Relation.Binary.Equality.Cast</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- An equational reasoning library for propositional equality over</a>
<a id="173" class="Comment">-- vectors of different indices using cast.</a>
<a id="217" class="Comment">--</a>
<a id="220" class="Comment">-- To see example usages of this library, scroll to the `Combinators`</a>
<a id="290" class="Comment">-- section.</a>
<a id="302" class="Comment">------------------------------------------------------------------------</a>

<a id="376" class="Symbol">{-#</a> <a id="380" class="Keyword">OPTIONS</a> <a id="388" class="Pragma">--cubical-compatible</a> <a id="409" class="Pragma">--safe</a> <a id="416" class="Symbol">#-}</a>

<a id="421" class="Keyword">module</a> <a id="428" href="README.Data.Vec.Relation.Binary.Equality.Cast.html" class="Module">README.Data.Vec.Relation.Binary.Equality.Cast</a> <a id="474" class="Keyword">where</a>

<a id="481" class="Keyword">open</a> <a id="486" class="Keyword">import</a> <a id="493" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>
<a id="508" class="Keyword">open</a> <a id="513" class="Keyword">import</a> <a id="520" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="535" class="Symbol">as</a> <a id="538" class="Module">List</a> <a id="543" class="Keyword">using</a> <a id="549" class="Symbol">(</a><a id="550" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="554" class="Symbol">)</a>
<a id="556" class="Keyword">import</a> <a id="563" href="Data.List.Properties.html" class="Module">Data.List.Properties</a> <a id="584" class="Symbol">as</a> <a id="587" class="Module">List</a>
<a id="592" class="Keyword">open</a> <a id="597" class="Keyword">import</a> <a id="604" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="618" class="Keyword">open</a> <a id="623" class="Keyword">import</a> <a id="630" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="650" class="Keyword">open</a> <a id="655" class="Keyword">import</a> <a id="662" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>
<a id="676" class="Keyword">open</a> <a id="681" class="Keyword">import</a> <a id="688" href="Data.Vec.Properties.html" class="Module">Data.Vec.Properties</a>
<a id="708" class="Keyword">open</a> <a id="713" class="Keyword">import</a> <a id="720" href="Data.Vec.Relation.Binary.Equality.Cast.html" class="Module">Data.Vec.Relation.Binary.Equality.Cast</a>
<a id="759" class="Keyword">open</a> <a id="764" class="Keyword">import</a> <a id="771" href="Function.html" class="Module">Function</a> <a id="780" class="Keyword">using</a> <a id="786" class="Symbol">(</a><a id="787" href="Function.Base.html#1115" class="Function Operator">_∘_</a><a id="790" class="Symbol">)</a>
<a id="792" class="Keyword">open</a> <a id="797" class="Keyword">import</a> <a id="804" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="844" class="Keyword">using</a> <a id="850" class="Symbol">(</a><a id="851" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="854" class="Symbol">;</a> <a id="856" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="860" class="Symbol">;</a> <a id="862" href="Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="865" class="Symbol">;</a> <a id="867" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="871" class="Symbol">;</a> <a id="873" class="Keyword">module</a> <a id="880" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a><a id="891" class="Symbol">)</a>

<a id="894" class="Keyword">private</a> <a id="902" class="Keyword">variable</a>
  <a id="913" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#913" class="Generalizable">a</a> <a id="915" class="Symbol">:</a> <a id="917" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="925" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="927" class="Symbol">:</a> <a id="929" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="933" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#913" class="Generalizable">a</a>
  <a id="937" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#937" class="Generalizable">l</a> <a id="939" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="941" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="943" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#943" class="Generalizable">o</a> <a id="945" class="Symbol">:</a> <a id="947" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="951" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#951" class="Generalizable">xs</a> <a id="954" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#954" class="Generalizable">ys</a> <a id="957" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#957" class="Generalizable">zs</a> <a id="960" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#960" class="Generalizable">ws</a> <a id="963" class="Symbol">:</a> <a id="965" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="969" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="971" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a>


<a id="975" class="Comment">------------------------------------------------------------------------</a>
<a id="1048" class="Comment">-- Motivation</a>
<a id="1062" class="Comment">--</a>
<a id="1065" class="Comment">-- The `cast` function is the computational variant of `subst` for</a>
<a id="1132" class="Comment">-- vectors. Since `cast` computes under vector constructors, it</a>
<a id="1196" class="Comment">-- enables reasoning about vectors with non-definitionally equal indices</a>
<a id="1269" class="Comment">-- by induction. See, e.g., Jacques Carette&#39;s comment in issue #1668.</a>
<a id="1339" class="Comment">-- &lt;https://github.com/agda/agda-stdlib/pull/1668#issuecomment-1003449509&gt;</a>
<a id="1414" class="Comment">--</a>
<a id="1417" class="Comment">-- Suppose we want to prove that ‘xs ++ [] ≡ xs’. Because `xs ++ []`</a>
<a id="1486" class="Comment">-- has type `Vec A (n + 0)` while `xs` has type `Vec A n`, they cannot</a>
<a id="1557" class="Comment">-- be directly related by homogeneous equality.</a>
<a id="1605" class="Comment">-- To resolve the issue, `++-right-identity` uses `cast` to recast</a>
<a id="1672" class="Comment">-- `xs ++ []` as a vector in `Vec A n`.</a>
<a id="1712" class="Comment">--</a>
<a id="++-right-identity"></a><a id="1715" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1715" class="Function">++-right-identity</a> <a id="1733" class="Symbol">:</a> <a id="1735" class="Symbol">∀</a> <a id="1737" class="Symbol">.(</a><a id="1739" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1739" class="Bound">eq</a> <a id="1742" class="Symbol">:</a> <a id="1744" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="1746" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="1748" class="Number">0</a> <a id="1750" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1752" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="1753" class="Symbol">)</a> <a id="1755" class="Symbol">(</a><a id="1756" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1756" class="Bound">xs</a> <a id="1759" class="Symbol">:</a> <a id="1761" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="1765" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="1767" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="1768" class="Symbol">)</a> <a id="1770" class="Symbol">→</a> <a id="1772" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="1777" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1739" class="Bound">eq</a> <a id="1780" class="Symbol">(</a><a id="1781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1756" class="Bound">xs</a> <a id="1784" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="1787" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a><a id="1789" class="Symbol">)</a> <a id="1791" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1793" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1756" class="Bound">xs</a>
<a id="1796" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1715" class="Function">++-right-identity</a> <a id="1814" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1814" class="Bound">eq</a> <a id="1817" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a>       <a id="1826" class="Symbol">=</a> <a id="1828" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="1833" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1715" class="Function">++-right-identity</a> <a id="1851" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1851" class="Bound">eq</a> <a id="1854" class="Symbol">(</a><a id="1855" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1855" class="Bound">x</a> <a id="1857" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="1859" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1859" class="Bound">xs</a><a id="1861" class="Symbol">)</a> <a id="1863" class="Symbol">=</a> <a id="1865" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1870" class="Symbol">(</a><a id="1871" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1855" class="Bound">x</a> <a id="1873" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷_</a><a id="1875" class="Symbol">)</a> <a id="1877" class="Symbol">(</a><a id="1878" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1715" class="Function">++-right-identity</a> <a id="1896" class="Symbol">(</a><a id="1897" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1902" href="Data.Nat.Base.html#5272" class="Function">pred</a> <a id="1907" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1851" class="Bound">eq</a><a id="1909" class="Symbol">)</a> <a id="1911" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1859" class="Bound">xs</a><a id="1913" class="Symbol">)</a>
<a id="1915" class="Comment">--</a>
<a id="1918" class="Comment">-- When the input is `x ∷ xs`, because `cast eq (x ∷ _)` equals</a>
<a id="1982" class="Comment">-- `x ∷ cast (cong pred eq) _`, the proof obligation</a>
<a id="2035" class="Comment">--     cast eq (x ∷ xs ++ []) ≡ x ∷ xs</a>
<a id="2074" class="Comment">-- simplifies to</a>
<a id="2091" class="Comment">--     x :: cast (cong pred eq) (xs ++ []) ≡ x ∷ xs</a>


<a id="2145" class="Comment">-- Although `cast` makes it possible to prove vector identities by ind-</a>
<a id="2217" class="Comment">-- uction, the explicit type-casting nature poses a significant barrier</a>
<a id="2289" class="Comment">-- to code reuse in larger proofs. For example, consider the identity</a>
<a id="2359" class="Comment">-- ‘fromList (xs List.∷ʳ x) ≡ (fromList xs) ∷ʳ x’ where `List._∷ʳ_` is the</a>
<a id="2434" class="Comment">-- snoc function of lists. We have</a>
<a id="2469" class="Comment">--</a>
<a id="2472" class="Comment">--     fromList (xs List.∷ʳ x)            : Vec A (List.length (xs List.∷ʳ x))</a>
<a id="2551" class="Comment">--   =   {- by definition -}</a>
<a id="2580" class="Comment">--     fromList (xs List.++ List.[ x ])   : Vec A (List.length (xs List.++ List.[ x ]))</a>
<a id="2668" class="Comment">--   =   {- by fromList-++ -}</a>
<a id="2698" class="Comment">--     fromList xs ++ fromList List.[ x ] : Vec A (List.length xs + List.length [ x ])</a>
<a id="2785" class="Comment">--   =   {- by definition -}</a>
<a id="2814" class="Comment">--     fromList xs ++ [ x ]               : Vec A (List.length xs + 1)</a>
<a id="2885" class="Comment">--   =   {- by unfold-∷ʳ -}</a>
<a id="2913" class="Comment">--     fromList xs ∷ʳ x                   : Vec A (suc (List.length xs))</a>
<a id="2986" class="Comment">-- where</a>
<a id="2995" class="Comment">--     fromList-++ : cast _ (fromList (xs List.++ ys)) ≡ fromList xs ++ fromList ys</a>
<a id="3079" class="Comment">--     unfold-∷ʳ   : cast _ (xs ∷ʳ x) ≡ xs ++ [ x ]</a>
<a id="3131" class="Comment">--</a>
<a id="3134" class="Comment">-- Although the identity itself is simple, the reasoning process changes</a>
<a id="3207" class="Comment">-- the index in the type twice. Consequently, its Agda translation must</a>
<a id="3279" class="Comment">-- insert two `cast`s in the proof. Moreover, the proof first has to</a>
<a id="3348" class="Comment">-- rearrange (the Agda version of) the identity into one with two</a>
<a id="3414" class="Comment">-- `cast`s, resulting in lots of boilerplate code as demonstrated by</a>
<a id="3483" class="Comment">-- `example1a-fromList-∷ʳ`.</a>
<a id="example1a-fromList-∷ʳ"></a><a id="3511" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3511" class="Function">example1a-fromList-∷ʳ</a> <a id="3533" class="Symbol">:</a> <a id="3535" class="Symbol">∀</a> <a id="3537" class="Symbol">(</a><a id="3538" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3538" class="Bound">x</a> <a id="3540" class="Symbol">:</a> <a id="3542" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="3543" class="Symbol">)</a> <a id="3545" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a> <a id="3548" class="Symbol">→</a>
                        <a id="3574" class="Symbol">.(</a><a id="3576" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3576" class="Bound">eq</a> <a id="3579" class="Symbol">:</a> <a id="3581" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="3593" class="Symbol">(</a><a id="3594" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a> <a id="3597" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3605" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3538" class="Bound">x</a><a id="3606" class="Symbol">)</a> <a id="3608" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3610" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3614" class="Symbol">(</a><a id="3615" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="3627" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a><a id="3629" class="Symbol">))</a> <a id="3632" class="Symbol">→</a>
                        <a id="3658" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3663" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3576" class="Bound">eq</a> <a id="3666" class="Symbol">(</a><a id="3667" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3676" class="Symbol">(</a><a id="3677" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a> <a id="3680" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3688" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3538" class="Bound">x</a><a id="3689" class="Symbol">))</a> <a id="3692" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3694" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3703" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3545" class="Bound">xs</a> <a id="3706" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="3709" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3538" class="Bound">x</a>
<a id="3711" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3511" class="Function">example1a-fromList-∷ʳ</a> <a id="3733" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="3735" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3738" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3738" class="Bound">eq</a> <a id="3741" class="Symbol">=</a> <a id="3743" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="3751" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3756" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3738" class="Bound">eq</a> <a id="3759" class="Symbol">(</a><a id="3760" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3769" class="Symbol">(</a><a id="3770" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3773" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a><a id="3782" class="Symbol">))</a>
    <a id="3789" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
  <a id="3795" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3800" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3738" class="Bound">eq</a> <a id="3803" class="Symbol">(</a><a id="3804" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3813" class="Symbol">(</a><a id="3814" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3817" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3825" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3832" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="3834" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3835" class="Symbol">))</a>
    <a id="3842" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="3845" href="Data.Vec.Relation.Binary.Equality.Cast.html#1225" class="Function">cast-trans</a> <a id="3856" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4138" class="Function">eq₁</a> <a id="3860" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a> <a id="3864" class="Symbol">(</a><a id="3865" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3874" class="Symbol">(</a><a id="3875" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3878" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3886" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3893" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="3895" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3896" class="Symbol">))</a> <a id="3899" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="3903" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3908" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a> <a id="3912" class="Symbol">(</a><a id="3913" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4138" class="Function">eq₁</a> <a id="3922" class="Symbol">(</a><a id="3923" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3932" class="Symbol">(</a><a id="3933" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="3936" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3944" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3951" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="3953" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3954" class="Symbol">)))</a>
    <a id="3962" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="3965" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="3970" class="Symbol">(</a><a id="3971" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3976" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a><a id="3979" class="Symbol">)</a> <a id="3981" class="Symbol">(</a><a id="3982" href="Data.Vec.Properties.html#53201" class="Function">fromList-++</a> <a id="3994" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a><a id="3996" class="Symbol">)</a> <a id="3998" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="4002" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="4007" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a> <a id="4011" class="Symbol">(</a><a id="4012" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4021" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="4024" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="4027" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="4029" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="4031" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="4032" class="Symbol">)</a>
    <a id="4038" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="4041" href="Data.Vec.Relation.Binary.Equality.Cast.html#1914" class="Function">≈-sym</a> <a id="4047" class="Symbol">(</a><a id="4048" href="Data.Vec.Properties.html#35192" class="Function">unfold-∷ʳ-eqFree</a> <a id="4065" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="4067" class="Symbol">(</a><a id="4068" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4077" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a><a id="4079" class="Symbol">))</a> <a id="4082" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="4086" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4095" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="4098" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4101" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a>
    <a id="4107" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
  <a id="4111" class="Keyword">where</a>
  <a id="4119" class="Keyword">open</a> <a id="4124" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
  <a id="4138" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4138" class="Function">eq₁</a> <a id="4142" class="Symbol">=</a> <a id="4144" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="4159" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a> <a id="4162" class="Symbol">{</a><a id="4163" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="4170" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3733" class="Bound">x</a> <a id="4172" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="4173" class="Symbol">}</a>
  <a id="4177" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4177" class="Function">eq₂</a> <a id="4181" class="Symbol">=</a> <a id="4183" href="Data.Nat.Properties.html#15642" class="Function">+-comm</a> <a id="4190" class="Symbol">(</a><a id="4191" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4203" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3735" class="Bound">xs</a><a id="4205" class="Symbol">)</a> <a id="4207" class="Number">1</a>

<a id="4210" class="Comment">-- The `cast`s are irrelevant to core of the proof. At the same time,</a>
<a id="4280" class="Comment">-- they can be inferred from the lemmas used during the reasoning steps</a>
<a id="4352" class="Comment">-- (e.g. `fromList-++` and `unfold-∷ʳ`). To eliminate the boilerplate,</a>
<a id="4423" class="Comment">-- this library provides a set of equational reasoning combinators for</a>
<a id="4494" class="Comment">-- equality of the form `cast eq xs ≡ ys`.</a>
<a id="example1b-fromList-∷ʳ"></a><a id="4537" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4537" class="Function">example1b-fromList-∷ʳ</a> <a id="4559" class="Symbol">:</a> <a id="4561" class="Symbol">∀</a> <a id="4563" class="Symbol">(</a><a id="4564" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4564" class="Bound">x</a> <a id="4566" class="Symbol">:</a> <a id="4568" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="4569" class="Symbol">)</a> <a id="4571" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a> <a id="4574" class="Symbol">→</a>
                        <a id="4600" class="Symbol">.(</a><a id="4602" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4602" class="Bound">eq</a> <a id="4605" class="Symbol">:</a> <a id="4607" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4619" class="Symbol">(</a><a id="4620" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a> <a id="4623" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4631" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4564" class="Bound">x</a><a id="4632" class="Symbol">)</a> <a id="4634" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4636" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4640" class="Symbol">(</a><a id="4641" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4653" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a><a id="4655" class="Symbol">))</a> <a id="4658" class="Symbol">→</a>
                        <a id="4684" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="4689" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4602" class="Bound">eq</a> <a id="4692" class="Symbol">(</a><a id="4693" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4702" class="Symbol">(</a><a id="4703" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a> <a id="4706" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4714" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4564" class="Bound">x</a><a id="4715" class="Symbol">))</a> <a id="4718" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4720" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4729" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4571" class="Bound">xs</a> <a id="4732" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4735" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4564" class="Bound">x</a>
<a id="4737" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4537" class="Function">example1b-fromList-∷ʳ</a> <a id="4759" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a> <a id="4761" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4764" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4764" class="Bound">eq</a> <a id="4767" class="Symbol">=</a> <a id="4769" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="4777" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4786" class="Symbol">(</a><a id="4787" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4790" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4798" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a><a id="4799" class="Symbol">)</a>
    <a id="4805" href="Data.Vec.Relation.Binary.Equality.Cast.html#3407" class="Function Operator">≈⟨⟩</a>
  <a id="4811" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4820" class="Symbol">(</a><a id="4821" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4824" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="4832" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="4839" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a> <a id="4841" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="4842" class="Symbol">)</a>
    <a id="4848" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="4851" href="Data.Vec.Properties.html#53201" class="Function">fromList-++</a> <a id="4863" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4866" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="4870" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4879" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4882" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="4885" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="4887" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a> <a id="4889" href="Data.Vec.Base.html#6459" class="Function Operator">]</a>
    <a id="4895" href="Data.Vec.Relation.Binary.Equality.Cast.html#3755" class="Function">≈⟨</a> <a id="4898" href="Data.Vec.Properties.html#35192" class="Function">unfold-∷ʳ-eqFree</a> <a id="4915" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a> <a id="4917" class="Symbol">(</a><a id="4918" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4927" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a><a id="4929" class="Symbol">)</a> <a id="4931" href="Data.Vec.Relation.Binary.Equality.Cast.html#3755" class="Function">⟨</a>
  <a id="4935" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4944" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4761" class="Bound">xs</a> <a id="4947" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4950" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4759" class="Bound">x</a>
    <a id="4956" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="4960" class="Keyword">where</a> <a id="4966" class="Keyword">open</a> <a id="4971" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>


<a id="4987" class="Comment">------------------------------------------------------------------------</a>
<a id="5060" class="Comment">-- Combinators</a>
<a id="5075" class="Comment">--</a>
<a id="5078" class="Comment">-- Let `xs ≈[ m≡n ] ys` denote `cast m≡n xs ≡ ys`. We have reflexivity,</a>
<a id="5150" class="Comment">-- symmetry and transitivity:</a>
<a id="5180" class="Comment">--     ≈-reflexive : xs ≈[ refl ] xs</a>
<a id="5217" class="Comment">--     ≈-sym       : xs ≈[ m≡n ] ys → ys ≈[ sym m≡n ] xs</a>
<a id="5274" class="Comment">--     ≈-trans     : xs ≈[ m≡n ] ys → ys ≈[ n≡o ] zs → xs ≈[ trans m≡n n≡o ] zs</a>
<a id="5354" class="Comment">-- Accordingly, `_≈[_]_` admits the standard set of equational reasoning</a>
<a id="5427" class="Comment">-- combinators. Suppose `≈-eqn : xs ≈[ m≡n ] ys`,</a>
<a id="5477" class="Comment">--     xs ≈⟨ ≈-eqn ⟩   -- `_≈⟨_⟩_` takes a `_≈[_]_` step, adjusting</a>
<a id="5545" class="Comment">--     ys              -- the index at the same time</a>
<a id="5598" class="Comment">--</a>
<a id="5601" class="Comment">--     ys ≈⟨ ≈-eqn ⟨   -- `_≈⟨_⟨_` takes a symmetric `_≈[_]_` step</a>
<a id="5668" class="Comment">--     xs</a>
<a id="example2a"></a><a id="5678" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5678" class="Function">example2a</a> <a id="5688" class="Symbol">:</a> <a id="5690" class="Symbol">∀</a> <a id="5692" class="Symbol">.(</a><a id="5694" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5694" class="Bound">eq</a> <a id="5697" class="Symbol">:</a> <a id="5699" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5703" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="5705" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="5707" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="5709" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5711" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="5713" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="5715" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5719" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="5720" class="Symbol">)</a> <a id="5722" class="Symbol">(</a><a id="5723" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5723" class="Bound">xs</a> <a id="5726" class="Symbol">:</a> <a id="5728" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="5732" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="5734" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a><a id="5735" class="Symbol">)</a> <a id="5737" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5737" class="Bound">a</a> <a id="5739" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5739" class="Bound">ys</a> <a id="5742" class="Symbol">→</a>
            <a id="5756" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="5761" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5694" class="Bound">eq</a> <a id="5764" class="Symbol">((</a><a id="5766" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5774" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5723" class="Bound">xs</a> <a id="5777" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="5780" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5737" class="Bound">a</a><a id="5781" class="Symbol">)</a> <a id="5783" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5786" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5739" class="Bound">ys</a><a id="5788" class="Symbol">)</a> <a id="5790" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5792" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5800" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5723" class="Bound">xs</a> <a id="5803" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5806" class="Symbol">(</a><a id="5807" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5737" class="Bound">a</a> <a id="5809" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="5811" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5739" class="Bound">ys</a><a id="5813" class="Symbol">)</a>
<a id="5815" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5678" class="Function">example2a</a> <a id="5825" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5825" class="Bound">eq</a> <a id="5828" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5828" class="Bound">xs</a> <a id="5831" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5831" class="Bound">a</a> <a id="5833" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5833" class="Bound">ys</a> <a id="5836" class="Symbol">=</a> <a id="5838" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="5846" class="Symbol">(</a><a id="5847" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5855" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5828" class="Bound">xs</a> <a id="5858" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="5861" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5831" class="Bound">a</a><a id="5862" class="Symbol">)</a> <a id="5864" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5867" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5833" class="Bound">ys</a> <a id="5870" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="5873" href="Data.Vec.Properties.html#37292" class="Function">∷ʳ-++-eqFree</a> <a id="5886" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5831" class="Bound">a</a> <a id="5888" class="Symbol">(</a><a id="5889" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5897" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5828" class="Bound">xs</a><a id="5899" class="Symbol">)</a> <a id="5901" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a> <a id="5903" class="Comment">-- index: suc m + n</a>
  <a id="5925" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5933" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5828" class="Bound">xs</a> <a id="5936" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5939" class="Symbol">(</a><a id="5940" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5831" class="Bound">a</a> <a id="5942" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="5944" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5833" class="Bound">ys</a><a id="5946" class="Symbol">)</a>  <a id="5949" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>                                <a id="5982" class="Comment">-- index: m + suc n</a>
  <a id="6004" class="Keyword">where</a> <a id="6010" class="Keyword">open</a> <a id="6015" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="6030" class="Comment">-- To interoperate with `_≡_`, this library provides `_≂⟨_⟩_` (\-~) for</a>
<a id="6102" class="Comment">-- taking a `_≡_` step during equational reasoning.</a>
<a id="6154" class="Comment">-- Let `≡-eqn : xs ≡ ys`, then</a>
<a id="6185" class="Comment">--     xs ≂⟨ ≡-eqn  ⟩    -- Takes a `_≡_` step; no change to the index</a>
<a id="6256" class="Comment">--     ys</a>
<a id="6266" class="Comment">--</a>
<a id="6269" class="Comment">--     ys ≂⟨ ≡-eqn ⟨    -- Takes a symmetric `_≡_` step</a>
<a id="6325" class="Comment">--     xs</a>
<a id="6335" class="Comment">-- Equivalently, `≈-reflexive` injects `_≡_` into `_≈[_]_`. That is,</a>
<a id="6404" class="Comment">-- `xs ≂⟨ ≡-eqn ⟩ ys` is the same as `xs ≈⟨ ≈-reflexive ≡-eqn ⟩ ys`.</a>
<a id="6473" class="Comment">-- Extending `example2a`, we have:</a>
<a id="example2b"></a><a id="6508" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6508" class="Function">example2b</a> <a id="6518" class="Symbol">:</a> <a id="6520" class="Symbol">∀</a> <a id="6522" class="Symbol">.(</a><a id="6524" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6524" class="Bound">eq</a> <a id="6527" class="Symbol">:</a> <a id="6529" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6533" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="6535" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="6537" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="6539" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6541" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="6543" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="6545" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6549" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="6550" class="Symbol">)</a> <a id="6552" class="Symbol">(</a><a id="6553" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6553" class="Bound">xs</a> <a id="6556" class="Symbol">:</a> <a id="6558" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="6562" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="6564" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a><a id="6565" class="Symbol">)</a> <a id="6567" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6567" class="Bound">a</a> <a id="6569" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6569" class="Bound">ys</a> <a id="6572" class="Symbol">→</a>
            <a id="6586" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="6591" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6524" class="Bound">eq</a> <a id="6594" class="Symbol">((</a><a id="6596" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6567" class="Bound">a</a> <a id="6598" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6600" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6553" class="Bound">xs</a><a id="6602" class="Symbol">)</a> <a id="6604" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6608" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6569" class="Bound">ys</a><a id="6610" class="Symbol">)</a> <a id="6612" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6614" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6553" class="Bound">xs</a> <a id="6617" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6621" class="Symbol">(</a><a id="6622" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6567" class="Bound">a</a> <a id="6624" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6626" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6569" class="Bound">ys</a><a id="6628" class="Symbol">)</a>
<a id="6630" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6508" class="Function">example2b</a> <a id="6640" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6640" class="Bound">eq</a> <a id="6643" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6646" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6648" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a> <a id="6651" class="Symbol">=</a> <a id="6653" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="6661" class="Symbol">(</a><a id="6662" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6664" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6666" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6668" class="Symbol">)</a> <a id="6670" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6674" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a>         <a id="6685" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">≂⟨</a> <a id="6688" href="Data.Vec.Properties.html#41443" class="Function">unfold-ʳ++</a> <a id="6699" class="Symbol">(</a><a id="6700" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6702" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6704" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6706" class="Symbol">)</a> <a id="6708" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a> <a id="6711" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">⟩</a>          <a id="6722" class="Comment">-- index: suc m + n</a>
  <a id="6744" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6752" class="Symbol">(</a><a id="6753" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6755" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6757" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6759" class="Symbol">)</a> <a id="6761" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6764" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a>  <a id="6768" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">≂⟨</a> <a id="6771" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="6776" class="Symbol">(</a><a id="6777" href="Data.Vec.Base.html#3076" class="Function Operator">_++</a> <a id="6781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a><a id="6783" class="Symbol">)</a> <a id="6785" class="Symbol">(</a><a id="6786" href="Data.Vec.Properties.html#37682" class="Function">reverse-∷</a> <a id="6796" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6798" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6800" class="Symbol">)</a> <a id="6802" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">⟩</a>  <a id="6805" class="Comment">-- index: suc m + n</a>
  <a id="6827" class="Symbol">(</a><a id="6828" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6836" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6839" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="6842" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a><a id="6843" class="Symbol">)</a> <a id="6845" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6848" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a> <a id="6851" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="6854" href="Data.Vec.Properties.html#37292" class="Function">∷ʳ-++-eqFree</a> <a id="6867" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6869" class="Symbol">(</a><a id="6870" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6878" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a><a id="6880" class="Symbol">)</a> <a id="6882" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>     <a id="6888" class="Comment">-- index: suc m + n</a>
  <a id="6910" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6921" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6924" class="Symbol">(</a><a id="6925" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6927" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6929" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a><a id="6931" class="Symbol">)</a>  <a id="6934" href="Data.Vec.Relation.Binary.Equality.Cast.html#4634" class="Function">≂⟨</a> <a id="6937" href="Data.Vec.Properties.html#41443" class="Function">unfold-ʳ++</a> <a id="6948" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6951" class="Symbol">(</a><a id="6952" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="6954" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6956" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a><a id="6958" class="Symbol">)</a> <a id="6960" href="Data.Vec.Relation.Binary.Equality.Cast.html#4634" class="Function">⟨</a>          <a id="6971" class="Comment">-- index: m + suc n</a>
  <a id="6993" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6643" class="Bound">xs</a> <a id="6996" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="7000" class="Symbol">(</a><a id="7001" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6646" class="Bound">a</a> <a id="7003" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="7005" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6648" class="Bound">ys</a><a id="7007" class="Symbol">)</a>         <a id="7017" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>                                    <a id="7054" class="Comment">-- index: m + suc n</a>
  <a id="7076" class="Keyword">where</a> <a id="7082" class="Keyword">open</a> <a id="7087" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="7102" class="Comment">-- Oftentimes index-changing identities apply to only part of the proof</a>
<a id="7174" class="Comment">-- term. When reasoning about `_≡_`, `cong` shifts the focus to the</a>
<a id="7242" class="Comment">-- subterm of interest. In this library, `≈-cong′` does a similar job.</a>
<a id="7313" class="Comment">-- For the typechecker to infer the congruence function `f`, it must be</a>
<a id="7385" class="Comment">-- polymorphic in the length of the given vector,</a>
<a id="example3a-fromList-++-++"></a><a id="7435" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7435" class="Function">example3a-fromList-++-++</a> <a id="7460" class="Symbol">:</a> <a id="7462" class="Symbol">{</a><a id="7463" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7463" class="Bound">xs</a> <a id="7466" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7466" class="Bound">ys</a> <a id="7469" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7469" class="Bound">zs</a> <a id="7472" class="Symbol">:</a> <a id="7474" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="7479" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="7480" class="Symbol">}</a> <a id="7482" class="Symbol">→</a>
                           <a id="7511" class="Symbol">.(</a><a id="7513" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7513" class="Bound">eq</a> <a id="7516" class="Symbol">:</a> <a id="7518" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="7530" class="Symbol">(</a><a id="7531" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7463" class="Bound">xs</a> <a id="7534" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="7542" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7466" class="Bound">ys</a> <a id="7545" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="7553" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7469" class="Bound">zs</a><a id="7555" class="Symbol">)</a> <a id="7557" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                  <a id="7593" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="7605" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7463" class="Bound">xs</a> <a id="7608" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="7610" class="Symbol">(</a><a id="7611" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="7623" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7466" class="Bound">ys</a> <a id="7626" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="7628" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="7640" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7469" class="Bound">zs</a><a id="7642" class="Symbol">))</a> <a id="7645" class="Symbol">→</a>
                           <a id="7674" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="7679" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7513" class="Bound">eq</a> <a id="7682" class="Symbol">(</a><a id="7683" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="7692" class="Symbol">(</a><a id="7693" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7463" class="Bound">xs</a> <a id="7696" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="7704" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7466" class="Bound">ys</a> <a id="7707" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="7715" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7469" class="Bound">zs</a><a id="7717" class="Symbol">))</a> <a id="7720" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="7757" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="7766" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7463" class="Bound">xs</a> <a id="7769" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="7772" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="7781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7466" class="Bound">ys</a> <a id="7784" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="7787" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="7796" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7469" class="Bound">zs</a>
<a id="7799" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7435" class="Function">example3a-fromList-++-++</a> <a id="7824" class="Symbol">{</a><a id="7825" class="Argument">xs</a> <a id="7828" class="Symbol">=</a> <a id="7830" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7830" class="Bound">xs</a><a id="7832" class="Symbol">}</a> <a id="7834" class="Symbol">{</a><a id="7835" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7835" class="Bound">ys</a><a id="7837" class="Symbol">}</a> <a id="7839" class="Symbol">{</a><a id="7840" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7840" class="Bound">zs</a><a id="7842" class="Symbol">}</a> <a id="7844" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7844" class="Bound">eq</a> <a id="7847" class="Symbol">=</a> <a id="7849" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="7857" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="7866" class="Symbol">(</a><a id="7867" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7830" class="Bound">xs</a> <a id="7870" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="7878" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7835" class="Bound">ys</a> <a id="7881" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="7889" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7840" class="Bound">zs</a><a id="7891" class="Symbol">)</a>
    <a id="7897" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="7900" href="Data.Vec.Properties.html#53201" class="Function">fromList-++</a> <a id="7912" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7830" class="Bound">xs</a> <a id="7915" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="7919" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="7928" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7830" class="Bound">xs</a> <a id="7931" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="7934" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="7943" class="Symbol">(</a><a id="7944" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7835" class="Bound">ys</a> <a id="7947" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="7955" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7840" class="Bound">zs</a><a id="7957" class="Symbol">)</a>
    <a id="7963" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="7966" href="Data.Vec.Relation.Binary.Equality.Cast.html#2663" class="Function">≈-cong′</a> <a id="7974" class="Symbol">(</a><a id="7975" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="7984" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7830" class="Bound">xs</a> <a id="7987" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="7990" class="Symbol">)</a> <a id="7992" class="Symbol">(</a><a id="7993" href="Data.Vec.Properties.html#53201" class="Function">fromList-++</a> <a id="8005" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7835" class="Bound">ys</a><a id="8007" class="Symbol">)</a> <a id="8009" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="8013" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8022" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7830" class="Bound">xs</a> <a id="8025" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8028" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8037" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7835" class="Bound">ys</a> <a id="8040" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8043" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8052" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7840" class="Bound">zs</a>
    <a id="8059" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="8063" class="Keyword">where</a> <a id="8069" class="Keyword">open</a> <a id="8074" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="8089" class="Comment">-- As an alternative, one can manually apply `cast-++ʳ` to expose `cast`</a>
<a id="8162" class="Comment">-- in the subterm. However, this unavoidably duplicates the proof term.</a>
<a id="example3b-fromList-++-++′"></a><a id="8234" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8234" class="Function">example3b-fromList-++-++′</a> <a id="8260" class="Symbol">:</a> <a id="8262" class="Symbol">{</a><a id="8263" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8263" class="Bound">xs</a> <a id="8266" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8266" class="Bound">ys</a> <a id="8269" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8269" class="Bound">zs</a> <a id="8272" class="Symbol">:</a> <a id="8274" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="8279" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="8280" class="Symbol">}</a> <a id="8282" class="Symbol">→</a>
                            <a id="8312" class="Symbol">.(</a><a id="8314" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8314" class="Bound">eq</a> <a id="8317" class="Symbol">:</a> <a id="8319" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8331" class="Symbol">(</a><a id="8332" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8263" class="Bound">xs</a> <a id="8335" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8343" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8266" class="Bound">ys</a> <a id="8346" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8354" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8269" class="Bound">zs</a><a id="8356" class="Symbol">)</a> <a id="8358" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="8395" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8407" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8263" class="Bound">xs</a> <a id="8410" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8412" class="Symbol">(</a><a id="8413" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8425" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8266" class="Bound">ys</a> <a id="8428" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8430" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8442" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8269" class="Bound">zs</a><a id="8444" class="Symbol">))</a> <a id="8447" class="Symbol">→</a>
                            <a id="8477" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="8482" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8314" class="Bound">eq</a> <a id="8485" class="Symbol">(</a><a id="8486" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8495" class="Symbol">(</a><a id="8496" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8263" class="Bound">xs</a> <a id="8499" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8507" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8266" class="Bound">ys</a> <a id="8510" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8518" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8269" class="Bound">zs</a><a id="8520" class="Symbol">))</a> <a id="8523" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                    <a id="8561" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8570" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8263" class="Bound">xs</a> <a id="8573" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8576" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8585" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8266" class="Bound">ys</a> <a id="8588" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8591" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8600" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8269" class="Bound">zs</a>
<a id="8603" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8234" class="Function">example3b-fromList-++-++′</a> <a id="8629" class="Symbol">{</a><a id="8630" class="Argument">xs</a> <a id="8633" class="Symbol">=</a> <a id="8635" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8635" class="Bound">xs</a><a id="8637" class="Symbol">}</a> <a id="8639" class="Symbol">{</a><a id="8640" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8640" class="Bound">ys</a><a id="8642" class="Symbol">}</a> <a id="8644" class="Symbol">{</a><a id="8645" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8645" class="Bound">zs</a><a id="8647" class="Symbol">}</a> <a id="8649" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8649" class="Bound">eq</a> <a id="8652" class="Symbol">=</a> <a id="8654" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="8662" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8671" class="Symbol">(</a><a id="8672" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8635" class="Bound">xs</a> <a id="8675" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8683" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8640" class="Bound">ys</a> <a id="8686" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8694" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8645" class="Bound">zs</a><a id="8696" class="Symbol">)</a>
    <a id="8702" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="8705" href="Data.Vec.Properties.html#53201" class="Function">fromList-++</a> <a id="8717" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8635" class="Bound">xs</a> <a id="8720" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="8724" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8733" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8635" class="Bound">xs</a> <a id="8736" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8739" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8748" class="Symbol">(</a><a id="8749" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8640" class="Bound">ys</a> <a id="8752" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8760" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8645" class="Bound">zs</a><a id="8762" class="Symbol">)</a>
    <a id="8768" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="8771" href="Data.Vec.Properties.html#19928" class="Function">cast-++ʳ</a> <a id="8780" class="Symbol">(</a><a id="8781" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="8796" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8640" class="Bound">ys</a><a id="8798" class="Symbol">)</a> <a id="8800" class="Symbol">(</a><a id="8801" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8810" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8635" class="Bound">xs</a><a id="8812" class="Symbol">)</a> <a id="8814" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="8818" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8827" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8635" class="Bound">xs</a> <a id="8830" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8833" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="8838" class="Symbol">_</a> <a id="8840" class="Symbol">(</a><a id="8841" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8850" class="Symbol">(</a><a id="8851" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8640" class="Bound">ys</a> <a id="8854" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8862" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8645" class="Bound">zs</a><a id="8864" class="Symbol">))</a>
    <a id="8871" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">≂⟨</a> <a id="8874" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="8879" class="Symbol">(</a><a id="8880" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8889" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8635" class="Bound">xs</a> <a id="8892" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="8895" class="Symbol">)</a> <a id="8897" class="Symbol">(</a><a id="8898" href="Data.Vec.Properties.html#53201" class="Function">fromList-++</a> <a id="8910" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8640" class="Bound">ys</a><a id="8912" class="Symbol">)</a> <a id="8914" href="Data.Vec.Relation.Binary.Equality.Cast.html#4474" class="Function">⟩</a>
  <a id="8918" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8927" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8635" class="Bound">xs</a> <a id="8930" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8933" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8942" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8640" class="Bound">ys</a> <a id="8945" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8948" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8957" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8645" class="Bound">zs</a>
    <a id="8964" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="8968" class="Keyword">where</a> <a id="8974" class="Keyword">open</a> <a id="8979" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="8994" class="Comment">-- `≈-cong′` can be chained together much like how `cong` can be nested.</a>
<a id="9067" class="Comment">-- In this example, `unfold-∷ʳ` is applied to the term `xs ++ [ a ]`</a>
<a id="9136" class="Comment">-- in `(_++ ys)` inside of `reverse`. Thus the proof employs two</a>
<a id="9201" class="Comment">-- `≈-cong′` usages, which is equivalent to using one `≈-cong′` with</a>
<a id="9270" class="Comment">-- a single composed function.</a>
<a id="example4-cong²"></a><a id="9301" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9301" class="Function">example4-cong²</a> <a id="9316" class="Symbol">:</a> <a id="9318" class="Symbol">∀</a> <a id="9320" class="Symbol">.(</a><a id="9322" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9322" class="Bound">eq</a> <a id="9325" class="Symbol">:</a> <a id="9327" class="Symbol">(</a><a id="9328" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a> <a id="9330" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9332" class="Number">1</a><a id="9333" class="Symbol">)</a> <a id="9335" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9337" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="9339" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9341" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a> <a id="9343" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9345" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9349" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a><a id="9350" class="Symbol">)</a> <a id="9352" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9352" class="Bound">a</a> <a id="9354" class="Symbol">(</a><a id="9355" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9355" class="Bound">xs</a> <a id="9358" class="Symbol">:</a> <a id="9360" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="9364" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="9366" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#939" class="Generalizable">m</a><a id="9367" class="Symbol">)</a> <a id="9369" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9369" class="Bound">ys</a> <a id="9372" class="Symbol">→</a>
          <a id="9384" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="9389" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9322" class="Bound">eq</a> <a id="9392" class="Symbol">(</a><a id="9393" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9401" class="Symbol">((</a><a id="9403" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9355" class="Bound">xs</a> <a id="9406" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9409" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="9411" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9352" class="Bound">a</a> <a id="9413" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="9414" class="Symbol">)</a> <a id="9416" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9419" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9369" class="Bound">ys</a><a id="9421" class="Symbol">))</a> <a id="9424" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9426" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9369" class="Bound">ys</a> <a id="9429" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="9433" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9441" class="Symbol">(</a><a id="9442" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9355" class="Bound">xs</a> <a id="9445" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="9448" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9352" class="Bound">a</a><a id="9449" class="Symbol">)</a>
<a id="9451" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9301" class="Function">example4-cong²</a> <a id="9466" class="Symbol">{</a><a id="9467" class="Argument">m</a> <a id="9469" class="Symbol">=</a> <a id="9471" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9471" class="Bound">m</a><a id="9472" class="Symbol">}</a> <a id="9474" class="Symbol">{</a><a id="9475" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9475" class="Bound">n</a><a id="9476" class="Symbol">}</a> <a id="9478" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9478" class="Bound">eq</a> <a id="9481" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9481" class="Bound">a</a> <a id="9483" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9483" class="Bound">xs</a> <a id="9486" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9486" class="Bound">ys</a> <a id="9489" class="Symbol">=</a> <a id="9491" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="9499" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9507" class="Symbol">((</a><a id="9509" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9483" class="Bound">xs</a> <a id="9512" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9515" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="9517" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9481" class="Bound">a</a> <a id="9519" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="9520" class="Symbol">)</a> <a id="9522" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9525" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9486" class="Bound">ys</a><a id="9527" class="Symbol">)</a>
    <a id="9533" href="Data.Vec.Relation.Binary.Equality.Cast.html#3755" class="Function">≈⟨</a> <a id="9536" href="Data.Vec.Relation.Binary.Equality.Cast.html#2663" class="Function">≈-cong′</a> <a id="9544" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9552" class="Symbol">(</a><a id="9553" href="Data.Vec.Relation.Binary.Equality.Cast.html#2663" class="Function">≈-cong′</a> <a id="9561" class="Symbol">(</a><a id="9562" href="Data.Vec.Base.html#3076" class="Function Operator">_++</a> <a id="9566" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9486" class="Bound">ys</a><a id="9568" class="Symbol">)</a> <a id="9570" class="Symbol">(</a><a id="9571" href="Data.Vec.Properties.html#35192" class="Function">unfold-∷ʳ-eqFree</a> <a id="9588" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9481" class="Bound">a</a> <a id="9590" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9483" class="Bound">xs</a><a id="9592" class="Symbol">))</a> <a id="9595" href="Data.Vec.Relation.Binary.Equality.Cast.html#3755" class="Function">⟨</a>
    <a id="9601" class="Comment">-- the same as ≈-cong′ (reverse ∘ (_++ ys)) ...</a>
  <a id="9651" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9659" class="Symbol">((</a><a id="9661" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9483" class="Bound">xs</a> <a id="9664" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="9667" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9481" class="Bound">a</a><a id="9668" class="Symbol">)</a> <a id="9670" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9673" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9486" class="Bound">ys</a><a id="9675" class="Symbol">)</a>
    <a id="9681" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="9684" href="Data.Vec.Properties.html#40502" class="Function">reverse-++-eqFree</a> <a id="9702" class="Symbol">(</a><a id="9703" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9483" class="Bound">xs</a> <a id="9706" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="9709" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9481" class="Bound">a</a><a id="9710" class="Symbol">)</a> <a id="9712" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9486" class="Bound">ys</a> <a id="9715" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="9719" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9727" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9486" class="Bound">ys</a> <a id="9730" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9733" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9741" class="Symbol">(</a><a id="9742" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9483" class="Bound">xs</a> <a id="9745" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="9748" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9481" class="Bound">a</a><a id="9749" class="Symbol">)</a>
    <a id="9755" href="Data.Vec.Relation.Binary.Equality.Cast.html#4634" class="Function">≂⟨</a> <a id="9758" href="Data.Vec.Properties.html#41443" class="Function">unfold-ʳ++</a> <a id="9769" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9486" class="Bound">ys</a> <a id="9772" class="Symbol">(</a><a id="9773" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9781" class="Symbol">(</a><a id="9782" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9483" class="Bound">xs</a> <a id="9785" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="9788" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9481" class="Bound">a</a><a id="9789" class="Symbol">))</a> <a id="9792" href="Data.Vec.Relation.Binary.Equality.Cast.html#4634" class="Function">⟨</a>
  <a id="9796" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9486" class="Bound">ys</a> <a id="9799" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="9803" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9811" class="Symbol">(</a><a id="9812" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9483" class="Bound">xs</a> <a id="9815" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="9818" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9481" class="Bound">a</a><a id="9819" class="Symbol">)</a>
    <a id="9825" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="9829" class="Keyword">where</a> <a id="9835" class="Keyword">open</a> <a id="9840" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="9855" class="Comment">------------------------------------------------------------------------</a>
<a id="9928" class="Comment">-- Interoperation between `_≈[_]_` and `_≡_`</a>
<a id="9973" class="Comment">--</a>
<a id="9976" class="Comment">-- This library is designed to interoperate with `_≡_`. Examples in the</a>
<a id="10048" class="Comment">-- combinators section showed how to apply `_≂⟨_⟩_` to take an `_≡_`</a>
<a id="10117" class="Comment">-- step during equational reasoning about `_≈[_]_`. Recall that</a>
<a id="10181" class="Comment">-- `xs ≈[ m≡n ] ys` is a shorthand for `cast m≡n xs ≡ ys`, the</a>
<a id="10244" class="Comment">-- combinator is essentially the composition of `_≡_` on the left-hand</a>
<a id="10315" class="Comment">-- side of `_≈[_]_`. Dually, the combinator `_≃⟨_⟩_` composes `_≡_` on</a>
<a id="10386" class="Comment">-- the right-hand side of `_≈[_]_`. Thus `_≃⟨_⟩_` intuitively ends the</a>
<a id="10457" class="Comment">-- reasoning system of `_≈[_]_` and switches back to the reasoning</a>
<a id="10524" class="Comment">-- system of `_≡_`.</a>
<a id="example5-fromList-++-++′"></a><a id="10544" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10544" class="Function">example5-fromList-++-++′</a> <a id="10569" class="Symbol">:</a> <a id="10571" class="Symbol">{</a><a id="10572" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10572" class="Bound">xs</a> <a id="10575" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10575" class="Bound">ys</a> <a id="10578" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10578" class="Bound">zs</a> <a id="10581" class="Symbol">:</a> <a id="10583" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="10588" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a><a id="10589" class="Symbol">}</a> <a id="10591" class="Symbol">→</a>
                           <a id="10620" class="Symbol">.(</a><a id="10622" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10622" class="Bound">eq</a> <a id="10625" class="Symbol">:</a> <a id="10627" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="10639" class="Symbol">(</a><a id="10640" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10572" class="Bound">xs</a> <a id="10643" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="10651" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10575" class="Bound">ys</a> <a id="10654" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="10662" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10578" class="Bound">zs</a><a id="10664" class="Symbol">)</a> <a id="10666" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                  <a id="10702" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="10714" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10572" class="Bound">xs</a> <a id="10717" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="10719" class="Symbol">(</a><a id="10720" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="10732" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10575" class="Bound">ys</a> <a id="10735" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="10737" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="10749" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10578" class="Bound">zs</a><a id="10751" class="Symbol">))</a> <a id="10754" class="Symbol">→</a>
                           <a id="10783" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="10788" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10622" class="Bound">eq</a> <a id="10791" class="Symbol">(</a><a id="10792" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="10801" class="Symbol">(</a><a id="10802" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10572" class="Bound">xs</a> <a id="10805" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="10813" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10575" class="Bound">ys</a> <a id="10816" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="10824" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10578" class="Bound">zs</a><a id="10826" class="Symbol">))</a> <a id="10829" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="10866" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="10875" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10572" class="Bound">xs</a> <a id="10878" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="10881" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="10890" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10575" class="Bound">ys</a> <a id="10893" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="10896" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="10905" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10578" class="Bound">zs</a>
<a id="10908" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10544" class="Function">example5-fromList-++-++′</a> <a id="10933" class="Symbol">{</a><a id="10934" class="Argument">xs</a> <a id="10937" class="Symbol">=</a> <a id="10939" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10939" class="Bound">xs</a><a id="10941" class="Symbol">}</a> <a id="10943" class="Symbol">{</a><a id="10944" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10944" class="Bound">ys</a><a id="10946" class="Symbol">}</a> <a id="10948" class="Symbol">{</a><a id="10949" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10949" class="Bound">zs</a><a id="10951" class="Symbol">}</a> <a id="10953" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10953" class="Bound">eq</a> <a id="10956" class="Symbol">=</a> <a id="10958" href="Data.Vec.Relation.Binary.Equality.Cast.html#3230" class="Function Operator">begin</a>
  <a id="10966" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="10975" class="Symbol">(</a><a id="10976" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10939" class="Bound">xs</a> <a id="10979" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="10987" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10944" class="Bound">ys</a> <a id="10990" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="10998" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10949" class="Bound">zs</a><a id="11000" class="Symbol">)</a>
    <a id="11006" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="11009" href="Data.Vec.Properties.html#53201" class="Function">fromList-++</a> <a id="11021" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10939" class="Bound">xs</a> <a id="11024" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="11028" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11037" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10939" class="Bound">xs</a> <a id="11040" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11043" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11052" class="Symbol">(</a><a id="11053" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10944" class="Bound">ys</a> <a id="11056" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11064" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10949" class="Bound">zs</a><a id="11066" class="Symbol">)</a>
    <a id="11072" href="Data.Vec.Relation.Binary.Equality.Cast.html#4082" class="Function">≃⟨</a> <a id="11075" href="Data.Vec.Properties.html#19928" class="Function">cast-++ʳ</a> <a id="11084" class="Symbol">(</a><a id="11085" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="11100" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10944" class="Bound">ys</a><a id="11102" class="Symbol">)</a> <a id="11104" class="Symbol">(</a><a id="11105" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11114" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10939" class="Bound">xs</a><a id="11116" class="Symbol">)</a> <a id="11118" href="Data.Vec.Relation.Binary.Equality.Cast.html#4082" class="Function">⟩</a>
  <a id="11122" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11131" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10939" class="Bound">xs</a> <a id="11134" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11137" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="11142" class="Symbol">_</a> <a id="11144" class="Symbol">(</a><a id="11145" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11154" class="Symbol">(</a><a id="11155" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10944" class="Bound">ys</a> <a id="11158" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11166" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10949" class="Bound">zs</a><a id="11168" class="Symbol">))</a>
    <a id="11175" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="11178" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="11183" class="Symbol">(</a><a id="11184" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11193" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10939" class="Bound">xs</a> <a id="11196" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="11199" class="Symbol">)</a> <a id="11201" class="Symbol">(</a><a id="11202" href="Data.Vec.Properties.html#53201" class="Function">fromList-++</a> <a id="11214" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10944" class="Bound">ys</a><a id="11216" class="Symbol">)</a> <a id="11218" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="11222" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11231" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10939" class="Bound">xs</a> <a id="11234" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11237" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11246" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10944" class="Bound">ys</a> <a id="11249" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11252" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11261" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#10949" class="Bound">zs</a>
    <a id="11268" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">≡-∎</a>
  <a id="11274" class="Keyword">where</a> <a id="11280" class="Keyword">open</a> <a id="11285" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="11300" class="Comment">-- Of course, it is possible to start with the reasoning system of `_≡_`</a>
<a id="11373" class="Comment">-- and then switch to the reasoning system of `_≈[_]_`.</a>
<a id="example6a-reverse-∷ʳ"></a><a id="11429" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11429" class="Function">example6a-reverse-∷ʳ</a> <a id="11450" class="Symbol">:</a> <a id="11452" class="Symbol">∀</a> <a id="11454" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11454" class="Bound">x</a> <a id="11456" class="Symbol">(</a><a id="11457" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11457" class="Bound">xs</a> <a id="11460" class="Symbol">:</a> <a id="11462" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="11466" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="11468" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="11469" class="Symbol">)</a> <a id="11471" class="Symbol">→</a> <a id="11473" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11481" class="Symbol">(</a><a id="11482" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11457" class="Bound">xs</a> <a id="11485" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="11488" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11454" class="Bound">x</a><a id="11489" class="Symbol">)</a> <a id="11491" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11493" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11454" class="Bound">x</a> <a id="11495" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11497" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11505" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11457" class="Bound">xs</a>
<a id="11508" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11429" class="Function">example6a-reverse-∷ʳ</a> <a id="11529" class="Symbol">{</a><a id="11530" class="Argument">n</a> <a id="11532" class="Symbol">=</a> <a id="11534" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11534" class="Bound">n</a><a id="11535" class="Symbol">}</a> <a id="11537" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11537" class="Bound">x</a> <a id="11539" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11539" class="Bound">xs</a> <a id="11542" class="Symbol">=</a> <a id="11544" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin-≡</a>
  <a id="11554" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11562" class="Symbol">(</a><a id="11563" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11539" class="Bound">xs</a> <a id="11566" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="11569" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11537" class="Bound">x</a><a id="11570" class="Symbol">)</a>
    <a id="11576" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="11579" href="Data.Vec.Relation.Binary.Equality.Cast.html#1789" class="Function">≈-reflexive</a> <a id="11591" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="11596" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="11600" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11608" class="Symbol">(</a><a id="11609" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11539" class="Bound">xs</a> <a id="11612" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="11615" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11537" class="Bound">x</a><a id="11616" class="Symbol">)</a>
    <a id="11622" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="11625" href="Data.Vec.Relation.Binary.Equality.Cast.html#2663" class="Function">≈-cong′</a> <a id="11633" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11641" class="Symbol">(</a><a id="11642" href="Data.Vec.Properties.html#35192" class="Function">unfold-∷ʳ-eqFree</a> <a id="11659" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11537" class="Bound">x</a> <a id="11661" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11539" class="Bound">xs</a><a id="11663" class="Symbol">)</a> <a id="11665" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="11669" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11677" class="Symbol">(</a><a id="11678" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11539" class="Bound">xs</a> <a id="11681" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11684" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="11686" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11537" class="Bound">x</a> <a id="11688" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="11689" class="Symbol">)</a>
    <a id="11695" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">≈⟨</a> <a id="11698" href="Data.Vec.Properties.html#40502" class="Function">reverse-++-eqFree</a> <a id="11716" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11539" class="Bound">xs</a> <a id="11719" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="11721" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11537" class="Bound">x</a> <a id="11723" href="Data.Vec.Base.html#6459" class="Function Operator">]</a> <a id="11725" href="Data.Vec.Relation.Binary.Equality.Cast.html#3539" class="Function">⟩</a>
  <a id="11729" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11537" class="Bound">x</a> <a id="11731" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11733" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11741" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11539" class="Bound">xs</a>
    <a id="11748" href="Data.Vec.Relation.Binary.Equality.Cast.html#3337" class="Function Operator">∎</a>
  <a id="11752" class="Keyword">where</a> <a id="11758" class="Keyword">open</a> <a id="11763" href="Data.Vec.Relation.Binary.Equality.Cast.html#3134" class="Module">CastReasoning</a>

<a id="example6b-reverse-∷ʳ-by-induction"></a><a id="11778" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11778" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="11812" class="Symbol">:</a> <a id="11814" class="Symbol">∀</a> <a id="11816" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11816" class="Bound">x</a> <a id="11818" class="Symbol">(</a><a id="11819" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11819" class="Bound">xs</a> <a id="11822" class="Symbol">:</a> <a id="11824" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="11828" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#925" class="Generalizable">A</a> <a id="11830" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#941" class="Generalizable">n</a><a id="11831" class="Symbol">)</a> <a id="11833" class="Symbol">→</a> <a id="11835" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11843" class="Symbol">(</a><a id="11844" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11819" class="Bound">xs</a> <a id="11847" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="11850" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11816" class="Bound">x</a><a id="11851" class="Symbol">)</a> <a id="11853" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="11855" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11816" class="Bound">x</a> <a id="11857" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11859" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11867" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11819" class="Bound">xs</a>
<a id="11870" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11778" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="11904" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11904" class="Bound">x</a> <a id="11906" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a>       <a id="11915" class="Symbol">=</a> <a id="11917" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="11922" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11778" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="11956" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a> <a id="11958" class="Symbol">(</a><a id="11959" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a> <a id="11961" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11963" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a><a id="11965" class="Symbol">)</a> <a id="11967" class="Symbol">=</a> <a id="11969" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="11977" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="11985" class="Symbol">(</a><a id="11986" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a> <a id="11988" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11990" class="Symbol">(</a><a id="11991" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a> <a id="11994" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="11997" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a><a id="11998" class="Symbol">))</a> <a id="12001" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="12004" href="Data.Vec.Properties.html#37682" class="Function">reverse-∷</a> <a id="12014" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a> <a id="12016" class="Symbol">(</a><a id="12017" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a> <a id="12020" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12023" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a><a id="12024" class="Symbol">)</a> <a id="12026" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="12030" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12038" class="Symbol">(</a><a id="12039" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a> <a id="12042" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12045" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a><a id="12046" class="Symbol">)</a> <a id="12048" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12051" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a>  <a id="12054" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="12057" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="12062" class="Symbol">(</a><a id="12063" href="Data.Vec.Base.html#8754" class="Function Operator">_∷ʳ</a> <a id="12067" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a><a id="12068" class="Symbol">)</a> <a id="12070" class="Symbol">(</a><a id="12071" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11778" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12105" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a> <a id="12107" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a><a id="12109" class="Symbol">)</a> <a id="12111" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="12115" class="Symbol">(</a><a id="12116" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a> <a id="12118" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12120" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12128" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a><a id="12130" class="Symbol">)</a> <a id="12132" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12135" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a>   <a id="12139" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
  <a id="12145" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a> <a id="12147" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12149" class="Symbol">(</a><a id="12150" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12158" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a> <a id="12161" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12164" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a><a id="12165" class="Symbol">)</a>   <a id="12169" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="12172" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="12177" class="Symbol">(</a><a id="12178" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a> <a id="12180" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷_</a><a id="12182" class="Symbol">)</a> <a id="12184" class="Symbol">(</a><a id="12185" href="Data.Vec.Properties.html#37682" class="Function">reverse-∷</a> <a id="12195" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a> <a id="12197" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a><a id="12199" class="Symbol">)</a> <a id="12201" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="12205" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11956" class="Bound">x</a> <a id="12207" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12209" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12217" class="Symbol">(</a><a id="12218" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11959" class="Bound">y</a> <a id="12220" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12222" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11963" class="Bound">xs</a><a id="12224" class="Symbol">)</a>    <a id="12229" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
  <a id="12233" class="Keyword">where</a> <a id="12239" class="Keyword">open</a> <a id="12244" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
</pre></body></html>