<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Vec.Relation.Binary.Equality.Cast</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- An equational reasoning library for propositional equality over</a>
<a id="173" class="Comment">-- vectors of different indices using cast.</a>
<a id="217" class="Comment">--</a>
<a id="220" class="Comment">-- To see example usages of this library, scroll to the `Combinators`</a>
<a id="290" class="Comment">-- section.</a>
<a id="302" class="Comment">------------------------------------------------------------------------</a>

<a id="376" class="Symbol">{-#</a> <a id="380" class="Keyword">OPTIONS</a> <a id="388" class="Pragma">--cubical-compatible</a> <a id="409" class="Pragma">--safe</a> <a id="416" class="Symbol">#-}</a>

<a id="421" class="Keyword">module</a> <a id="428" href="README.Data.Vec.Relation.Binary.Equality.Cast.html" class="Module">README.Data.Vec.Relation.Binary.Equality.Cast</a> <a id="474" class="Keyword">where</a>

<a id="481" class="Keyword">open</a> <a id="486" class="Keyword">import</a> <a id="493" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>
<a id="508" class="Keyword">open</a> <a id="513" class="Keyword">import</a> <a id="520" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="535" class="Symbol">as</a> <a id="538" class="Module">List</a> <a id="543" class="Keyword">using</a> <a id="549" class="Symbol">(</a><a id="550" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="554" class="Symbol">)</a>
<a id="556" class="Keyword">import</a> <a id="563" href="Data.List.Properties.html" class="Module">Data.List.Properties</a> <a id="584" class="Symbol">as</a> <a id="587" class="Module">List</a>
<a id="592" class="Keyword">open</a> <a id="597" class="Keyword">import</a> <a id="604" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="618" class="Keyword">open</a> <a id="623" class="Keyword">import</a> <a id="630" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="650" class="Keyword">open</a> <a id="655" class="Keyword">import</a> <a id="662" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>
<a id="676" class="Keyword">open</a> <a id="681" class="Keyword">import</a> <a id="688" href="Data.Vec.Properties.html" class="Module">Data.Vec.Properties</a>
<a id="708" class="Keyword">open</a> <a id="713" class="Keyword">import</a> <a id="720" href="Data.Vec.Relation.Binary.Equality.Cast.html" class="Module">Data.Vec.Relation.Binary.Equality.Cast</a>
<a id="759" class="Keyword">open</a> <a id="764" class="Keyword">import</a> <a id="771" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="811" class="Keyword">using</a> <a id="817" class="Symbol">(</a><a id="818" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="821" class="Symbol">;</a> <a id="823" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="827" class="Symbol">;</a> <a id="829" href="Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="832" class="Symbol">;</a> <a id="834" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="838" class="Symbol">;</a> <a id="840" class="Keyword">module</a> <a id="847" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a><a id="858" class="Symbol">)</a>

<a id="861" class="Keyword">private</a> <a id="869" class="Keyword">variable</a>
  <a id="880" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#880" class="Generalizable">a</a> <a id="882" class="Symbol">:</a> <a id="884" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="892" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="894" class="Symbol">:</a> <a id="896" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="900" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#880" class="Generalizable">a</a>
  <a id="904" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#904" class="Generalizable">l</a> <a id="906" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="908" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="910" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#910" class="Generalizable">o</a> <a id="912" class="Symbol">:</a> <a id="914" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#918" class="Generalizable">xs</a> <a id="921" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#921" class="Generalizable">ys</a> <a id="924" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#924" class="Generalizable">zs</a> <a id="927" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#927" class="Generalizable">ws</a> <a id="930" class="Symbol">:</a> <a id="932" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="936" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="938" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a>


<a id="942" class="Comment">------------------------------------------------------------------------</a>
<a id="1015" class="Comment">-- Motivation</a>
<a id="1029" class="Comment">--</a>
<a id="1032" class="Comment">-- The `cast` function is the computational variant of `subst` for</a>
<a id="1099" class="Comment">-- vectors. Since `cast` computes under vector constructors, it</a>
<a id="1163" class="Comment">-- enables reasoning about vectors with non-definitionally equal indices</a>
<a id="1236" class="Comment">-- by induction. See, e.g., Jacques Carette&#39;s comment in issue #1668.</a>
<a id="1306" class="Comment">-- &lt;https://github.com/agda/agda-stdlib/pull/1668#issuecomment-1003449509&gt;</a>
<a id="1381" class="Comment">--</a>
<a id="1384" class="Comment">-- Suppose we want to prove that ‘xs ++ [] ≡ xs’. Because `xs ++ []`</a>
<a id="1453" class="Comment">-- has type `Vec A (n + 0)` while `xs` has type `Vec A n`, they cannot</a>
<a id="1524" class="Comment">-- be directly related by homogeneous equality.</a>
<a id="1572" class="Comment">-- To resolve the issue, `++-right-identity` uses `cast` to recast</a>
<a id="1639" class="Comment">-- `xs ++ []` as a vector in `Vec A n`.</a>
<a id="1679" class="Comment">--</a>
<a id="++-right-identity"></a><a id="1682" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1682" class="Function">++-right-identity</a> <a id="1700" class="Symbol">:</a> <a id="1702" class="Symbol">∀</a> <a id="1704" class="Symbol">.(</a><a id="1706" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1706" class="Bound">eq</a> <a id="1709" class="Symbol">:</a> <a id="1711" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="1713" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="1715" class="Number">0</a> <a id="1717" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1719" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="1720" class="Symbol">)</a> <a id="1722" class="Symbol">(</a><a id="1723" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1723" class="Bound">xs</a> <a id="1726" class="Symbol">:</a> <a id="1728" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="1732" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="1734" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="1735" class="Symbol">)</a> <a id="1737" class="Symbol">→</a> <a id="1739" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="1744" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1706" class="Bound">eq</a> <a id="1747" class="Symbol">(</a><a id="1748" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1723" class="Bound">xs</a> <a id="1751" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="1754" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a><a id="1756" class="Symbol">)</a> <a id="1758" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1760" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1723" class="Bound">xs</a>
<a id="1763" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1682" class="Function">++-right-identity</a> <a id="1781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1781" class="Bound">eq</a> <a id="1784" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a>       <a id="1793" class="Symbol">=</a> <a id="1795" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="1800" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1682" class="Function">++-right-identity</a> <a id="1818" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1818" class="Bound">eq</a> <a id="1821" class="Symbol">(</a><a id="1822" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1822" class="Bound">x</a> <a id="1824" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="1826" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1826" class="Bound">xs</a><a id="1828" class="Symbol">)</a> <a id="1830" class="Symbol">=</a> <a id="1832" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1837" class="Symbol">(</a><a id="1838" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1822" class="Bound">x</a> <a id="1840" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷_</a><a id="1842" class="Symbol">)</a> <a id="1844" class="Symbol">(</a><a id="1845" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1682" class="Function">++-right-identity</a> <a id="1863" class="Symbol">(</a><a id="1864" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="1869" href="Data.Nat.Base.html#5272" class="Function">pred</a> <a id="1874" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1818" class="Bound">eq</a><a id="1876" class="Symbol">)</a> <a id="1878" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#1826" class="Bound">xs</a><a id="1880" class="Symbol">)</a>
<a id="1882" class="Comment">--</a>
<a id="1885" class="Comment">-- When the input is `x ∷ xs`, because `cast eq (x ∷ _)` equals</a>
<a id="1949" class="Comment">-- `x ∷ cast (cong pred eq) _`, the proof obligation</a>
<a id="2002" class="Comment">--     cast eq (x ∷ xs ++ []) ≡ x ∷ xs</a>
<a id="2041" class="Comment">-- simplifies to</a>
<a id="2058" class="Comment">--     x :: cast (cong pred eq) (xs ++ []) ≡ x ∷ xs</a>


<a id="2112" class="Comment">-- Although `cast` makes it possible to prove vector identities by ind-</a>
<a id="2184" class="Comment">-- uction, the explicit type-casting nature poses a significant barrier</a>
<a id="2256" class="Comment">-- to code reuse in larger proofs. For example, consider the identity</a>
<a id="2326" class="Comment">-- ‘fromList (xs List.∷ʳ x) ≡ (fromList xs) ∷ʳ x’ where `List._∷ʳ_` is the</a>
<a id="2401" class="Comment">-- snoc function of lists. We have</a>
<a id="2436" class="Comment">--</a>
<a id="2439" class="Comment">--     fromList (xs List.∷ʳ x)            : Vec A (List.length (xs List.∷ʳ x))</a>
<a id="2518" class="Comment">--   =   {- by definition -}</a>
<a id="2547" class="Comment">--     fromList (xs List.++ List.[ x ])   : Vec A (List.length (xs List.++ List.[ x ]))</a>
<a id="2635" class="Comment">--   =   {- by fromList-++ -}</a>
<a id="2665" class="Comment">--     fromList xs ++ fromList List.[ x ] : Vec A (List.length xs + List.length [ x ])</a>
<a id="2752" class="Comment">--   =   {- by definition -}</a>
<a id="2781" class="Comment">--     fromList xs ++ [ x ]               : Vec A (List.length xs + 1)</a>
<a id="2852" class="Comment">--   =   {- by unfold-∷ʳ -}</a>
<a id="2880" class="Comment">--     fromList xs ∷ʳ x                   : Vec A (suc (List.length xs))</a>
<a id="2953" class="Comment">-- where</a>
<a id="2962" class="Comment">--     fromList-++ : cast _ (fromList (xs List.++ ys)) ≡ fromList xs ++ fromList ys</a>
<a id="3046" class="Comment">--     unfold-∷ʳ   : cast _ (xs ∷ʳ x) ≡ xs ++ [ x ]</a>
<a id="3098" class="Comment">--</a>
<a id="3101" class="Comment">-- Although the identity itself is simple, the reasoning process changes</a>
<a id="3174" class="Comment">-- the index in the type twice. Consequently, its Agda translation must</a>
<a id="3246" class="Comment">-- insert two `cast`s in the proof. Moreover, the proof first has to</a>
<a id="3315" class="Comment">-- rearrange (the Agda version of) the identity into one with two</a>
<a id="3381" class="Comment">-- `cast`s, resulting in lots of boilerplate code as demonstrated by</a>
<a id="3450" class="Comment">-- `example1a-fromList-∷ʳ`.</a>
<a id="example1a-fromList-∷ʳ"></a><a id="3478" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3478" class="Function">example1a-fromList-∷ʳ</a> <a id="3500" class="Symbol">:</a> <a id="3502" class="Symbol">∀</a> <a id="3504" class="Symbol">(</a><a id="3505" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3505" class="Bound">x</a> <a id="3507" class="Symbol">:</a> <a id="3509" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="3510" class="Symbol">)</a> <a id="3512" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a> <a id="3515" class="Symbol">→</a>
                        <a id="3541" class="Symbol">.(</a><a id="3543" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3543" class="Bound">eq</a> <a id="3546" class="Symbol">:</a> <a id="3548" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="3560" class="Symbol">(</a><a id="3561" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a> <a id="3564" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3572" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3505" class="Bound">x</a><a id="3573" class="Symbol">)</a> <a id="3575" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3577" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3581" class="Symbol">(</a><a id="3582" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="3594" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a><a id="3596" class="Symbol">))</a> <a id="3599" class="Symbol">→</a>
                        <a id="3625" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3630" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3543" class="Bound">eq</a> <a id="3633" class="Symbol">(</a><a id="3634" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3643" class="Symbol">(</a><a id="3644" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a> <a id="3647" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3655" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3505" class="Bound">x</a><a id="3656" class="Symbol">))</a> <a id="3659" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3661" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3670" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3512" class="Bound">xs</a> <a id="3673" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="3676" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3505" class="Bound">x</a>
<a id="3678" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3478" class="Function">example1a-fromList-∷ʳ</a> <a id="3700" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3702" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3705" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3705" class="Bound">eq</a> <a id="3708" class="Symbol">=</a> <a id="3710" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="3718" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3723" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3705" class="Bound">eq</a> <a id="3726" class="Symbol">(</a><a id="3727" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3736" class="Symbol">(</a><a id="3737" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3740" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="3748" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a><a id="3749" class="Symbol">))</a>
    <a id="3756" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
  <a id="3762" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3767" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3705" class="Bound">eq</a> <a id="3770" class="Symbol">(</a><a id="3771" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3780" class="Symbol">(</a><a id="3781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3784" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3792" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3799" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3801" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3802" class="Symbol">))</a>
    <a id="3809" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="3812" href="Data.Vec.Relation.Binary.Equality.Cast.html#1139" class="Function">cast-trans</a> <a id="3823" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4105" class="Function">eq₁</a> <a id="3827" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4144" class="Function">eq₂</a> <a id="3831" class="Symbol">(</a><a id="3832" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3841" class="Symbol">(</a><a id="3842" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3845" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3853" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3860" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3862" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3863" class="Symbol">))</a> <a id="3866" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="3870" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3875" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4144" class="Function">eq₂</a> <a id="3879" class="Symbol">(</a><a id="3880" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3885" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4105" class="Function">eq₁</a> <a id="3889" class="Symbol">(</a><a id="3890" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3899" class="Symbol">(</a><a id="3900" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3903" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="3911" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="3918" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3920" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="3921" class="Symbol">)))</a>
    <a id="3929" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="3932" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="3937" class="Symbol">(</a><a id="3938" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3943" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4144" class="Function">eq₂</a><a id="3946" class="Symbol">)</a> <a id="3948" class="Symbol">(</a><a id="3949" href="Data.Vec.Properties.html#54259" class="Function">fromList-++</a> <a id="3961" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a><a id="3963" class="Symbol">)</a> <a id="3965" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="3969" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="3974" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4144" class="Function">eq₂</a> <a id="3978" class="Symbol">(</a><a id="3979" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="3988" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="3991" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="3994" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="3996" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="3998" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="3999" class="Symbol">)</a>
    <a id="4005" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="4008" href="Data.Vec.Relation.Binary.Equality.Cast.html#1820" class="Function">≈-sym</a> <a id="4014" class="Symbol">(</a><a id="4015" href="Data.Vec.Properties.html#35459" class="Function">unfold-∷ʳ-eqFree</a> <a id="4032" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="4034" class="Symbol">(</a><a id="4035" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4044" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a><a id="4046" class="Symbol">))</a> <a id="4049" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="4053" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4062" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="4065" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4068" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a>
    <a id="4074" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
  <a id="4078" class="Keyword">where</a>
  <a id="4086" class="Keyword">open</a> <a id="4091" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
  <a id="4105" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4105" class="Function">eq₁</a> <a id="4109" class="Symbol">=</a> <a id="4111" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="4126" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a> <a id="4129" class="Symbol">{</a><a id="4130" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="4137" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3700" class="Bound">x</a> <a id="4139" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="4140" class="Symbol">}</a>
  <a id="4144" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4144" class="Function">eq₂</a> <a id="4148" class="Symbol">=</a> <a id="4150" href="Data.Nat.Properties.html#15642" class="Function">+-comm</a> <a id="4157" class="Symbol">(</a><a id="4158" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4170" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#3702" class="Bound">xs</a><a id="4172" class="Symbol">)</a> <a id="4174" class="Number">1</a>

<a id="4177" class="Comment">-- The `cast`s are irrelevant to core of the proof. At the same time,</a>
<a id="4247" class="Comment">-- they can be inferred from the lemmas used during the reasoning steps</a>
<a id="4319" class="Comment">-- (e.g. `fromList-++` and `unfold-∷ʳ`). To eliminate the boilerplate,</a>
<a id="4390" class="Comment">-- this library provides a set of equational reasoning combinators for</a>
<a id="4461" class="Comment">-- equality of the form `cast eq xs ≡ ys`.</a>
<a id="example1b-fromList-∷ʳ"></a><a id="4504" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4504" class="Function">example1b-fromList-∷ʳ</a> <a id="4526" class="Symbol">:</a> <a id="4528" class="Symbol">∀</a> <a id="4530" class="Symbol">(</a><a id="4531" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4531" class="Bound">x</a> <a id="4533" class="Symbol">:</a> <a id="4535" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="4536" class="Symbol">)</a> <a id="4538" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4538" class="Bound">xs</a> <a id="4541" class="Symbol">→</a>
                        <a id="4567" class="Symbol">.(</a><a id="4569" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4569" class="Bound">eq</a> <a id="4572" class="Symbol">:</a> <a id="4574" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4586" class="Symbol">(</a><a id="4587" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4538" class="Bound">xs</a> <a id="4590" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4598" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4531" class="Bound">x</a><a id="4599" class="Symbol">)</a> <a id="4601" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4603" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4607" class="Symbol">(</a><a id="4608" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="4620" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4538" class="Bound">xs</a><a id="4622" class="Symbol">))</a> <a id="4625" class="Symbol">→</a>
                        <a id="4651" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="4656" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4569" class="Bound">eq</a> <a id="4659" class="Symbol">(</a><a id="4660" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4669" class="Symbol">(</a><a id="4670" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4538" class="Bound">xs</a> <a id="4673" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4681" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4531" class="Bound">x</a><a id="4682" class="Symbol">))</a> <a id="4685" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4687" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4696" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4538" class="Bound">xs</a> <a id="4699" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4702" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4531" class="Bound">x</a>
<a id="4704" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4504" class="Function">example1b-fromList-∷ʳ</a> <a id="4726" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4726" class="Bound">x</a> <a id="4728" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4728" class="Bound">xs</a> <a id="4731" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4731" class="Bound">eq</a> <a id="4734" class="Symbol">=</a> <a id="4736" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="4744" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4753" class="Symbol">(</a><a id="4754" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4728" class="Bound">xs</a> <a id="4757" href="Data.List.Base.html#7451" class="Function Operator">List.∷ʳ</a> <a id="4765" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4726" class="Bound">x</a><a id="4766" class="Symbol">)</a>
    <a id="4772" href="Data.Vec.Relation.Binary.Equality.Cast.html#2910" class="Function Operator">≈⟨⟩</a>
  <a id="4778" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4787" class="Symbol">(</a><a id="4788" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4728" class="Bound">xs</a> <a id="4791" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="4799" href="Data.List.Base.html#5205" class="Function Operator">List.[</a> <a id="4806" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4726" class="Bound">x</a> <a id="4808" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="4809" class="Symbol">)</a>
    <a id="4815" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="4818" href="Data.Vec.Properties.html#54259" class="Function">fromList-++</a> <a id="4830" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4728" class="Bound">xs</a> <a id="4833" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="4837" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4846" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4728" class="Bound">xs</a> <a id="4849" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="4852" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="4854" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4726" class="Bound">x</a> <a id="4856" href="Data.Vec.Base.html#6459" class="Function Operator">]</a>
    <a id="4862" href="Data.Vec.Relation.Binary.Equality.Cast.html#3258" class="Function">≈⟨</a> <a id="4865" href="Data.Vec.Properties.html#35459" class="Function">unfold-∷ʳ-eqFree</a> <a id="4882" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4726" class="Bound">x</a> <a id="4884" class="Symbol">(</a><a id="4885" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4894" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4728" class="Bound">xs</a><a id="4896" class="Symbol">)</a> <a id="4898" href="Data.Vec.Relation.Binary.Equality.Cast.html#3258" class="Function">⟨</a>
  <a id="4902" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="4911" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4728" class="Bound">xs</a> <a id="4914" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="4917" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#4726" class="Bound">x</a>
    <a id="4923" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="4927" class="Keyword">where</a> <a id="4933" class="Keyword">open</a> <a id="4938" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>


<a id="4954" class="Comment">------------------------------------------------------------------------</a>
<a id="5027" class="Comment">-- Combinators</a>
<a id="5042" class="Comment">--</a>
<a id="5045" class="Comment">-- Let `xs ≈[ m≡n ] ys` denote `cast m≡n xs ≡ ys`. We have reflexivity,</a>
<a id="5117" class="Comment">-- symmetry and transitivity:</a>
<a id="5147" class="Comment">--     ≈-reflexive : xs ≈[ refl ] xs</a>
<a id="5184" class="Comment">--     ≈-sym       : xs ≈[ m≡n ] ys → ys ≈[ sym m≡n ] xs</a>
<a id="5241" class="Comment">--     ≈-trans     : xs ≈[ m≡n ] ys → ys ≈[ n≡o ] zs → xs ≈[ trans m≡n n≡o ] zs</a>
<a id="5321" class="Comment">-- Accordingly, `_≈[_]_` admits the standard set of equational reasoning</a>
<a id="5394" class="Comment">-- combinators. Suppose `≈-eqn : xs ≈[ m≡n ] ys`,</a>
<a id="5444" class="Comment">--     xs ≈⟨ ≈-eqn ⟩   -- `_≈⟨_⟩_` takes a `_≈[_]_` step, adjusting</a>
<a id="5512" class="Comment">--     ys              -- the index at the same time</a>
<a id="5565" class="Comment">--</a>
<a id="5568" class="Comment">--     ys ≈⟨ ≈-eqn ⟨   -- `_≈⟨_⟨_` takes a symmetric `_≈[_]_` step</a>
<a id="5635" class="Comment">--     xs</a>
<a id="example2a"></a><a id="5645" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5645" class="Function">example2a</a> <a id="5655" class="Symbol">:</a> <a id="5657" class="Symbol">∀</a> <a id="5659" class="Symbol">.(</a><a id="5661" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5661" class="Bound">eq</a> <a id="5664" class="Symbol">:</a> <a id="5666" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5670" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="5672" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="5674" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="5676" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5678" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="5680" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="5682" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5686" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="5687" class="Symbol">)</a> <a id="5689" class="Symbol">(</a><a id="5690" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5690" class="Bound">xs</a> <a id="5693" class="Symbol">:</a> <a id="5695" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="5699" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="5701" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a><a id="5702" class="Symbol">)</a> <a id="5704" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5704" class="Bound">a</a> <a id="5706" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5706" class="Bound">ys</a> <a id="5709" class="Symbol">→</a>
            <a id="5723" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="5728" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5661" class="Bound">eq</a> <a id="5731" class="Symbol">((</a><a id="5733" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5741" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5690" class="Bound">xs</a> <a id="5744" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="5747" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5704" class="Bound">a</a><a id="5748" class="Symbol">)</a> <a id="5750" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5753" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5706" class="Bound">ys</a><a id="5755" class="Symbol">)</a> <a id="5757" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="5759" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5767" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5690" class="Bound">xs</a> <a id="5770" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5773" class="Symbol">(</a><a id="5774" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5704" class="Bound">a</a> <a id="5776" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="5778" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5706" class="Bound">ys</a><a id="5780" class="Symbol">)</a>
<a id="5782" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5645" class="Function">example2a</a> <a id="5792" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5792" class="Bound">eq</a> <a id="5795" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5795" class="Bound">xs</a> <a id="5798" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5798" class="Bound">a</a> <a id="5800" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5800" class="Bound">ys</a> <a id="5803" class="Symbol">=</a> <a id="5805" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="5813" class="Symbol">(</a><a id="5814" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5822" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5795" class="Bound">xs</a> <a id="5825" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="5828" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5798" class="Bound">a</a><a id="5829" class="Symbol">)</a> <a id="5831" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5834" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5800" class="Bound">ys</a> <a id="5837" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="5840" href="Data.Vec.Properties.html#37641" class="Function">∷ʳ-++-eqFree</a> <a id="5853" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5798" class="Bound">a</a> <a id="5855" class="Symbol">(</a><a id="5856" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5864" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5795" class="Bound">xs</a><a id="5866" class="Symbol">)</a> <a id="5868" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a> <a id="5870" class="Comment">-- index: suc m + n</a>
  <a id="5892" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="5900" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5795" class="Bound">xs</a> <a id="5903" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="5906" class="Symbol">(</a><a id="5907" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5798" class="Bound">a</a> <a id="5909" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="5911" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#5800" class="Bound">ys</a><a id="5913" class="Symbol">)</a>  <a id="5916" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>                                <a id="5949" class="Comment">-- index: m + suc n</a>
  <a id="5971" class="Keyword">where</a> <a id="5977" class="Keyword">open</a> <a id="5982" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="5997" class="Comment">-- To interoperate with `_≡_`, this library provides `_≂⟨_⟩_` (\-~) for</a>
<a id="6069" class="Comment">-- taking a `_≡_` step during equational reasoning.</a>
<a id="6121" class="Comment">-- Let `≡-eqn : xs ≡ ys`, then</a>
<a id="6152" class="Comment">--     xs ≂⟨ ≡-eqn  ⟩    -- Takes a `_≡_` step; no change to the index</a>
<a id="6223" class="Comment">--     ys</a>
<a id="6233" class="Comment">--</a>
<a id="6236" class="Comment">--     ys ≂⟨ ≡-eqn ⟨    -- Takes a symmetric `_≡_` step</a>
<a id="6292" class="Comment">--     xs</a>
<a id="6302" class="Comment">-- Equivalently, `≈-reflexive` injects `_≡_` into `_≈[_]_`. That is,</a>
<a id="6371" class="Comment">-- `xs ≂⟨ ≡-eqn ⟩ ys` is the same as `xs ≈⟨ ≈-reflexive ≡-eqn ⟩ ys`.</a>
<a id="6440" class="Comment">-- Extending `example2a`, we have:</a>
<a id="example2b"></a><a id="6475" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6475" class="Function">example2b</a> <a id="6485" class="Symbol">:</a> <a id="6487" class="Symbol">∀</a> <a id="6489" class="Symbol">.(</a><a id="6491" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6491" class="Bound">eq</a> <a id="6494" class="Symbol">:</a> <a id="6496" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6500" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="6502" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="6504" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="6506" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6508" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="6510" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="6512" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="6516" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="6517" class="Symbol">)</a> <a id="6519" class="Symbol">(</a><a id="6520" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6520" class="Bound">xs</a> <a id="6523" class="Symbol">:</a> <a id="6525" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="6529" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="6531" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a><a id="6532" class="Symbol">)</a> <a id="6534" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6534" class="Bound">a</a> <a id="6536" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6536" class="Bound">ys</a> <a id="6539" class="Symbol">→</a>
            <a id="6553" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="6558" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6491" class="Bound">eq</a> <a id="6561" class="Symbol">((</a><a id="6563" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6534" class="Bound">a</a> <a id="6565" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6567" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6520" class="Bound">xs</a><a id="6569" class="Symbol">)</a> <a id="6571" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6575" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6536" class="Bound">ys</a><a id="6577" class="Symbol">)</a> <a id="6579" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="6581" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6520" class="Bound">xs</a> <a id="6584" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6588" class="Symbol">(</a><a id="6589" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6534" class="Bound">a</a> <a id="6591" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6593" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6536" class="Bound">ys</a><a id="6595" class="Symbol">)</a>
<a id="6597" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6475" class="Function">example2b</a> <a id="6607" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6607" class="Bound">eq</a> <a id="6610" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a> <a id="6613" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6615" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a> <a id="6618" class="Symbol">=</a> <a id="6620" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="6628" class="Symbol">(</a><a id="6629" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6631" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6633" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a><a id="6635" class="Symbol">)</a> <a id="6637" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6641" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a>         <a id="6652" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">≂⟨</a> <a id="6655" href="Data.Vec.Properties.html#42305" class="Function">unfold-ʳ++</a> <a id="6666" class="Symbol">(</a><a id="6667" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6669" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6671" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a><a id="6673" class="Symbol">)</a> <a id="6675" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a> <a id="6678" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">⟩</a>          <a id="6689" class="Comment">-- index: suc m + n</a>
  <a id="6711" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6719" class="Symbol">(</a><a id="6720" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6722" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6724" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a><a id="6726" class="Symbol">)</a> <a id="6728" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6731" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a>  <a id="6735" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">≂⟨</a> <a id="6738" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="6743" class="Symbol">(</a><a id="6744" href="Data.Vec.Base.html#3076" class="Function Operator">_++</a> <a id="6748" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a><a id="6750" class="Symbol">)</a> <a id="6752" class="Symbol">(</a><a id="6753" href="Data.Vec.Properties.html#38031" class="Function">reverse-∷</a> <a id="6763" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6765" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a><a id="6767" class="Symbol">)</a> <a id="6769" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">⟩</a>  <a id="6772" class="Comment">-- index: suc m + n</a>
  <a id="6794" class="Symbol">(</a><a id="6795" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6803" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a> <a id="6806" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="6809" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a><a id="6810" class="Symbol">)</a> <a id="6812" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6815" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a> <a id="6818" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="6821" href="Data.Vec.Properties.html#37641" class="Function">∷ʳ-++-eqFree</a> <a id="6834" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6836" class="Symbol">(</a><a id="6837" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6845" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a><a id="6847" class="Symbol">)</a> <a id="6849" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>     <a id="6855" class="Comment">-- index: suc m + n</a>
  <a id="6877" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="6885" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a> <a id="6888" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="6891" class="Symbol">(</a><a id="6892" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6894" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6896" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a><a id="6898" class="Symbol">)</a>  <a id="6901" href="Data.Vec.Relation.Binary.Equality.Cast.html#4137" class="Function">≂⟨</a> <a id="6904" href="Data.Vec.Properties.html#42305" class="Function">unfold-ʳ++</a> <a id="6915" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a> <a id="6918" class="Symbol">(</a><a id="6919" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6921" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6923" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a><a id="6925" class="Symbol">)</a> <a id="6927" href="Data.Vec.Relation.Binary.Equality.Cast.html#4137" class="Function">⟨</a>          <a id="6938" class="Comment">-- index: m + suc n</a>
  <a id="6960" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6610" class="Bound">xs</a> <a id="6963" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="6967" class="Symbol">(</a><a id="6968" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6613" class="Bound">a</a> <a id="6970" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="6972" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#6615" class="Bound">ys</a><a id="6974" class="Symbol">)</a>         <a id="6984" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>                                    <a id="7021" class="Comment">-- index: m + suc n</a>
  <a id="7043" class="Keyword">where</a> <a id="7049" class="Keyword">open</a> <a id="7054" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="7069" class="Comment">-- Oftentimes index-changing identities apply to only part of the proof</a>
<a id="7141" class="Comment">-- term. When reasoning about `_≡_`, `cong` shifts the focus to the</a>
<a id="7209" class="Comment">-- subterm of interest. In this library, `≈-cong` does a similar job.</a>
<a id="7279" class="Comment">-- Suppose `f : A → B`, `xs : B`, `ys zs : A`, `ys≈zs : ys ≈[ _ ] zs`</a>
<a id="7349" class="Comment">-- and `xs≈f⟨c·ys⟩ : xs ≈[ _ ] f (cast _ ys)`, we have</a>
<a id="7404" class="Comment">--     xs ≈⟨ ≈-cong f xs≈f⟨c·ys⟩ ys≈zs ⟩</a>
<a id="7445" class="Comment">--     f zs</a>
<a id="7457" class="Comment">-- The reason for having the extra argument `xs≈f⟨c·ys⟩` is to expose</a>
<a id="7527" class="Comment">-- `cast` in the subterm in order to apply the step `ys≈zs`. When using</a>
<a id="7599" class="Comment">-- ordinary `cong` the proof has to explicitly push `cast` inside:</a>
<a id="7666" class="Comment">--     xs            ≈⟨ xs≈f⟨c·ys⟩ ⟩</a>
<a id="7703" class="Comment">--     f (cast _ ys) ≂⟨ cong f ys≈zs ⟩</a>
<a id="7742" class="Comment">--     f zs</a>
<a id="7754" class="Comment">-- Note. Technically, `A` and `B` should be vectors of different length</a>
<a id="7826" class="Comment">-- and that `ys`, `zs` are vectors of non-definitionally equal index.</a>
<a id="example3a-fromList-++-++"></a><a id="7896" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7896" class="Function">example3a-fromList-++-++</a> <a id="7921" class="Symbol">:</a> <a id="7923" class="Symbol">{</a><a id="7924" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7924" class="Bound">xs</a> <a id="7927" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7927" class="Bound">ys</a> <a id="7930" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7930" class="Bound">zs</a> <a id="7933" class="Symbol">:</a> <a id="7935" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="7940" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="7941" class="Symbol">}</a> <a id="7943" class="Symbol">→</a>
                           <a id="7972" class="Symbol">.(</a><a id="7974" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7974" class="Bound">eq</a> <a id="7977" class="Symbol">:</a> <a id="7979" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="7991" class="Symbol">(</a><a id="7992" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7924" class="Bound">xs</a> <a id="7995" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8003" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7927" class="Bound">ys</a> <a id="8006" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8014" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7930" class="Bound">zs</a><a id="8016" class="Symbol">)</a> <a id="8018" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                  <a id="8054" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8066" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7924" class="Bound">xs</a> <a id="8069" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8071" class="Symbol">(</a><a id="8072" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8084" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7927" class="Bound">ys</a> <a id="8087" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8089" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8101" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7930" class="Bound">zs</a><a id="8103" class="Symbol">))</a> <a id="8106" class="Symbol">→</a>
                           <a id="8135" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="8140" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7974" class="Bound">eq</a> <a id="8143" class="Symbol">(</a><a id="8144" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8153" class="Symbol">(</a><a id="8154" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7924" class="Bound">xs</a> <a id="8157" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8165" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7927" class="Bound">ys</a> <a id="8168" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8176" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7930" class="Bound">zs</a><a id="8178" class="Symbol">))</a> <a id="8181" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="8218" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8227" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7924" class="Bound">xs</a> <a id="8230" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8233" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8242" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7927" class="Bound">ys</a> <a id="8245" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8248" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8257" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7930" class="Bound">zs</a>
<a id="8260" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#7896" class="Function">example3a-fromList-++-++</a> <a id="8285" class="Symbol">{</a><a id="8286" class="Argument">xs</a> <a id="8289" class="Symbol">=</a> <a id="8291" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8291" class="Bound">xs</a><a id="8293" class="Symbol">}</a> <a id="8295" class="Symbol">{</a><a id="8296" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8296" class="Bound">ys</a><a id="8298" class="Symbol">}</a> <a id="8300" class="Symbol">{</a><a id="8301" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8301" class="Bound">zs</a><a id="8303" class="Symbol">}</a> <a id="8305" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8305" class="Bound">eq</a> <a id="8308" class="Symbol">=</a> <a id="8310" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="8318" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8327" class="Symbol">(</a><a id="8328" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8291" class="Bound">xs</a> <a id="8331" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8339" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8296" class="Bound">ys</a> <a id="8342" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8350" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8301" class="Bound">zs</a><a id="8352" class="Symbol">)</a>
    <a id="8358" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="8361" href="Data.Vec.Properties.html#54259" class="Function">fromList-++</a> <a id="8373" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8291" class="Bound">xs</a> <a id="8376" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="8380" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8389" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8291" class="Bound">xs</a> <a id="8392" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8395" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8404" class="Symbol">(</a><a id="8405" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8296" class="Bound">ys</a> <a id="8408" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8416" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8301" class="Bound">zs</a><a id="8418" class="Symbol">)</a>
    <a id="8424" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="8427" href="Data.Vec.Relation.Binary.Equality.Cast.html#4380" class="Function">≈-cong</a> <a id="8434" class="Symbol">(</a><a id="8435" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8444" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8291" class="Bound">xs</a> <a id="8447" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="8450" class="Symbol">)</a> <a id="8452" class="Symbol">(</a><a id="8453" href="Data.Vec.Properties.html#20119" class="Function">cast-++ʳ</a> <a id="8462" class="Symbol">(</a><a id="8463" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="8478" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8296" class="Bound">ys</a><a id="8480" class="Symbol">)</a> <a id="8482" class="Symbol">(</a><a id="8483" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8492" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8291" class="Bound">xs</a><a id="8494" class="Symbol">))</a> <a id="8497" class="Symbol">(</a><a id="8498" href="Data.Vec.Properties.html#54259" class="Function">fromList-++</a> <a id="8510" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8296" class="Bound">ys</a><a id="8512" class="Symbol">)</a> <a id="8514" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="8518" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8527" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8291" class="Bound">xs</a> <a id="8530" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8533" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8542" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8296" class="Bound">ys</a> <a id="8545" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="8548" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="8557" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8301" class="Bound">zs</a>
    <a id="8564" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="8568" class="Keyword">where</a> <a id="8574" class="Keyword">open</a> <a id="8579" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="8594" class="Comment">-- As an alternative, one can manually apply `cast-++ʳ` to expose `cast`</a>
<a id="8667" class="Comment">-- in the subterm. However, this unavoidably duplicates the proof term.</a>
<a id="example3b-fromList-++-++′"></a><a id="8739" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8739" class="Function">example3b-fromList-++-++′</a> <a id="8765" class="Symbol">:</a> <a id="8767" class="Symbol">{</a><a id="8768" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8768" class="Bound">xs</a> <a id="8771" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8771" class="Bound">ys</a> <a id="8774" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8774" class="Bound">zs</a> <a id="8777" class="Symbol">:</a> <a id="8779" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="8784" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="8785" class="Symbol">}</a> <a id="8787" class="Symbol">→</a>
                            <a id="8817" class="Symbol">.(</a><a id="8819" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8819" class="Bound">eq</a> <a id="8822" class="Symbol">:</a> <a id="8824" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8836" class="Symbol">(</a><a id="8837" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8768" class="Bound">xs</a> <a id="8840" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8848" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8771" class="Bound">ys</a> <a id="8851" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="8859" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8774" class="Bound">zs</a><a id="8861" class="Symbol">)</a> <a id="8863" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="8900" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8912" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8768" class="Bound">xs</a> <a id="8915" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8917" class="Symbol">(</a><a id="8918" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8930" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8771" class="Bound">ys</a> <a id="8933" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="8935" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="8947" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8774" class="Bound">zs</a><a id="8949" class="Symbol">))</a> <a id="8952" class="Symbol">→</a>
                            <a id="8982" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="8987" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8819" class="Bound">eq</a> <a id="8990" class="Symbol">(</a><a id="8991" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9000" class="Symbol">(</a><a id="9001" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8768" class="Bound">xs</a> <a id="9004" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9012" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8771" class="Bound">ys</a> <a id="9015" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9023" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8774" class="Bound">zs</a><a id="9025" class="Symbol">))</a> <a id="9028" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                    <a id="9066" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9075" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8768" class="Bound">xs</a> <a id="9078" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9081" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9090" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8771" class="Bound">ys</a> <a id="9093" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9096" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9105" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8774" class="Bound">zs</a>
<a id="9108" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#8739" class="Function">example3b-fromList-++-++′</a> <a id="9134" class="Symbol">{</a><a id="9135" class="Argument">xs</a> <a id="9138" class="Symbol">=</a> <a id="9140" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9140" class="Bound">xs</a><a id="9142" class="Symbol">}</a> <a id="9144" class="Symbol">{</a><a id="9145" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9145" class="Bound">ys</a><a id="9147" class="Symbol">}</a> <a id="9149" class="Symbol">{</a><a id="9150" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9150" class="Bound">zs</a><a id="9152" class="Symbol">}</a> <a id="9154" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9154" class="Bound">eq</a> <a id="9157" class="Symbol">=</a> <a id="9159" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="9167" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9176" class="Symbol">(</a><a id="9177" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9140" class="Bound">xs</a> <a id="9180" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9188" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9145" class="Bound">ys</a> <a id="9191" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9199" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9150" class="Bound">zs</a><a id="9201" class="Symbol">)</a>
    <a id="9207" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="9210" href="Data.Vec.Properties.html#54259" class="Function">fromList-++</a> <a id="9222" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9140" class="Bound">xs</a> <a id="9225" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="9229" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9238" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9140" class="Bound">xs</a> <a id="9241" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9244" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9253" class="Symbol">(</a><a id="9254" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9145" class="Bound">ys</a> <a id="9257" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9265" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9150" class="Bound">zs</a><a id="9267" class="Symbol">)</a>
    <a id="9273" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="9276" href="Data.Vec.Properties.html#20119" class="Function">cast-++ʳ</a> <a id="9285" class="Symbol">(</a><a id="9286" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="9301" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9145" class="Bound">ys</a><a id="9303" class="Symbol">)</a> <a id="9305" class="Symbol">(</a><a id="9306" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9315" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9140" class="Bound">xs</a><a id="9317" class="Symbol">)</a> <a id="9319" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="9323" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9332" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9140" class="Bound">xs</a> <a id="9335" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9338" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="9343" class="Symbol">_</a> <a id="9345" class="Symbol">(</a><a id="9346" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9355" class="Symbol">(</a><a id="9356" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9145" class="Bound">ys</a> <a id="9359" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="9367" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9150" class="Bound">zs</a><a id="9369" class="Symbol">))</a>
    <a id="9376" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">≂⟨</a> <a id="9379" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="9384" class="Symbol">(</a><a id="9385" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9394" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9140" class="Bound">xs</a> <a id="9397" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="9400" class="Symbol">)</a> <a id="9402" class="Symbol">(</a><a id="9403" href="Data.Vec.Properties.html#54259" class="Function">fromList-++</a> <a id="9415" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9145" class="Bound">ys</a><a id="9417" class="Symbol">)</a> <a id="9419" href="Data.Vec.Relation.Binary.Equality.Cast.html#3977" class="Function">⟩</a>
  <a id="9423" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9432" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9140" class="Bound">xs</a> <a id="9435" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9438" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9447" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9145" class="Bound">ys</a> <a id="9450" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9453" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="9462" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9150" class="Bound">zs</a>
    <a id="9469" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="9473" class="Keyword">where</a> <a id="9479" class="Keyword">open</a> <a id="9484" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="9499" class="Comment">-- `≈-cong` can be chained together much like how `cong` can be nested.</a>
<a id="9571" class="Comment">-- In this example, `unfold-∷ʳ` is applied to the term `xs ++ [ a ]`</a>
<a id="9640" class="Comment">-- in `(_++ ys)` inside of `reverse`. Thus the proof employs two</a>
<a id="9705" class="Comment">-- `≈-cong`.</a>
<a id="example4-cong²"></a><a id="9718" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9718" class="Function">example4-cong²</a> <a id="9733" class="Symbol">:</a> <a id="9735" class="Symbol">∀</a> <a id="9737" class="Symbol">.(</a><a id="9739" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9739" class="Bound">eq</a> <a id="9742" class="Symbol">:</a> <a id="9744" class="Symbol">(</a><a id="9745" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a> <a id="9747" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9749" class="Number">1</a><a id="9750" class="Symbol">)</a> <a id="9752" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9754" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="9756" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9758" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a> <a id="9760" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="9762" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9766" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a><a id="9767" class="Symbol">)</a> <a id="9769" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9769" class="Bound">a</a> <a id="9771" class="Symbol">(</a><a id="9772" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9772" class="Bound">xs</a> <a id="9775" class="Symbol">:</a> <a id="9777" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="9781" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="9783" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#906" class="Generalizable">m</a><a id="9784" class="Symbol">)</a> <a id="9786" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9786" class="Bound">ys</a> <a id="9789" class="Symbol">→</a>
          <a id="9801" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="9806" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9739" class="Bound">eq</a> <a id="9809" class="Symbol">(</a><a id="9810" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9818" class="Symbol">((</a><a id="9820" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9772" class="Bound">xs</a> <a id="9823" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9826" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="9828" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9769" class="Bound">a</a> <a id="9830" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="9831" class="Symbol">)</a> <a id="9833" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9836" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9786" class="Bound">ys</a><a id="9838" class="Symbol">))</a> <a id="9841" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9843" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9786" class="Bound">ys</a> <a id="9846" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="9850" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9858" class="Symbol">(</a><a id="9859" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9772" class="Bound">xs</a> <a id="9862" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="9865" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9769" class="Bound">a</a><a id="9866" class="Symbol">)</a>
<a id="9868" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9718" class="Function">example4-cong²</a> <a id="9883" class="Symbol">{</a><a id="9884" class="Argument">m</a> <a id="9886" class="Symbol">=</a> <a id="9888" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9888" class="Bound">m</a><a id="9889" class="Symbol">}</a> <a id="9891" class="Symbol">{</a><a id="9892" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">n</a><a id="9893" class="Symbol">}</a> <a id="9895" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9895" class="Bound">eq</a> <a id="9898" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a> <a id="9900" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="9903" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a> <a id="9906" class="Symbol">=</a> <a id="9908" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="9916" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9924" class="Symbol">((</a><a id="9926" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="9929" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9932" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="9934" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a> <a id="9936" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="9937" class="Symbol">)</a> <a id="9939" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="9942" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a><a id="9944" class="Symbol">)</a>
    <a id="9950" href="Data.Vec.Relation.Binary.Equality.Cast.html#3258" class="Function">≈⟨</a> <a id="9953" href="Data.Vec.Relation.Binary.Equality.Cast.html#4380" class="Function">≈-cong</a> <a id="9960" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="9968" class="Symbol">(</a><a id="9969" href="Data.Vec.Properties.html#41644" class="Function">cast-reverse</a> <a id="9982" class="Symbol">(</a><a id="9983" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="9988" class="Symbol">(</a><a id="9989" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">_+</a> <a id="9992" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9892" class="Bound">n</a><a id="9993" class="Symbol">)</a> <a id="9995" class="Symbol">(</a><a id="9996" href="Data.Nat.Properties.html#15642" class="Function">+-comm</a> <a id="10003" class="Number">1</a> <a id="10005" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9888" class="Bound">m</a><a id="10006" class="Symbol">))</a> <a id="10009" class="Symbol">((</a><a id="10011" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="10014" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10017" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a><a id="10018" class="Symbol">)</a> <a id="10020" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="10023" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a><a id="10025" class="Symbol">))</a>
                                             <a id="10073" class="Symbol">(</a><a id="10074" href="Data.Vec.Relation.Binary.Equality.Cast.html#4380" class="Function">≈-cong</a> <a id="10081" class="Symbol">(</a><a id="10082" href="Data.Vec.Base.html#3076" class="Function Operator">_++</a> <a id="10086" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a><a id="10088" class="Symbol">)</a> <a id="10090" class="Symbol">(</a><a id="10091" href="Data.Vec.Properties.html#19840" class="Function">cast-++ˡ</a> <a id="10100" class="Symbol">(</a><a id="10101" href="Data.Nat.Properties.html#15642" class="Function">+-comm</a> <a id="10108" class="Number">1</a> <a id="10110" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9888" class="Bound">m</a><a id="10111" class="Symbol">)</a> <a id="10113" class="Symbol">(</a><a id="10114" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="10117" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10120" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a><a id="10121" class="Symbol">))</a>
                                                     <a id="10177" class="Symbol">(</a><a id="10178" href="Data.Vec.Properties.html#35459" class="Function">unfold-∷ʳ-eqFree</a> <a id="10195" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a> <a id="10197" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a><a id="10199" class="Symbol">))</a> <a id="10202" href="Data.Vec.Relation.Binary.Equality.Cast.html#3258" class="Function">⟨</a>
  <a id="10206" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10214" class="Symbol">((</a><a id="10216" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="10219" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10222" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a><a id="10223" class="Symbol">)</a> <a id="10225" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="10228" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a><a id="10230" class="Symbol">)</a>
    <a id="10236" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="10239" href="Data.Vec.Properties.html#40851" class="Function">reverse-++-eqFree</a> <a id="10257" class="Symbol">(</a><a id="10258" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="10261" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10264" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a><a id="10265" class="Symbol">)</a> <a id="10267" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a> <a id="10270" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="10274" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10282" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a> <a id="10285" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="10288" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10296" class="Symbol">(</a><a id="10297" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="10300" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10303" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a><a id="10304" class="Symbol">)</a>
    <a id="10310" href="Data.Vec.Relation.Binary.Equality.Cast.html#4137" class="Function">≂⟨</a> <a id="10313" href="Data.Vec.Properties.html#42305" class="Function">unfold-ʳ++</a> <a id="10324" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a> <a id="10327" class="Symbol">(</a><a id="10328" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10336" class="Symbol">(</a><a id="10337" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="10340" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10343" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a><a id="10344" class="Symbol">))</a> <a id="10347" href="Data.Vec.Relation.Binary.Equality.Cast.html#4137" class="Function">⟨</a>
  <a id="10351" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9903" class="Bound">ys</a> <a id="10354" href="Data.Vec.Base.html#8972" class="Function Operator">ʳ++</a> <a id="10358" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="10366" class="Symbol">(</a><a id="10367" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9900" class="Bound">xs</a> <a id="10370" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="10373" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#9898" class="Bound">a</a><a id="10374" class="Symbol">)</a>
    <a id="10380" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="10384" class="Keyword">where</a> <a id="10390" class="Keyword">open</a> <a id="10395" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="10410" class="Comment">------------------------------------------------------------------------</a>
<a id="10483" class="Comment">-- Interoperation between `_≈[_]_` and `_≡_`</a>
<a id="10528" class="Comment">--</a>
<a id="10531" class="Comment">-- This library is designed to interoperate with `_≡_`. Examples in the</a>
<a id="10603" class="Comment">-- combinators section showed how to apply `_≂⟨_⟩_` to take an `_≡_`</a>
<a id="10672" class="Comment">-- step during equational reasoning about `_≈[_]_`. Recall that</a>
<a id="10736" class="Comment">-- `xs ≈[ m≡n ] ys` is a shorthand for `cast m≡n xs ≡ ys`, the</a>
<a id="10799" class="Comment">-- combinator is essentially the composition of `_≡_` on the left-hand</a>
<a id="10870" class="Comment">-- side of `_≈[_]_`. Dually, the combinator `_≃⟨_⟩_` composes `_≡_` on</a>
<a id="10941" class="Comment">-- the right-hand side of `_≈[_]_`. Thus `_≃⟨_⟩_` intuitively ends the</a>
<a id="11012" class="Comment">-- reasoning system of `_≈[_]_` and switches back to the reasoning</a>
<a id="11079" class="Comment">-- system of `_≡_`.</a>
<a id="example5-fromList-++-++′"></a><a id="11099" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11099" class="Function">example5-fromList-++-++′</a> <a id="11124" class="Symbol">:</a> <a id="11126" class="Symbol">{</a><a id="11127" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11127" class="Bound">xs</a> <a id="11130" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11130" class="Bound">ys</a> <a id="11133" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11133" class="Bound">zs</a> <a id="11136" class="Symbol">:</a> <a id="11138" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="11143" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a><a id="11144" class="Symbol">}</a> <a id="11146" class="Symbol">→</a>
                           <a id="11175" class="Symbol">.(</a><a id="11177" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11177" class="Bound">eq</a> <a id="11180" class="Symbol">:</a> <a id="11182" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="11194" class="Symbol">(</a><a id="11195" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11127" class="Bound">xs</a> <a id="11198" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11206" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11130" class="Bound">ys</a> <a id="11209" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11217" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11133" class="Bound">zs</a><a id="11219" class="Symbol">)</a> <a id="11221" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                  <a id="11257" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="11269" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11127" class="Bound">xs</a> <a id="11272" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="11274" class="Symbol">(</a><a id="11275" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="11287" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11130" class="Bound">ys</a> <a id="11290" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="11292" href="Data.List.Base.html#5044" class="Function">List.length</a> <a id="11304" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11133" class="Bound">zs</a><a id="11306" class="Symbol">))</a> <a id="11309" class="Symbol">→</a>
                           <a id="11338" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="11343" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11177" class="Bound">eq</a> <a id="11346" class="Symbol">(</a><a id="11347" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11356" class="Symbol">(</a><a id="11357" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11127" class="Bound">xs</a> <a id="11360" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11368" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11130" class="Bound">ys</a> <a id="11371" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11379" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11133" class="Bound">zs</a><a id="11381" class="Symbol">))</a> <a id="11384" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a>
                                   <a id="11421" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11430" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11127" class="Bound">xs</a> <a id="11433" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11436" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11445" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11130" class="Bound">ys</a> <a id="11448" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11451" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11460" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11133" class="Bound">zs</a>
<a id="11463" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11099" class="Function">example5-fromList-++-++′</a> <a id="11488" class="Symbol">{</a><a id="11489" class="Argument">xs</a> <a id="11492" class="Symbol">=</a> <a id="11494" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11494" class="Bound">xs</a><a id="11496" class="Symbol">}</a> <a id="11498" class="Symbol">{</a><a id="11499" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11499" class="Bound">ys</a><a id="11501" class="Symbol">}</a> <a id="11503" class="Symbol">{</a><a id="11504" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11504" class="Bound">zs</a><a id="11506" class="Symbol">}</a> <a id="11508" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11508" class="Bound">eq</a> <a id="11511" class="Symbol">=</a> <a id="11513" href="Data.Vec.Relation.Binary.Equality.Cast.html#2733" class="Function Operator">begin</a>
  <a id="11521" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11530" class="Symbol">(</a><a id="11531" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11494" class="Bound">xs</a> <a id="11534" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11542" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11499" class="Bound">ys</a> <a id="11545" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11553" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11504" class="Bound">zs</a><a id="11555" class="Symbol">)</a>
    <a id="11561" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="11564" href="Data.Vec.Properties.html#54259" class="Function">fromList-++</a> <a id="11576" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11494" class="Bound">xs</a> <a id="11579" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="11583" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11592" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11494" class="Bound">xs</a> <a id="11595" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11598" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11607" class="Symbol">(</a><a id="11608" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11499" class="Bound">ys</a> <a id="11611" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11619" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11504" class="Bound">zs</a><a id="11621" class="Symbol">)</a>
    <a id="11627" href="Data.Vec.Relation.Binary.Equality.Cast.html#3585" class="Function">≃⟨</a> <a id="11630" href="Data.Vec.Properties.html#20119" class="Function">cast-++ʳ</a> <a id="11639" class="Symbol">(</a><a id="11640" href="Data.List.Properties.html#4987" class="Function">List.length-++</a> <a id="11655" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11499" class="Bound">ys</a><a id="11657" class="Symbol">)</a> <a id="11659" class="Symbol">(</a><a id="11660" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11669" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11494" class="Bound">xs</a><a id="11671" class="Symbol">)</a> <a id="11673" href="Data.Vec.Relation.Binary.Equality.Cast.html#3585" class="Function">⟩</a>
  <a id="11677" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11686" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11494" class="Bound">xs</a> <a id="11689" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11692" href="Data.Vec.Base.html#2821" class="Function">cast</a> <a id="11697" class="Symbol">_</a> <a id="11699" class="Symbol">(</a><a id="11700" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11709" class="Symbol">(</a><a id="11710" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11499" class="Bound">ys</a> <a id="11713" href="Data.List.Base.html#1734" class="Function Operator">List.++</a> <a id="11721" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11504" class="Bound">zs</a><a id="11723" class="Symbol">))</a>
    <a id="11730" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="11733" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="11738" class="Symbol">(</a><a id="11739" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11748" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11494" class="Bound">xs</a> <a id="11751" href="Data.Vec.Base.html#3076" class="Function Operator">++_</a><a id="11754" class="Symbol">)</a> <a id="11756" class="Symbol">(</a><a id="11757" href="Data.Vec.Properties.html#54259" class="Function">fromList-++</a> <a id="11769" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11499" class="Bound">ys</a><a id="11771" class="Symbol">)</a> <a id="11773" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="11777" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11786" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11494" class="Bound">xs</a> <a id="11789" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11792" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11801" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11499" class="Bound">ys</a> <a id="11804" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="11807" href="Data.Vec.Base.html#8496" class="Function">fromList</a> <a id="11816" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11504" class="Bound">zs</a>
    <a id="11823" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">≡-∎</a>
  <a id="11829" class="Keyword">where</a> <a id="11835" class="Keyword">open</a> <a id="11840" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="11855" class="Comment">-- Of course, it is possible to start with the reasoning system of `_≡_`</a>
<a id="11928" class="Comment">-- and then switch to the reasoning system of `_≈[_]_`.</a>
<a id="example6a-reverse-∷ʳ"></a><a id="11984" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11984" class="Function">example6a-reverse-∷ʳ</a> <a id="12005" class="Symbol">:</a> <a id="12007" class="Symbol">∀</a> <a id="12009" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12009" class="Bound">x</a> <a id="12011" class="Symbol">(</a><a id="12012" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12012" class="Bound">xs</a> <a id="12015" class="Symbol">:</a> <a id="12017" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="12021" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="12023" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="12024" class="Symbol">)</a> <a id="12026" class="Symbol">→</a> <a id="12028" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12036" class="Symbol">(</a><a id="12037" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12012" class="Bound">xs</a> <a id="12040" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12043" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12009" class="Bound">x</a><a id="12044" class="Symbol">)</a> <a id="12046" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12048" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12009" class="Bound">x</a> <a id="12050" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12052" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12060" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12012" class="Bound">xs</a>
<a id="12063" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#11984" class="Function">example6a-reverse-∷ʳ</a> <a id="12084" class="Symbol">{</a><a id="12085" class="Argument">n</a> <a id="12087" class="Symbol">=</a> <a id="12089" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12089" class="Bound">n</a><a id="12090" class="Symbol">}</a> <a id="12092" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12092" class="Bound">x</a> <a id="12094" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12094" class="Bound">xs</a> <a id="12097" class="Symbol">=</a> <a id="12099" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin-≡</a>
  <a id="12109" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12117" class="Symbol">(</a><a id="12118" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12094" class="Bound">xs</a> <a id="12121" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12124" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12092" class="Bound">x</a><a id="12125" class="Symbol">)</a>
    <a id="12131" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="12134" href="Data.Vec.Relation.Binary.Equality.Cast.html#1703" class="Function">≈-reflexive</a> <a id="12146" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="12151" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="12155" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12163" class="Symbol">(</a><a id="12164" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12094" class="Bound">xs</a> <a id="12167" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12170" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12092" class="Bound">x</a><a id="12171" class="Symbol">)</a>
    <a id="12177" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="12180" href="Data.Vec.Relation.Binary.Equality.Cast.html#4380" class="Function">≈-cong</a> <a id="12187" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12195" class="Symbol">(</a><a id="12196" href="Data.Vec.Properties.html#41644" class="Function">cast-reverse</a> <a id="12209" class="Symbol">_</a> <a id="12211" class="Symbol">_)</a> <a id="12214" class="Symbol">(</a><a id="12215" href="Data.Vec.Properties.html#35459" class="Function">unfold-∷ʳ-eqFree</a> <a id="12232" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12092" class="Bound">x</a> <a id="12234" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12094" class="Bound">xs</a><a id="12236" class="Symbol">)</a> <a id="12238" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="12242" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12250" class="Symbol">(</a><a id="12251" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12094" class="Bound">xs</a> <a id="12254" href="Data.Vec.Base.html#3076" class="Function Operator">++</a> <a id="12257" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="12259" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12092" class="Bound">x</a> <a id="12261" href="Data.Vec.Base.html#6459" class="Function Operator">]</a><a id="12262" class="Symbol">)</a>
    <a id="12268" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">≈⟨</a> <a id="12271" href="Data.Vec.Properties.html#40851" class="Function">reverse-++-eqFree</a> <a id="12289" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12094" class="Bound">xs</a> <a id="12292" href="Data.Vec.Base.html#6459" class="Function Operator">[</a> <a id="12294" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12092" class="Bound">x</a> <a id="12296" href="Data.Vec.Base.html#6459" class="Function Operator">]</a> <a id="12298" href="Data.Vec.Relation.Binary.Equality.Cast.html#3042" class="Function">⟩</a>
  <a id="12302" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12092" class="Bound">x</a> <a id="12304" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12306" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12314" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12094" class="Bound">xs</a>
    <a id="12321" href="Data.Vec.Relation.Binary.Equality.Cast.html#2840" class="Function Operator">∎</a>
  <a id="12325" class="Keyword">where</a> <a id="12331" class="Keyword">open</a> <a id="12336" href="Data.Vec.Relation.Binary.Equality.Cast.html#2637" class="Module">CastReasoning</a>

<a id="example6b-reverse-∷ʳ-by-induction"></a><a id="12351" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12351" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12385" class="Symbol">:</a> <a id="12387" class="Symbol">∀</a> <a id="12389" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12389" class="Bound">x</a> <a id="12391" class="Symbol">(</a><a id="12392" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12392" class="Bound">xs</a> <a id="12395" class="Symbol">:</a> <a id="12397" href="Data.Vec.Base.html#1119" class="Datatype">Vec</a> <a id="12401" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#892" class="Generalizable">A</a> <a id="12403" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#908" class="Generalizable">n</a><a id="12404" class="Symbol">)</a> <a id="12406" class="Symbol">→</a> <a id="12408" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12416" class="Symbol">(</a><a id="12417" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12392" class="Bound">xs</a> <a id="12420" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12423" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12389" class="Bound">x</a><a id="12424" class="Symbol">)</a> <a id="12426" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="12428" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12389" class="Bound">x</a> <a id="12430" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12432" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12440" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12392" class="Bound">xs</a>
<a id="12443" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12351" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12477" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12477" class="Bound">x</a> <a id="12479" href="Data.Vec.Base.html#1155" class="InductiveConstructor">[]</a>       <a id="12488" class="Symbol">=</a> <a id="12490" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="12495" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12351" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12529" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a> <a id="12531" class="Symbol">(</a><a id="12532" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a> <a id="12534" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12536" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a><a id="12538" class="Symbol">)</a> <a id="12540" class="Symbol">=</a> <a id="12542" href="Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
  <a id="12550" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12558" class="Symbol">(</a><a id="12559" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a> <a id="12561" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12563" class="Symbol">(</a><a id="12564" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a> <a id="12567" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12570" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a><a id="12571" class="Symbol">))</a> <a id="12574" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="12577" href="Data.Vec.Properties.html#38031" class="Function">reverse-∷</a> <a id="12587" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a> <a id="12589" class="Symbol">(</a><a id="12590" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a> <a id="12593" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12596" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a><a id="12597" class="Symbol">)</a> <a id="12599" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="12603" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12611" class="Symbol">(</a><a id="12612" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a> <a id="12615" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12618" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a><a id="12619" class="Symbol">)</a> <a id="12621" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12624" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a>  <a id="12627" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="12630" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="12635" class="Symbol">(</a><a id="12636" href="Data.Vec.Base.html#8754" class="Function Operator">_∷ʳ</a> <a id="12640" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a><a id="12641" class="Symbol">)</a> <a id="12643" class="Symbol">(</a><a id="12644" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12351" class="Function">example6b-reverse-∷ʳ-by-induction</a> <a id="12678" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a> <a id="12680" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a><a id="12682" class="Symbol">)</a> <a id="12684" href="Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
  <a id="12688" class="Symbol">(</a><a id="12689" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a> <a id="12691" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12693" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12701" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a><a id="12703" class="Symbol">)</a> <a id="12705" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12708" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a>   <a id="12712" href="Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
  <a id="12718" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a> <a id="12720" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12722" class="Symbol">(</a><a id="12723" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12731" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a> <a id="12734" href="Data.Vec.Base.html#8754" class="Function Operator">∷ʳ</a> <a id="12737" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a><a id="12738" class="Symbol">)</a>   <a id="12742" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">≡⟨</a> <a id="12745" href="Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="12750" class="Symbol">(</a><a id="12751" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a> <a id="12753" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷_</a><a id="12755" class="Symbol">)</a> <a id="12757" class="Symbol">(</a><a id="12758" href="Data.Vec.Properties.html#38031" class="Function">reverse-∷</a> <a id="12768" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a> <a id="12770" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a><a id="12772" class="Symbol">)</a> <a id="12774" href="Relation.Binary.Reasoning.Syntax.html#11140" class="Function">⟨</a>
  <a id="12778" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12529" class="Bound">x</a> <a id="12780" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12782" href="Data.Vec.Base.html#8862" class="Function">reverse</a> <a id="12790" class="Symbol">(</a><a id="12791" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12532" class="Bound">y</a> <a id="12793" href="Data.Vec.Base.html#1174" class="InductiveConstructor Operator">∷</a> <a id="12795" href="README.Data.Vec.Relation.Binary.Equality.Cast.html#12536" class="Bound">xs</a><a id="12797" class="Symbol">)</a>    <a id="12802" href="Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
  <a id="12806" class="Keyword">where</a> <a id="12812" class="Keyword">open</a> <a id="12817" href="Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">≡-Reasoning</a>
</pre></body></html>