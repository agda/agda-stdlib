<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Foreign.Haskell</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A simple example of a program using the foreign function interface</a>
<a id="176" class="Comment">------------------------------------------------------------------------</a>

<a id="250" class="Symbol">{-#</a> <a id="254" class="Keyword">OPTIONS</a> <a id="262" class="Pragma">--guardedness</a> <a id="276" class="Symbol">#-}</a>

<a id="281" class="Keyword">module</a> <a id="288" href="README.Foreign.Haskell.html" class="Module">README.Foreign.Haskell</a> <a id="311" class="Keyword">where</a>

<a id="318" class="Comment">-- In order to be considered safe by Agda, the standard library cannot</a>
<a id="389" class="Comment">-- add COMPILE pragmas binding the inductive types it defines to concrete</a>
<a id="463" class="Comment">-- Haskell types.</a>

<a id="482" class="Comment">-- To work around this limitation, we have defined FFI-friendly versions</a>
<a id="555" class="Comment">-- of these types together with a zero-cost coercion `coerce`.</a>

<a id="619" class="Keyword">open</a> <a id="624" class="Keyword">import</a> <a id="631" href="Level.html" class="Module">Level</a> <a id="637" class="Keyword">using</a> <a id="643" class="Symbol">(</a><a id="644" href="Agda.Primitive.html#742" class="Postulate">Level</a><a id="649" class="Symbol">)</a>
<a id="651" class="Keyword">open</a> <a id="656" class="Keyword">import</a> <a id="663" href="Agda.Builtin.Int.html" class="Module">Agda.Builtin.Int</a>
<a id="680" class="Keyword">open</a> <a id="685" class="Keyword">import</a> <a id="692" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a>
<a id="709" class="Keyword">open</a> <a id="714" class="Keyword">import</a> <a id="721" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="736" class="Keyword">using</a> <a id="742" class="Symbol">(</a><a id="743" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="747" class="Symbol">;</a> <a id="749" href="Data.Bool.Base.html#1505" class="Function Operator">if_then_else_</a><a id="762" class="Symbol">)</a>
<a id="764" class="Keyword">open</a> <a id="769" class="Keyword">import</a> <a id="776" href="Data.Char.html" class="Module">Data.Char</a> <a id="786" class="Symbol">as</a> <a id="789" class="Module">Char</a>
<a id="794" class="Keyword">open</a> <a id="799" class="Keyword">import</a> <a id="806" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="821" class="Symbol">as</a> <a id="824" class="Module">List</a> <a id="829" class="Keyword">using</a> <a id="835" class="Symbol">(</a><a id="836" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="840" class="Symbol">;</a> <a id="842" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="845" class="Symbol">;</a> <a id="847" href="Data.List.Base.html#7793" class="InductiveConstructor">[]</a><a id="849" class="Symbol">;</a> <a id="851" href="Data.List.Base.html#10366" class="Function">takeWhile</a><a id="860" class="Symbol">;</a> <a id="862" href="Data.List.Base.html#10622" class="Function">dropWhile</a><a id="871" class="Symbol">)</a>
<a id="873" class="Keyword">open</a> <a id="878" class="Keyword">import</a> <a id="885" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="901" class="Keyword">using</a> <a id="907" class="Symbol">(</a><a id="908" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a><a id="913" class="Symbol">;</a> <a id="915" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a><a id="919" class="Symbol">;</a> <a id="921" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="928" class="Symbol">)</a>
<a id="930" class="Keyword">open</a> <a id="935" class="Keyword">import</a> <a id="942" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="960" class="Keyword">using</a> <a id="966" class="Symbol">(</a><a id="967" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="970" class="Symbol">;</a> <a id="972" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="975" class="Symbol">)</a>
<a id="977" class="Keyword">open</a> <a id="982" class="Keyword">import</a> <a id="989" href="Function.html" class="Module">Function</a>
<a id="998" class="Keyword">open</a> <a id="1003" class="Keyword">import</a> <a id="1010" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="1038" class="Keyword">import</a> <a id="1045" href="Foreign.Haskell.html" class="Module">Foreign.Haskell</a> <a id="1061" class="Symbol">as</a> <a id="1064" class="Module">FFI</a>
<a id="1068" class="Keyword">open</a> <a id="1073" class="Keyword">import</a> <a id="1080" href="Foreign.Haskell.Coerce.html" class="Module">Foreign.Haskell.Coerce</a>

<a id="1104" class="Keyword">private</a>
  <a id="1114" class="Keyword">variable</a>
    <a id="1127" href="README.Foreign.Haskell.html#1127" class="Generalizable">a</a> <a id="1129" class="Symbol">:</a> <a id="1131" href="Agda.Primitive.html#742" class="Postulate">Level</a>
    <a id="1141" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a> <a id="1143" class="Symbol">:</a> <a id="1145" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1149" href="README.Foreign.Haskell.html#1127" class="Generalizable">a</a>

<a id="1152" class="Comment">-- Here we use the FFI version of Pair.</a>

<a id="1193" class="Keyword">postulate</a>
  <a id="primUncons"></a><a id="1205" href="README.Foreign.Haskell.html#1205" class="Postulate">primUncons</a>    <a id="1219" class="Symbol">:</a> <a id="1221" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="1226" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a> <a id="1228" class="Symbol">→</a> <a id="1230" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1236" class="Symbol">(</a><a id="1237" href="Foreign.Haskell.Pair.html#534" class="Record">FFI.Pair</a> <a id="1246" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a> <a id="1248" class="Symbol">(</a><a id="1249" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="1254" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a><a id="1255" class="Symbol">))</a>
  <a id="primCatMaybes"></a><a id="1260" href="README.Foreign.Haskell.html#1260" class="Postulate">primCatMaybes</a> <a id="1274" class="Symbol">:</a> <a id="1276" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="1281" class="Symbol">(</a><a id="1282" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1288" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a><a id="1289" class="Symbol">)</a> <a id="1291" class="Symbol">→</a> <a id="1293" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="1298" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a>
  <a id="primTestChar"></a><a id="1302" href="README.Foreign.Haskell.html#1302" class="Postulate">primTestChar</a>  <a id="1316" class="Symbol">:</a> <a id="1318" href="Agda.Builtin.Char.html#238" class="Postulate">Char</a> <a id="1323" class="Symbol">→</a> <a id="1325" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
  <a id="primIntEq"></a><a id="1332" href="README.Foreign.Haskell.html#1332" class="Postulate">primIntEq</a>     <a id="1346" class="Symbol">:</a> <a id="1348" href="Agda.Builtin.Int.html#245" class="Datatype">Int</a> <a id="1352" class="Symbol">→</a> <a id="1354" href="Agda.Builtin.Int.html#245" class="Datatype">Int</a> <a id="1358" class="Symbol">→</a> <a id="1360" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>

<a id="1366" class="Symbol">{-#</a> <a id="1370" class="Keyword">COMPILE</a> <a id="1378" class="Keyword">GHC</a> <a id="1382" href="README.Foreign.Haskell.html#1205" class="Postulate">primUncons</a> <a id="1393" class="Pragma">=</a> <a id="1395" class="Pragma">\</a> <a id="1397" class="Pragma">_</a> <a id="1399" class="Pragma">_</a> <a id="1401" class="Pragma">xs</a> <a id="1404" class="Pragma">-&gt;</a> <a id="1407" class="Pragma">case</a> <a id="1412" class="Pragma">xs</a> <a id="1415" class="Pragma">of</a>
  <a id="1420" class="Pragma">{</a> <a id="1422" class="Pragma">[]</a>       <a id="1431" class="Pragma">-&gt;</a> <a id="1434" class="Pragma">Nothing</a>
  <a id="1444" class="Pragma">;</a> <a id="1446" class="Pragma">(x</a> <a id="1449" class="Pragma">:</a> <a id="1451" class="Pragma">xs)</a> <a id="1455" class="Pragma">-&gt;</a> <a id="1458" class="Pragma">Just</a> <a id="1463" class="Pragma">(x,</a> <a id="1467" class="Pragma">xs)</a>
  <a id="1473" class="Pragma">}</a>
<a id="1475" class="Symbol">#-}</a>

<a id="1480" class="Symbol">{-#</a> <a id="1484" class="Keyword">FOREIGN</a> <a id="1492" class="Pragma">GHC</a> <a id="1496" class="Pragma">import</a> <a id="1503" class="Pragma">Data.Maybe</a> <a id="1514" class="Symbol">#-}</a>
<a id="1518" class="Symbol">{-#</a> <a id="1522" class="Keyword">COMPILE</a> <a id="1530" class="Keyword">GHC</a> <a id="1534" href="README.Foreign.Haskell.html#1260" class="Postulate">primCatMaybes</a> <a id="1548" class="Pragma">=</a> <a id="1550" class="Pragma">\</a> <a id="1552" class="Pragma">_</a> <a id="1554" class="Pragma">_</a> <a id="1556" class="Pragma">-&gt;</a> <a id="1559" class="Pragma">catMaybes</a> <a id="1569" class="Symbol">#-}</a>

<a id="1574" class="Symbol">{-#</a> <a id="1578" class="Keyword">COMPILE</a> <a id="1586" class="Keyword">GHC</a> <a id="1590" href="README.Foreign.Haskell.html#1302" class="Postulate">primTestChar</a> <a id="1603" class="Pragma">=</a> <a id="1605" class="Pragma">(&#39;-&#39;</a> <a id="1610" class="Pragma">/=)</a> <a id="1614" class="Symbol">#-}</a>

<a id="1619" class="Symbol">{-#</a> <a id="1623" class="Keyword">COMPILE</a> <a id="1631" class="Keyword">GHC</a> <a id="1635" href="README.Foreign.Haskell.html#1332" class="Postulate">primIntEq</a> <a id="1645" class="Pragma">=</a> <a id="1647" class="Pragma">(==)</a> <a id="1652" class="Symbol">#-}</a>

<a id="1657" class="Comment">-- We however want to use the notion of Pair internal to the standard library.</a>
<a id="1736" class="Comment">-- For this we use `coerce` to take use back to the types we are used to.</a>

<a id="1811" class="Comment">-- The typeclass mechanism uses the coercion rules for Pair, as well as the</a>
<a id="1887" class="Comment">-- knowledge that natural numbers are represented as integers.</a>
<a id="1950" class="Comment">-- We additionally benefit from the congruence rules for List, Maybe, Char,</a>
<a id="2026" class="Comment">-- Bool, and a reflexivity principle for variable A.</a>

<a id="uncons"></a><a id="2080" href="README.Foreign.Haskell.html#2080" class="Function">uncons</a> <a id="2087" class="Symbol">:</a> <a id="2089" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2094" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a> <a id="2096" class="Symbol">→</a> <a id="2098" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2104" class="Symbol">(</a><a id="2105" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a> <a id="2107" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="2109" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2114" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a><a id="2115" class="Symbol">)</a>
<a id="2117" href="README.Foreign.Haskell.html#2080" class="Function">uncons</a> <a id="2124" class="Symbol">=</a> <a id="2126" href="Foreign.Haskell.Coerce.html#2740" class="Postulate">coerce</a> <a id="2133" href="README.Foreign.Haskell.html#1205" class="Postulate">primUncons</a>

<a id="catMaybes"></a><a id="2145" href="README.Foreign.Haskell.html#2145" class="Function">catMaybes</a> <a id="2155" class="Symbol">:</a> <a id="2157" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2162" class="Symbol">(</a><a id="2163" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2169" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a><a id="2170" class="Symbol">)</a> <a id="2172" class="Symbol">→</a> <a id="2174" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2179" href="README.Foreign.Haskell.html#1141" class="Generalizable">A</a>
<a id="2181" href="README.Foreign.Haskell.html#2145" class="Function">catMaybes</a> <a id="2191" class="Symbol">=</a> <a id="2193" href="README.Foreign.Haskell.html#1260" class="Postulate">primCatMaybes</a>

<a id="testChar"></a><a id="2208" href="README.Foreign.Haskell.html#2208" class="Function">testChar</a> <a id="2217" class="Symbol">:</a> <a id="2219" href="Agda.Builtin.Char.html#238" class="Postulate">Char</a> <a id="2224" class="Symbol">→</a> <a id="2226" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
<a id="2231" href="README.Foreign.Haskell.html#2208" class="Function">testChar</a> <a id="2240" class="Symbol">=</a> <a id="2242" href="Foreign.Haskell.Coerce.html#2740" class="Postulate">coerce</a> <a id="2249" href="README.Foreign.Haskell.html#1302" class="Postulate">primTestChar</a>
  <a id="2264" class="Comment">-- note that coerce is useless here but the proof could come from</a>
  <a id="2332" class="Comment">-- either `coerce-fun coerce-refl coerce-refl` or `coerce-refl` alone</a>
  <a id="2404" class="Comment">-- We (and Agda) do not care which proof we got.</a>

<a id="eqNat"></a><a id="2454" href="README.Foreign.Haskell.html#2454" class="Function">eqNat</a> <a id="2460" class="Symbol">:</a> <a id="2462" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a> <a id="2466" class="Symbol">→</a> <a id="2468" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a> <a id="2472" class="Symbol">→</a> <a id="2474" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
<a id="2479" href="README.Foreign.Haskell.html#2454" class="Function">eqNat</a> <a id="2485" class="Symbol">=</a> <a id="2487" href="Foreign.Haskell.Coerce.html#2740" class="Postulate">coerce</a> <a id="2494" href="README.Foreign.Haskell.html#1332" class="Postulate">primIntEq</a>
  <a id="2506" class="Comment">-- We can coerce `Nat` to `Int` but not `Int` to `Nat`. This fundamentally</a>
  <a id="2583" class="Comment">-- relies on the fact that `Coercible` understands that functions are</a>
  <a id="2655" class="Comment">-- contravariant.</a>

<a id="2674" class="Keyword">open</a> <a id="2679" class="Keyword">import</a> <a id="2686" href="IO.html" class="Module">IO</a>
<a id="2689" class="Keyword">open</a> <a id="2694" class="Keyword">import</a> <a id="2701" href="Codata.Musical.Notation.html" class="Module">Codata.Musical.Notation</a>
<a id="2725" class="Keyword">open</a> <a id="2730" class="Keyword">import</a> <a id="2737" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="2754" class="Keyword">using</a> <a id="2760" class="Symbol">(</a><a id="2761" href="Data.String.Base.html#1537" class="Primitive">toList</a><a id="2767" class="Symbol">;</a> <a id="2769" href="Data.String.Base.html#1570" class="Primitive">fromList</a><a id="2777" class="Symbol">;</a> <a id="2779" href="Data.String.Base.html#2805" class="Function">unlines</a><a id="2786" class="Symbol">;</a> <a id="2788" href="Data.String.Base.html#2404" class="Function Operator">_++_</a><a id="2792" class="Symbol">)</a>
<a id="2794" class="Keyword">open</a> <a id="2799" class="Keyword">import</a> <a id="2806" href="Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a>

<a id="2833" class="Comment">-- example program using uncons, catMaybes, and testChar</a>

<a id="main"></a><a id="2891" href="README.Foreign.Haskell.html#2891" class="Function">main</a> <a id="2896" class="Symbol">=</a> <a id="2898" href="IO.Base.html#2669" class="Function">run</a> <a id="2902" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2904" class="Keyword">do</a>
  <a id="2909" href="README.Foreign.Haskell.html#2909" class="Bound">content</a> <a id="2917" href="IO.Base.html#2084" class="Function Operator">←</a> <a id="2919" href="IO.html#2873" class="Function">readFiniteFile</a> <a id="2934" class="String">&quot;README/Foreign/Haskell.agda&quot;</a>
  <a id="2966" class="Keyword">let</a> <a id="2970" href="README.Foreign.Haskell.html#2970" class="Bound">chars</a> <a id="2976" class="Symbol">=</a> <a id="2978" href="Data.String.Base.html#1537" class="Primitive">toList</a> <a id="2985" href="README.Foreign.Haskell.html#2909" class="Bound">content</a>
  <a id="2995" class="Keyword">let</a> <a id="2999" href="README.Foreign.Haskell.html#2999" class="Bound">cleanup</a> <a id="3007" class="Symbol">=</a> <a id="3009" href="README.Foreign.Haskell.html#2145" class="Function">catMaybes</a> <a id="3019" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3021" href="Data.List.Base.html#1631" class="Function">List.map</a> <a id="3030" class="Symbol">(λ</a> <a id="3033" href="README.Foreign.Haskell.html#3033" class="Bound">c</a> <a id="3035" class="Symbol">→</a> <a id="3037" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="3040" href="README.Foreign.Haskell.html#2208" class="Function">testChar</a> <a id="3049" href="README.Foreign.Haskell.html#3033" class="Bound">c</a> <a id="3051" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="3056" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="3061" href="README.Foreign.Haskell.html#3033" class="Bound">c</a> <a id="3063" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="3068" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="3075" class="Symbol">)</a>
  <a id="3079" class="Keyword">let</a> <a id="3083" href="README.Foreign.Haskell.html#3083" class="Bound">cleaned</a> <a id="3091" class="Symbol">=</a> <a id="3093" href="Data.List.Base.html#10622" class="Function">dropWhile</a> <a id="3103" class="Symbol">(</a><a id="3104" class="String">&#39;\n&#39;</a> <a id="3109" href="Data.Char.Properties.html#2071" class="Function Operator">≟_</a><a id="3111" class="Symbol">)</a> <a id="3113" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3115" href="README.Foreign.Haskell.html#2999" class="Bound">cleanup</a> <a id="3123" href="README.Foreign.Haskell.html#2970" class="Bound">chars</a>
  <a id="3131" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="3136" href="README.Foreign.Haskell.html#2080" class="Function">uncons</a> <a id="3143" href="README.Foreign.Haskell.html#3083" class="Bound">cleaned</a> <a id="3151" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="3154" class="Symbol">λ</a> <a id="3156" class="Keyword">where</a>
    <a id="3166" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>         <a id="3182" class="Symbol">→</a> <a id="3184" href="IO.Finite.html#1506" class="Function">putStrLn</a> <a id="3193" class="String">&quot;I cannot believe this file is filed with dashes only!&quot;</a>
    <a id="3253" class="Symbol">(</a><a id="3254" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="3259" class="Symbol">(</a><a id="3260" href="README.Foreign.Haskell.html#3260" class="Bound">c</a> <a id="3262" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3264" href="README.Foreign.Haskell.html#3264" class="Bound">cs</a><a id="3266" class="Symbol">))</a> <a id="3269" class="Symbol">→</a> <a id="3271" href="IO.Finite.html#1506" class="Function">putStrLn</a> <a id="3280" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3282" href="Data.String.Base.html#2805" class="Function">unlines</a>
                    <a id="3310" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3312" class="Symbol">(</a><a id="3313" class="String">&quot;First (non dash) character: &quot;</a> <a id="3344" href="Data.String.Base.html#2404" class="Function Operator">++</a> <a id="3347" href="Data.Char.Base.html#1245" class="Primitive">Char.show</a> <a id="3357" href="README.Foreign.Haskell.html#3260" class="Bound">c</a><a id="3358" class="Symbol">)</a>
                    <a id="3380" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3382" class="Symbol">(</a><a id="3383" class="String">&quot;Rest (dash free) of the line: &quot;</a> <a id="3416" href="Data.String.Base.html#2404" class="Function Operator">++</a> <a id="3419" href="Data.String.Base.html#1570" class="Primitive">fromList</a> <a id="3428" class="Symbol">(</a><a id="3429" href="Data.List.Base.html#10366" class="Function">takeWhile</a> <a id="3439" class="Symbol">(</a><a id="3440" href="Relation.Nullary.Decidable.Core.html#2517" class="Function">¬?</a> <a id="3443" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3445" class="Symbol">(</a><a id="3446" class="String">&#39;\n&#39;</a> <a id="3451" href="Data.Char.Properties.html#2071" class="Function Operator">≟_</a><a id="3453" class="Symbol">))</a> <a id="3456" href="README.Foreign.Haskell.html#3264" class="Bound">cs</a><a id="3458" class="Symbol">))</a>
                    <a id="3481" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3483" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="3487" class="Comment">-- You can compile and run this test by writing:</a>
<a id="3536" class="Comment">-- agda -c Haskell.agda</a>
<a id="3560" class="Comment">-- ../../Haskell</a>

<a id="3578" class="Comment">-- You should see the following text (without the indentation on the left):</a>
<a id="3654" class="Comment">--   First (non dash) character: &#39; &#39;</a>
<a id="3691" class="Comment">--   Rest (dash free) of the line: The Agda standard library</a>
</pre></body></html>