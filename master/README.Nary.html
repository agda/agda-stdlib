<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Nary</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the generic n-ary operations the stdlib provides</a>
<a id="179" class="Comment">-- can be used</a>
<a id="194" class="Comment">------------------------------------------------------------------------</a>

<a id="268" class="Symbol">{-#</a> <a id="272" class="Keyword">OPTIONS</a> <a id="280" class="Pragma">--cubical-compatible</a> <a id="301" class="Pragma">--safe</a> <a id="308" class="Symbol">#-}</a>

<a id="313" class="Keyword">module</a> <a id="320" href="README.Nary.html" class="Module">README.Nary</a> <a id="332" class="Keyword">where</a>

<a id="339" class="Keyword">open</a> <a id="344" class="Keyword">import</a> <a id="351" href="Level.html" class="Module">Level</a> <a id="357" class="Keyword">using</a> <a id="363" class="Symbol">(</a><a id="364" href="Agda.Primitive.html#742" class="Postulate">Level</a><a id="369" class="Symbol">)</a>
<a id="371" class="Keyword">open</a> <a id="376" class="Keyword">import</a> <a id="383" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="397" class="Keyword">open</a> <a id="402" class="Keyword">import</a> <a id="409" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="429" class="Keyword">open</a> <a id="434" class="Keyword">import</a> <a id="441" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="450" class="Keyword">using</a> <a id="456" class="Symbol">(</a><a id="457" href="Data.Fin.Base.html#1154" class="Datatype">Fin</a><a id="460" class="Symbol">;</a> <a id="462" href="Data.Fin.Base.html#1847" class="Function">fromℕ</a><a id="467" class="Symbol">;</a> <a id="469" href="Data.Fin.html#739" class="Function Operator">#_</a><a id="471" class="Symbol">;</a> <a id="473" href="Data.Fin.Base.html#3077" class="Function">inject₁</a><a id="480" class="Symbol">)</a>
<a id="482" class="Keyword">open</a> <a id="487" class="Keyword">import</a> <a id="494" href="Data.List.html" class="Module">Data.List</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>
<a id="537" class="Keyword">open</a> <a id="542" class="Keyword">import</a> <a id="549" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="567" class="Keyword">using</a> <a id="573" class="Symbol">(</a><a id="574" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="577" class="Symbol">;</a> <a id="579" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="582" class="Symbol">)</a>
<a id="584" class="Keyword">open</a> <a id="589" class="Keyword">import</a> <a id="596" href="Data.Sum.Base.html" class="Module">Data.Sum.Base</a> <a id="610" class="Keyword">using</a> <a id="616" class="Symbol">(</a><a id="617" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="621" class="Symbol">;</a> <a id="623" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="627" class="Symbol">)</a>
<a id="629" class="Keyword">open</a> <a id="634" class="Keyword">import</a> <a id="641" href="Function.Base.html" class="Module">Function.Base</a> <a id="655" class="Keyword">using</a> <a id="661" class="Symbol">(</a><a id="662" href="Function.Base.html#704" class="Function">id</a><a id="664" class="Symbol">;</a> <a id="666" href="Function.Base.html#1638" class="Function">flip</a><a id="670" class="Symbol">;</a> <a id="672" href="Function.Base.html#3626" class="Function Operator">_∘′_</a><a id="676" class="Symbol">)</a>
<a id="678" class="Keyword">open</a> <a id="683" class="Keyword">import</a> <a id="690" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="707" class="Keyword">open</a> <a id="712" class="Keyword">import</a> <a id="719" href="Relation.Binary.Definitions.html" class="Module">Relation.Binary.Definitions</a> <a id="747" class="Keyword">using</a> <a id="753" class="Symbol">(</a><a id="754" class="Keyword">module</a> <a id="761" href="Relation.Binary.Definitions.html#3038" class="Module">Tri</a><a id="764" class="Symbol">);</a> <a id="767" class="Keyword">open</a> <a id="772" href="Relation.Binary.Definitions.html#3038" class="Module">Tri</a>
<a id="776" class="Keyword">open</a> <a id="781" class="Keyword">import</a> <a id="788" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="827" class="Keyword">private</a>
  <a id="837" class="Keyword">variable</a>
    <a id="850" href="README.Nary.html#850" class="Generalizable">a</a> <a id="852" href="README.Nary.html#852" class="Generalizable">b</a> <a id="854" href="README.Nary.html#854" class="Generalizable">c</a> <a id="856" href="README.Nary.html#856" class="Generalizable">d</a> <a id="858" href="README.Nary.html#858" class="Generalizable">e</a> <a id="860" class="Symbol">:</a> <a id="862" href="Agda.Primitive.html#742" class="Postulate">Level</a>
    <a id="872" href="README.Nary.html#872" class="Generalizable">A</a> <a id="874" class="Symbol">:</a> <a id="876" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="880" href="README.Nary.html#850" class="Generalizable">a</a>
    <a id="886" href="README.Nary.html#886" class="Generalizable">B</a> <a id="888" class="Symbol">:</a> <a id="890" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="894" href="README.Nary.html#852" class="Generalizable">b</a>
    <a id="900" href="README.Nary.html#900" class="Generalizable">C</a> <a id="902" class="Symbol">:</a> <a id="904" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="908" href="README.Nary.html#854" class="Generalizable">c</a>
    <a id="914" href="README.Nary.html#914" class="Generalizable">D</a> <a id="916" class="Symbol">:</a> <a id="918" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="922" href="README.Nary.html#856" class="Generalizable">d</a>
    <a id="928" href="README.Nary.html#928" class="Generalizable">E</a> <a id="930" class="Symbol">:</a> <a id="932" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="936" href="README.Nary.html#858" class="Generalizable">e</a>

<a id="939" class="Comment">------------------------------------------------------------------------</a>
<a id="1012" class="Comment">-- Introduction</a>
<a id="1028" class="Comment">------------------------------------------------------------------------</a>

<a id="1102" class="Comment">-- Function.Nary.NonDependent and Data.Product.N-ary.Heterogeneous provide</a>
<a id="1177" class="Comment">-- a generic representation of n-ary heterogeneous (non dependent) products</a>
<a id="1253" class="Comment">-- and the corresponding types of (non-dependent) n-ary functions. The</a>
<a id="1324" class="Comment">-- representation works well with inference thus allowing us to use generic</a>
<a id="1400" class="Comment">-- combinators to manipulate such functions.</a>

<a id="1446" class="Keyword">open</a> <a id="1451" class="Keyword">import</a> <a id="1458" href="Data.Product.Nary.NonDependent.html" class="Module">Data.Product.Nary.NonDependent</a>
<a id="1489" class="Keyword">open</a> <a id="1494" class="Keyword">import</a> <a id="1501" href="Function.Nary.NonDependent.html" class="Module">Function.Nary.NonDependent</a>
<a id="1528" class="Keyword">open</a> <a id="1533" class="Keyword">import</a> <a id="1540" href="Relation.Nary.html" class="Module">Relation.Nary</a>


<a id="1556" class="Comment">------------------------------------------------------------------------</a>
<a id="1629" class="Comment">-- Generalised equality-manipulating combinators</a>
<a id="1678" class="Comment">------------------------------------------------------------------------</a>

<a id="1752" class="Comment">-- By default the standard library provides users with (we are leaving out</a>
<a id="1827" class="Comment">-- the implicit arguments here):</a>
<a id="1860" class="Comment">--</a>
<a id="1863" class="Comment">-- cong   : (f : A₁      → B) → a₁ ≡ b₁           → f a₁   ≡ f b₁</a>
<a id="1929" class="Comment">-- cong₂  : (f : A₁ → A₂ → B) → a₁ ≡ b₁ → a₂ ≡ b₂ → f a₁ a₂ ≡ f b₁ b₂</a>
<a id="1999" class="Comment">--</a>
<a id="2002" class="Comment">-- and</a>
<a id="2009" class="Comment">--</a>
<a id="2012" class="Comment">-- subst  : (P : A₁      → Set p) → a₁ ≡ b₁           → P a₁    → P b₁</a>
<a id="2083" class="Comment">-- subst₂ : (P : A₁ → A₂ → Set p) → a₁ ≡ b₁ → a₂ ≡ b₂ → P a₁ a₂ → P b₁ b₂</a>
<a id="2157" class="Comment">--</a>
<a id="2160" class="Comment">-- This pattern can be generalised to any natural number `n`. Thanks to our</a>
<a id="2236" class="Comment">-- library for n-ary functions, we can write the types and implementations</a>
<a id="2311" class="Comment">-- of `congₙ` and `substₙ`.</a>

<a id="2340" class="Comment">------------------------------------------------------------------------</a>
<a id="2413" class="Comment">-- congₙ : ∀ n (f : A₁ → ⋯ → Aₙ → B) →</a>
<a id="2452" class="Comment">--         a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → f a₁ ⋯ aₙ ≡ f b₁ ⋯ bₙ</a>

<a id="2508" class="Comment">-- It may be used directly to prove something:</a>

<a id="2556" href="README.Nary.html#2556" class="Function">_</a> <a id="2558" class="Symbol">:</a> <a id="2560" class="Symbol">∀</a> <a id="2562" class="Symbol">(</a><a id="2563" href="README.Nary.html#2563" class="Bound">as</a> <a id="2566" href="README.Nary.html#2566" class="Bound">bs</a> <a id="2569" href="README.Nary.html#2569" class="Bound">cs</a> <a id="2572" class="Symbol">:</a> <a id="2574" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2579" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2580" class="Symbol">)</a> <a id="2582" class="Symbol">→</a>
       <a id="2591" href="Data.List.Base.html#3714" class="Function">zip</a> <a id="2595" class="Symbol">(</a><a id="2596" href="Data.List.Base.html#3714" class="Function">zip</a> <a id="2600" class="Symbol">(</a><a id="2601" href="README.Nary.html#2563" class="Bound">as</a> <a id="2604" href="Data.List.Base.html#1954" class="Function Operator">++</a> <a id="2607" class="InductiveConstructor">[]</a><a id="2609" class="Symbol">)</a> <a id="2611" class="Symbol">(</a><a id="2612" href="Data.List.Base.html#1631" class="Function">map</a> <a id="2616" href="Function.Base.html#704" class="Function">id</a> <a id="2619" href="README.Nary.html#2569" class="Bound">cs</a><a id="2621" class="Symbol">))</a> <a id="2624" class="Symbol">(</a><a id="2625" href="Data.List.Base.html#7419" class="Function">reverse</a> <a id="2633" class="Symbol">(</a><a id="2634" href="Data.List.Base.html#7419" class="Function">reverse</a> <a id="2642" href="README.Nary.html#2566" class="Bound">bs</a><a id="2644" class="Symbol">))</a>
     <a id="2652" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2654" href="Data.List.Base.html#3714" class="Function">zip</a> <a id="2658" class="Symbol">(</a><a id="2659" href="Data.List.Base.html#3714" class="Function">zip</a> <a id="2663" href="README.Nary.html#2563" class="Bound">as</a> <a id="2666" href="README.Nary.html#2569" class="Bound">cs</a><a id="2668" class="Symbol">)</a> <a id="2670" href="README.Nary.html#2566" class="Bound">bs</a>
<a id="2673" class="Symbol">_</a> <a id="2675" class="Symbol">=</a> <a id="2677" class="Symbol">λ</a> <a id="2679" href="README.Nary.html#2679" class="Bound">as</a> <a id="2682" href="README.Nary.html#2682" class="Bound">bs</a> <a id="2685" href="README.Nary.html#2685" class="Bound">cs</a> <a id="2688" class="Symbol">→</a> <a id="2690" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="2696" class="Number">3</a> <a id="2698" class="Symbol">(λ</a> <a id="2701" href="README.Nary.html#2701" class="Bound">as</a> <a id="2704" href="README.Nary.html#2704" class="Bound">bs</a> <a id="2707" class="Symbol">→</a> <a id="2709" href="Data.List.Base.html#3714" class="Function">zip</a> <a id="2713" class="Symbol">(</a><a id="2714" href="Data.List.Base.html#3714" class="Function">zip</a> <a id="2718" href="README.Nary.html#2701" class="Bound">as</a> <a id="2721" href="README.Nary.html#2704" class="Bound">bs</a><a id="2723" class="Symbol">))</a>
                         <a id="2751" class="Symbol">(</a><a id="2752" href="Data.List.Properties.html#5949" class="Function">++-identityʳ</a> <a id="2765" href="README.Nary.html#2679" class="Bound">as</a><a id="2767" class="Symbol">)</a>
                         <a id="2794" class="Symbol">(</a><a id="2795" href="Data.List.Properties.html#3204" class="Function">map-id</a> <a id="2802" href="README.Nary.html#2685" class="Bound">cs</a><a id="2804" class="Symbol">)</a>
                         <a id="2831" class="Symbol">(</a><a id="2832" href="Data.List.Properties.html#42957" class="Function">reverse-involutive</a> <a id="2851" href="README.Nary.html#2682" class="Bound">bs</a><a id="2853" class="Symbol">)</a>

<a id="2856" class="Comment">-- Or as part of a longer derivation:</a>

<a id="2895" href="README.Nary.html#2895" class="Function">_</a> <a id="2897" class="Symbol">:</a> <a id="2899" class="Symbol">∀</a> <a id="2901" href="README.Nary.html#2901" class="Bound">m</a> <a id="2903" href="README.Nary.html#2903" class="Bound">n</a> <a id="2905" href="README.Nary.html#2905" class="Bound">p</a> <a id="2907" href="README.Nary.html#2907" class="Bound">q</a> <a id="2909" class="Symbol">→</a> <a id="2911" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2915" class="Symbol">(</a><a id="2916" href="README.Nary.html#2901" class="Bound">m</a> <a id="2918" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2920" class="Symbol">(</a><a id="2921" href="README.Nary.html#2905" class="Bound">p</a> <a id="2923" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="2925" href="README.Nary.html#2903" class="Bound">n</a><a id="2926" class="Symbol">)</a> <a id="2928" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2930" class="Symbol">(</a><a id="2931" href="README.Nary.html#2907" class="Bound">q</a> <a id="2933" href="Data.Nat.Base.html#6561" class="Function Operator">^</a> <a id="2935" class="Symbol">(</a><a id="2936" href="README.Nary.html#2901" class="Bound">m</a> <a id="2938" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2940" href="README.Nary.html#2903" class="Bound">n</a><a id="2941" class="Symbol">)))</a>
              <a id="2959" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2961" class="Symbol">(</a><a id="2962" href="README.Nary.html#2901" class="Bound">m</a> <a id="2964" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2966" class="Number">0</a><a id="2967" class="Symbol">)</a> <a id="2969" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2971" class="Symbol">(</a><a id="2972" href="README.Nary.html#2903" class="Bound">n</a> <a id="2974" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="2976" href="README.Nary.html#2905" class="Bound">p</a><a id="2977" class="Symbol">)</a> <a id="2979" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2981" class="Symbol">(</a><a id="2982" href="README.Nary.html#2907" class="Bound">q</a> <a id="2984" href="Data.Nat.Base.html#6561" class="Function Operator">^</a> <a id="2986" href="README.Nary.html#2901" class="Bound">m</a> <a id="2988" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="2990" href="README.Nary.html#2907" class="Bound">q</a> <a id="2992" href="Data.Nat.Base.html#6561" class="Function Operator">^</a> <a id="2994" href="README.Nary.html#2903" class="Bound">n</a><a id="2995" class="Symbol">)</a> <a id="2997" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2999" class="Number">1</a>
<a id="3001" class="Symbol">_</a> <a id="3003" class="Symbol">=</a> <a id="3005" class="Symbol">λ</a> <a id="3007" href="README.Nary.html#3007" class="Bound">m</a> <a id="3009" href="README.Nary.html#3009" class="Bound">n</a> <a id="3011" href="README.Nary.html#3011" class="Bound">p</a> <a id="3013" href="README.Nary.html#3013" class="Bound">q</a> <a id="3015" class="Symbol">→</a> <a id="3017" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
    <a id="3027" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3031" class="Symbol">(</a><a id="3032" href="README.Nary.html#3007" class="Bound">m</a> <a id="3034" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3036" class="Symbol">(</a><a id="3037" href="README.Nary.html#3011" class="Bound">p</a> <a id="3039" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="3041" href="README.Nary.html#3009" class="Bound">n</a><a id="3042" class="Symbol">)</a> <a id="3044" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3046" class="Symbol">(</a><a id="3047" href="README.Nary.html#3013" class="Bound">q</a> <a id="3049" href="Data.Nat.Base.html#6561" class="Function Operator">^</a> <a id="3051" class="Symbol">(</a><a id="3052" href="README.Nary.html#3007" class="Bound">m</a> <a id="3054" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3056" href="README.Nary.html#3009" class="Bound">n</a><a id="3057" class="Symbol">)))</a> <a id="3061" href="Relation.Binary.Reasoning.Syntax.html#10986" class="Function">≡⟨</a> <a id="3064" href="Data.Nat.Properties.html#14883" class="Function">+-comm</a> <a id="3071" class="Number">1</a> <a id="3073" class="Symbol">_</a> <a id="3075" href="Relation.Binary.Reasoning.Syntax.html#10986" class="Function">⟩</a>
    <a id="3081" href="README.Nary.html#3007" class="Bound">m</a> <a id="3083" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3085" class="Symbol">(</a><a id="3086" href="README.Nary.html#3011" class="Bound">p</a> <a id="3088" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="3090" href="README.Nary.html#3009" class="Bound">n</a><a id="3091" class="Symbol">)</a> <a id="3093" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3095" class="Symbol">(</a><a id="3096" href="README.Nary.html#3013" class="Bound">q</a> <a id="3098" href="Data.Nat.Base.html#6561" class="Function Operator">^</a> <a id="3100" class="Symbol">(</a><a id="3101" href="README.Nary.html#3007" class="Bound">m</a> <a id="3103" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3105" href="README.Nary.html#3009" class="Bound">n</a><a id="3106" class="Symbol">))</a> <a id="3109" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3111" class="Number">1</a>   <a id="3115" href="Relation.Binary.Reasoning.Syntax.html#10986" class="Function">≡⟨</a> <a id="3118" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="3124" class="Number">3</a> <a id="3126" class="Symbol">(λ</a> <a id="3129" href="README.Nary.html#3129" class="Bound">m</a> <a id="3131" href="README.Nary.html#3131" class="Bound">n</a> <a id="3133" href="README.Nary.html#3133" class="Bound">p</a> <a id="3135" class="Symbol">→</a> <a id="3137" href="README.Nary.html#3129" class="Bound">m</a> <a id="3139" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3141" href="README.Nary.html#3131" class="Bound">n</a> <a id="3143" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3145" href="README.Nary.html#3133" class="Bound">p</a> <a id="3147" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3149" class="Number">1</a><a id="3150" class="Symbol">)</a>
                                                 <a id="3201" class="Symbol">(</a><a id="3202" href="Data.Nat.Properties.html#14883" class="Function">+-comm</a> <a id="3209" class="Number">0</a> <a id="3211" href="README.Nary.html#3007" class="Bound">m</a><a id="3212" class="Symbol">)</a>
                                                 <a id="3263" class="Symbol">(</a><a id="3264" href="Data.Nat.Properties.html#21421" class="Function">*-comm</a> <a id="3271" href="README.Nary.html#3011" class="Bound">p</a> <a id="3273" href="README.Nary.html#3009" class="Bound">n</a><a id="3274" class="Symbol">)</a>
                                                 <a id="3325" class="Symbol">(</a><a id="3326" href="Data.Nat.Properties.html#29366" class="Function">^-distribˡ-+-*</a> <a id="3341" href="README.Nary.html#3013" class="Bound">q</a> <a id="3343" href="README.Nary.html#3007" class="Bound">m</a> <a id="3345" href="README.Nary.html#3009" class="Bound">n</a><a id="3346" class="Symbol">)</a>
                                       <a id="3387" href="Relation.Binary.Reasoning.Syntax.html#10986" class="Function">⟩</a>
    <a id="3393" href="README.Nary.html#3007" class="Bound">m</a> <a id="3395" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3397" class="Number">0</a> <a id="3399" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3401" href="README.Nary.html#3009" class="Bound">n</a> <a id="3403" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="3405" href="README.Nary.html#3011" class="Bound">p</a> <a id="3407" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3409" class="Symbol">(</a><a id="3410" href="README.Nary.html#3013" class="Bound">q</a> <a id="3412" href="Data.Nat.Base.html#6561" class="Function Operator">^</a> <a id="3414" href="README.Nary.html#3007" class="Bound">m</a><a id="3415" class="Symbol">)</a> <a id="3417" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="3419" class="Symbol">(</a><a id="3420" href="README.Nary.html#3013" class="Bound">q</a> <a id="3422" href="Data.Nat.Base.html#6561" class="Function Operator">^</a> <a id="3424" href="README.Nary.html#3009" class="Bound">n</a><a id="3425" class="Symbol">)</a> <a id="3427" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3429" class="Number">1</a> <a id="3431" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a> <a id="3433" class="Keyword">where</a> <a id="3439" class="Keyword">open</a> <a id="3444" href="Relation.Binary.PropositionalEquality.Properties.html#6744" class="Module">≡-Reasoning</a>

<a id="3457" class="Comment">-- Partial application of the functional argument is fine: the number of arguments</a>
<a id="3540" class="Comment">-- `congₙ` is going to take is determined by its first argument (a natural number)</a>
<a id="3623" class="Comment">-- and not by the type of the function it works on.</a>

<a id="3676" href="README.Nary.html#3676" class="Function">_</a> <a id="3678" class="Symbol">:</a> <a id="3680" class="Symbol">∀</a> <a id="3682" href="README.Nary.html#3682" class="Bound">m</a> <a id="3684" class="Symbol">→</a> <a id="3686" class="Symbol">(</a><a id="3687" href="README.Nary.html#3682" class="Bound">m</a> <a id="3689" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+_</a><a id="3691" class="Symbol">)</a> <a id="3693" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3695" class="Symbol">((</a><a id="3697" href="README.Nary.html#3682" class="Bound">m</a> <a id="3699" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3701" class="Number">0</a><a id="3702" class="Symbol">)</a> <a id="3704" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+_</a><a id="3706" class="Symbol">)</a>
<a id="3708" class="Symbol">_</a> <a id="3710" class="Symbol">=</a> <a id="3712" class="Symbol">λ</a> <a id="3714" href="README.Nary.html#3714" class="Bound">m</a> <a id="3716" class="Symbol">→</a> <a id="3718" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="3724" class="Number">1</a> <a id="3726" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="3730" class="Symbol">(</a><a id="3731" href="Data.Nat.Properties.html#14883" class="Function">+-comm</a> <a id="3738" class="Number">0</a> <a id="3740" href="README.Nary.html#3714" class="Bound">m</a><a id="3741" class="Symbol">)</a>

<a id="3744" class="Comment">-- We don&#39;t have to work on the function&#39;s first argument either: we can just as</a>
<a id="3825" class="Comment">-- easily use `congₙ` to act on the second one by `flip`ping it. See `holeₙ` for</a>
<a id="3906" class="Comment">-- a generalisation of this idea allowing to target *any* of the function&#39;s</a>
<a id="3982" class="Comment">-- arguments and not just the first or second one.</a>

<a id="4034" href="README.Nary.html#4034" class="Function">_</a> <a id="4036" class="Symbol">:</a> <a id="4038" class="Symbol">∀</a> <a id="4040" href="README.Nary.html#4040" class="Bound">m</a> <a id="4042" class="Symbol">→</a> <a id="4044" class="Symbol">(</a><a id="4045" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">_+</a> <a id="4048" href="README.Nary.html#4040" class="Bound">m</a><a id="4049" class="Symbol">)</a> <a id="4051" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4053" class="Symbol">(</a><a id="4054" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">_+</a> <a id="4057" class="Symbol">(</a><a id="4058" href="README.Nary.html#4040" class="Bound">m</a> <a id="4060" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4062" class="Number">0</a><a id="4063" class="Symbol">))</a>
<a id="4066" class="Symbol">_</a> <a id="4068" class="Symbol">=</a> <a id="4070" class="Symbol">λ</a> <a id="4072" href="README.Nary.html#4072" class="Bound">m</a> <a id="4074" class="Symbol">→</a> <a id="4076" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="4082" class="Number">1</a> <a id="4084" class="Symbol">(</a><a id="4085" href="Function.Base.html#1638" class="Function">flip</a> <a id="4090" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a><a id="4093" class="Symbol">)</a> <a id="4095" class="Symbol">(</a><a id="4096" href="Data.Nat.Properties.html#14883" class="Function">+-comm</a> <a id="4103" class="Number">0</a> <a id="4105" href="README.Nary.html#4072" class="Bound">m</a><a id="4106" class="Symbol">)</a>

<a id="4109" class="Comment">------------------------------------------------------------------------</a>
<a id="4182" class="Comment">-- substₙ : (P : A₁ → ⋯ → Aₙ → Set p) →</a>
<a id="4222" class="Comment">--          a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → P a₁ ⋯ aₙ → P b₁ ⋯ bₙ</a>

<a id="4279" class="Comment">-- We can play the same type of game with subst</a>

<a id="4328" class="Keyword">open</a> <a id="4333" class="Keyword">import</a> <a id="4340" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a> <a id="4357" class="Keyword">using</a> <a id="4363" class="Symbol">(</a><a id="4364" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a><a id="4374" class="Symbol">)</a>

<a id="4377" class="Comment">-- Because we know from the definition `mod-helper` that this equation holds:</a>
<a id="4455" class="Comment">-- mod-helper k m (suc n) (suc j) = mod-helper (suc k) m n j</a>
<a id="4516" class="Comment">-- we should be able to prove the slightly modified statement by transforming</a>
<a id="4594" class="Comment">-- all the `x + 1` into `suc x`. We can do so using `substₙ`.</a>

<a id="4657" href="README.Nary.html#4657" class="Function">_</a> <a id="4659" class="Symbol">:</a> <a id="4661" class="Symbol">∀</a> <a id="4663" href="README.Nary.html#4663" class="Bound">k</a> <a id="4665" href="README.Nary.html#4665" class="Bound">m</a> <a id="4667" href="README.Nary.html#4667" class="Bound">n</a> <a id="4669" href="README.Nary.html#4669" class="Bound">j</a> <a id="4671" class="Symbol">→</a> <a id="4673" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a> <a id="4684" href="README.Nary.html#4663" class="Bound">k</a> <a id="4686" href="README.Nary.html#4665" class="Bound">m</a> <a id="4688" class="Symbol">(</a><a id="4689" href="README.Nary.html#4667" class="Bound">n</a> <a id="4691" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4693" class="Number">1</a><a id="4694" class="Symbol">)</a> <a id="4696" class="Symbol">(</a><a id="4697" href="README.Nary.html#4669" class="Bound">j</a> <a id="4699" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4701" class="Number">1</a><a id="4702" class="Symbol">)</a> <a id="4704" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4706" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a> <a id="4717" class="Symbol">(</a><a id="4718" href="README.Nary.html#4663" class="Bound">k</a> <a id="4720" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4722" class="Number">1</a><a id="4723" class="Symbol">)</a> <a id="4725" href="README.Nary.html#4665" class="Bound">m</a> <a id="4727" href="README.Nary.html#4667" class="Bound">n</a> <a id="4729" href="README.Nary.html#4669" class="Bound">j</a>
<a id="4731" class="Symbol">_</a> <a id="4733" class="Symbol">=</a> <a id="4735" class="Symbol">λ</a> <a id="4737" href="README.Nary.html#4737" class="Bound">k</a> <a id="4739" href="README.Nary.html#4739" class="Bound">m</a> <a id="4741" href="README.Nary.html#4741" class="Bound">n</a> <a id="4743" href="README.Nary.html#4743" class="Bound">j</a> <a id="4745" class="Symbol">→</a>
    <a id="4751" class="Keyword">let</a> <a id="4755" href="README.Nary.html#4755" class="Bound">P</a> <a id="4757" href="README.Nary.html#4757" class="Bound">sk</a> <a id="4760" href="README.Nary.html#4760" class="Bound">sn</a> <a id="4763" href="README.Nary.html#4763" class="Bound">sj</a> <a id="4766" class="Symbol">=</a> <a id="4768" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a> <a id="4779" href="README.Nary.html#4737" class="Bound">k</a> <a id="4781" href="README.Nary.html#4739" class="Bound">m</a> <a id="4783" href="README.Nary.html#4760" class="Bound">sn</a> <a id="4786" href="README.Nary.html#4763" class="Bound">sj</a> <a id="4789" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4791" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a> <a id="4802" href="README.Nary.html#4757" class="Bound">sk</a> <a id="4805" href="README.Nary.html#4739" class="Bound">m</a> <a id="4807" href="README.Nary.html#4741" class="Bound">n</a> <a id="4809" href="README.Nary.html#4743" class="Bound">j</a>
    <a id="4815" class="Keyword">in</a> <a id="4818" href="Relation.Nary.html#3713" class="Function">substₙ</a> <a id="4825" href="README.Nary.html#4755" class="Bound">P</a> <a id="4827" class="Symbol">(</a><a id="4828" href="Data.Nat.Properties.html#14883" class="Function">+-comm</a> <a id="4835" class="Number">1</a> <a id="4837" href="README.Nary.html#4737" class="Bound">k</a><a id="4838" class="Symbol">)</a> <a id="4840" class="Symbol">(</a><a id="4841" href="Data.Nat.Properties.html#14883" class="Function">+-comm</a> <a id="4848" class="Number">1</a> <a id="4850" href="README.Nary.html#4741" class="Bound">n</a><a id="4851" class="Symbol">)</a> <a id="4853" class="Symbol">(</a><a id="4854" href="Data.Nat.Properties.html#14883" class="Function">+-comm</a> <a id="4861" class="Number">1</a> <a id="4863" href="README.Nary.html#4743" class="Bound">j</a><a id="4864" class="Symbol">)</a> <a id="4866" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="4872" class="Comment">-----------------------------------------------------------------------</a>
<a id="4944" class="Comment">-- Generic programs working on n-ary products &amp; functions</a>
<a id="5002" class="Comment">-----------------------------------------------------------------------</a>

<a id="5075" class="Comment">-----------------------------------------------------------------------</a>
<a id="5147" class="Comment">-- curryₙ   : ∀ n → (A₁ × ⋯ × Aₙ → B) → A₁ → ⋯ → Aₙ → B</a>
<a id="5203" class="Comment">-- uncurryₙ : ∀ n → (A₁ → ⋯ → Aₙ → B) → A₁ × ⋯ × Aₙ → B</a>

<a id="5260" class="Comment">-- The first thing we may want to do generically is convert between</a>
<a id="5328" class="Comment">-- curried function types and uncurried ones. We can do this by using:</a>

<a id="5400" class="Comment">-- They both work the same way so we will focus on curryₙ only here.</a>
<a id="5469" class="Comment">-- If we pass to `curryₙ` the arity of its argument then we obtain a</a>
<a id="5538" class="Comment">-- fully curried function.</a>

<a id="curry₁"></a><a id="5566" href="README.Nary.html#5566" class="Function">curry₁</a> <a id="5573" class="Symbol">:</a> <a id="5575" class="Symbol">(</a><a id="5576" href="README.Nary.html#872" class="Generalizable">A</a> <a id="5578" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5580" href="README.Nary.html#886" class="Generalizable">B</a> <a id="5582" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5584" href="README.Nary.html#900" class="Generalizable">C</a> <a id="5586" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5588" href="README.Nary.html#914" class="Generalizable">D</a> <a id="5590" class="Symbol">→</a> <a id="5592" href="README.Nary.html#928" class="Generalizable">E</a><a id="5593" class="Symbol">)</a> <a id="5595" class="Symbol">→</a> <a id="5597" href="README.Nary.html#872" class="Generalizable">A</a> <a id="5599" class="Symbol">→</a> <a id="5601" href="README.Nary.html#886" class="Generalizable">B</a> <a id="5603" class="Symbol">→</a> <a id="5605" href="README.Nary.html#900" class="Generalizable">C</a> <a id="5607" class="Symbol">→</a> <a id="5609" href="README.Nary.html#914" class="Generalizable">D</a> <a id="5611" class="Symbol">→</a> <a id="5613" href="README.Nary.html#928" class="Generalizable">E</a>
<a id="5615" href="README.Nary.html#5566" class="Function">curry₁</a> <a id="5622" class="Symbol">=</a> <a id="5624" href="Data.Product.Nary.NonDependent.html#3691" class="Function">curryₙ</a> <a id="5631" class="Number">4</a>

<a id="5634" class="Comment">-- Note that here we are not flattening arbitrary nestings: products have</a>
<a id="5708" class="Comment">-- to be right nested. Which means that if you have a deeply-nested product</a>
<a id="5784" class="Comment">-- then it won&#39;t be affected by the procedure.</a>

<a id="curry₁′"></a><a id="5832" href="README.Nary.html#5832" class="Function">curry₁′</a> <a id="5840" class="Symbol">:</a> <a id="5842" class="Symbol">(</a><a id="5843" href="README.Nary.html#872" class="Generalizable">A</a> <a id="5845" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5847" class="Symbol">(</a><a id="5848" href="README.Nary.html#886" class="Generalizable">B</a> <a id="5850" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5852" href="README.Nary.html#900" class="Generalizable">C</a><a id="5853" class="Symbol">)</a> <a id="5855" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5857" href="README.Nary.html#914" class="Generalizable">D</a> <a id="5859" class="Symbol">→</a> <a id="5861" href="README.Nary.html#928" class="Generalizable">E</a><a id="5862" class="Symbol">)</a> <a id="5864" class="Symbol">→</a> <a id="5866" href="README.Nary.html#872" class="Generalizable">A</a> <a id="5868" class="Symbol">→</a> <a id="5870" class="Symbol">(</a><a id="5871" href="README.Nary.html#886" class="Generalizable">B</a> <a id="5873" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5875" href="README.Nary.html#900" class="Generalizable">C</a><a id="5876" class="Symbol">)</a> <a id="5878" class="Symbol">→</a> <a id="5880" href="README.Nary.html#914" class="Generalizable">D</a> <a id="5882" class="Symbol">→</a> <a id="5884" href="README.Nary.html#928" class="Generalizable">E</a>
<a id="5886" href="README.Nary.html#5832" class="Function">curry₁′</a> <a id="5894" class="Symbol">=</a> <a id="5896" href="Data.Product.Nary.NonDependent.html#3691" class="Function">curryₙ</a> <a id="5903" class="Number">3</a>

<a id="5906" class="Comment">-- When we are currying a function, we have no obligation to pass its exact</a>
<a id="5982" class="Comment">-- arity as the parameter: we can decide to only curry part of it like so:</a>
<a id="6057" class="Comment">-- Indeed (A₁ × ⋯ × Aₙ → B) can also be seen as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ) → B)</a>

<a id="curry₂"></a><a id="6135" href="README.Nary.html#6135" class="Function">curry₂</a> <a id="6142" class="Symbol">:</a> <a id="6144" class="Symbol">(</a><a id="6145" href="README.Nary.html#872" class="Generalizable">A</a> <a id="6147" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6149" href="README.Nary.html#886" class="Generalizable">B</a> <a id="6151" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6153" href="README.Nary.html#900" class="Generalizable">C</a> <a id="6155" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6157" href="README.Nary.html#914" class="Generalizable">D</a> <a id="6159" class="Symbol">→</a> <a id="6161" href="README.Nary.html#928" class="Generalizable">E</a><a id="6162" class="Symbol">)</a> <a id="6164" class="Symbol">→</a> <a id="6166" href="README.Nary.html#872" class="Generalizable">A</a> <a id="6168" class="Symbol">→</a> <a id="6170" href="README.Nary.html#886" class="Generalizable">B</a> <a id="6172" class="Symbol">→</a> <a id="6174" class="Symbol">(</a><a id="6175" href="README.Nary.html#900" class="Generalizable">C</a> <a id="6177" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6179" href="README.Nary.html#914" class="Generalizable">D</a><a id="6180" class="Symbol">)</a> <a id="6182" class="Symbol">→</a> <a id="6184" href="README.Nary.html#928" class="Generalizable">E</a>
<a id="6186" href="README.Nary.html#6135" class="Function">curry₂</a> <a id="6193" class="Symbol">=</a> <a id="6195" href="Data.Product.Nary.NonDependent.html#3691" class="Function">curryₙ</a> <a id="6202" class="Number">3</a>

<a id="6205" class="Comment">-----------------------------------------------------------------------</a>
<a id="6277" class="Comment">-- projₙ : ∀ n (k : Fin n) → (A₁ × ⋯ × Aₙ) → Aₖ₊₁</a>

<a id="6328" class="Comment">-- Another useful class of functions to manipulate n-ary product is a</a>
<a id="6398" class="Comment">-- generic projection function. Note the (k + 1) in the return index:</a>
<a id="6468" class="Comment">-- Fin counts from 0 up.</a>

<a id="6494" class="Comment">-- It behaves as one expects (Data.Fin&#39;s #_ comes in handy to write down</a>
<a id="6567" class="Comment">-- Fin literals):</a>

<a id="proj₃"></a><a id="6586" href="README.Nary.html#6586" class="Function">proj₃</a> <a id="6592" class="Symbol">:</a> <a id="6594" class="Symbol">(</a><a id="6595" href="README.Nary.html#872" class="Generalizable">A</a> <a id="6597" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6599" href="README.Nary.html#886" class="Generalizable">B</a> <a id="6601" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6603" href="README.Nary.html#900" class="Generalizable">C</a> <a id="6605" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6607" href="README.Nary.html#914" class="Generalizable">D</a> <a id="6609" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6611" href="README.Nary.html#928" class="Generalizable">E</a><a id="6612" class="Symbol">)</a> <a id="6614" class="Symbol">→</a> <a id="6616" href="README.Nary.html#900" class="Generalizable">C</a>
<a id="6618" href="README.Nary.html#6586" class="Function">proj₃</a> <a id="6624" class="Symbol">=</a> <a id="6626" href="Data.Product.Nary.NonDependent.html#6488" class="Function">projₙ</a> <a id="6632" class="Number">5</a> <a id="6634" class="Symbol">(</a><a id="6635" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6637" class="Number">2</a><a id="6638" class="Symbol">)</a>

<a id="6641" class="Comment">-- Of course we can once more project the &quot;tail&quot; of the n-ary product by</a>
<a id="6714" class="Comment">-- passing `projₙ` a natural number which is smaller than the size of the</a>
<a id="6788" class="Comment">-- n-ary product, seeing (A₁ × ⋯ × Aₙ) as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ)).</a>

<a id="proj₃′"></a><a id="6857" href="README.Nary.html#6857" class="Function">proj₃′</a> <a id="6864" class="Symbol">:</a> <a id="6866" class="Symbol">(</a><a id="6867" href="README.Nary.html#872" class="Generalizable">A</a> <a id="6869" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6871" href="README.Nary.html#886" class="Generalizable">B</a> <a id="6873" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6875" href="README.Nary.html#900" class="Generalizable">C</a> <a id="6877" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6879" href="README.Nary.html#914" class="Generalizable">D</a> <a id="6881" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6883" href="README.Nary.html#928" class="Generalizable">E</a><a id="6884" class="Symbol">)</a> <a id="6886" class="Symbol">→</a> <a id="6888" href="README.Nary.html#900" class="Generalizable">C</a> <a id="6890" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6892" href="README.Nary.html#914" class="Generalizable">D</a> <a id="6894" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6896" href="README.Nary.html#928" class="Generalizable">E</a>
<a id="6898" href="README.Nary.html#6857" class="Function">proj₃′</a> <a id="6905" class="Symbol">=</a> <a id="6907" href="Data.Product.Nary.NonDependent.html#6488" class="Function">projₙ</a> <a id="6913" class="Number">3</a> <a id="6915" class="Symbol">(</a><a id="6916" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6918" class="Number">2</a><a id="6919" class="Symbol">)</a>

<a id="6922" class="Comment">-----------------------------------------------------------------------</a>
<a id="6994" class="Comment">-- insertₙ : ∀ n (k : Fin (suc n)) →</a>
<a id="7031" class="Comment">--           B → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B × Aₖ₊₁ × ⋯ Aₙ)</a>

<a id="insert₁"></a><a id="7095" href="README.Nary.html#7095" class="Function">insert₁</a> <a id="7103" class="Symbol">:</a> <a id="7105" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7107" class="Symbol">→</a> <a id="7109" class="Symbol">(</a><a id="7110" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7112" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7114" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7116" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7118" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7120" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7122" href="README.Nary.html#928" class="Generalizable">E</a><a id="7123" class="Symbol">)</a> <a id="7125" class="Symbol">→</a> <a id="7127" class="Symbol">(</a><a id="7128" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7130" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7132" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7134" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7136" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7138" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7140" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7142" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7144" href="README.Nary.html#928" class="Generalizable">E</a><a id="7145" class="Symbol">)</a>
<a id="7147" href="README.Nary.html#7095" class="Function">insert₁</a> <a id="7155" class="Symbol">=</a> <a id="7157" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="7165" class="Number">4</a> <a id="7167" class="Symbol">(</a><a id="7168" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7170" class="Number">2</a><a id="7171" class="Symbol">)</a>

<a id="insert₁′"></a><a id="7174" href="README.Nary.html#7174" class="Function">insert₁′</a> <a id="7183" class="Symbol">:</a> <a id="7185" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7187" class="Symbol">→</a> <a id="7189" class="Symbol">(</a><a id="7190" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7192" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7194" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7196" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7198" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7200" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7202" href="README.Nary.html#928" class="Generalizable">E</a><a id="7203" class="Symbol">)</a> <a id="7205" class="Symbol">→</a> <a id="7207" class="Symbol">(</a><a id="7208" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7210" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7212" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7214" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7216" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7218" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7220" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7222" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7224" href="README.Nary.html#928" class="Generalizable">E</a><a id="7225" class="Symbol">)</a>
<a id="7227" href="README.Nary.html#7174" class="Function">insert₁′</a> <a id="7236" class="Symbol">=</a> <a id="7238" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="7246" class="Number">3</a> <a id="7248" class="Symbol">(</a><a id="7249" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7251" class="Number">2</a><a id="7252" class="Symbol">)</a>

<a id="7255" class="Comment">-- Note that `insertₙ` takes a `Fin (suc n)`. Indeed in an n-ary product</a>
<a id="7328" class="Comment">-- there are (suc n) positions at which one may insert a value. We may</a>
<a id="7399" class="Comment">-- insert at the front or the back of the product:</a>

<a id="insert-front"></a><a id="7451" href="README.Nary.html#7451" class="Function">insert-front</a> <a id="7464" class="Symbol">:</a> <a id="7466" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7468" class="Symbol">→</a> <a id="7470" class="Symbol">(</a><a id="7471" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7473" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7475" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7477" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7479" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7481" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7483" href="README.Nary.html#928" class="Generalizable">E</a><a id="7484" class="Symbol">)</a> <a id="7486" class="Symbol">→</a> <a id="7488" class="Symbol">(</a><a id="7489" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7491" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7493" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7495" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7497" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7499" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7501" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7503" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7505" href="README.Nary.html#928" class="Generalizable">E</a><a id="7506" class="Symbol">)</a>
<a id="7508" href="README.Nary.html#7451" class="Function">insert-front</a> <a id="7521" class="Symbol">=</a> <a id="7523" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="7531" class="Number">4</a> <a id="7533" class="Symbol">(</a><a id="7534" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7536" class="Number">0</a><a id="7537" class="Symbol">)</a>

<a id="insert-back"></a><a id="7540" href="README.Nary.html#7540" class="Function">insert-back</a> <a id="7552" class="Symbol">:</a> <a id="7554" href="README.Nary.html#928" class="Generalizable">E</a> <a id="7556" class="Symbol">→</a> <a id="7558" class="Symbol">(</a><a id="7559" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7561" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7563" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7565" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7567" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7569" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7571" href="README.Nary.html#914" class="Generalizable">D</a><a id="7572" class="Symbol">)</a> <a id="7574" class="Symbol">→</a> <a id="7576" class="Symbol">(</a><a id="7577" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7579" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7581" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7583" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7585" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7587" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7589" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7591" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7593" href="README.Nary.html#928" class="Generalizable">E</a><a id="7594" class="Symbol">)</a>
<a id="7596" href="README.Nary.html#7540" class="Function">insert-back</a> <a id="7608" class="Symbol">=</a> <a id="7610" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="7618" class="Number">4</a> <a id="7620" class="Symbol">(</a><a id="7621" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7623" class="Number">4</a><a id="7624" class="Symbol">)</a>

<a id="7627" class="Comment">-----------------------------------------------------------------------</a>
<a id="7699" class="Comment">-- removeₙ : ∀ n (k : Fin n) → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="7773" class="Comment">-- Dual to `insertₙ`, we may remove a value.</a>

<a id="remove₁"></a><a id="7819" href="README.Nary.html#7819" class="Function">remove₁</a> <a id="7827" class="Symbol">:</a> <a id="7829" class="Symbol">(</a><a id="7830" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7832" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7834" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7836" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7838" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7840" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7842" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7844" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7846" href="README.Nary.html#928" class="Generalizable">E</a><a id="7847" class="Symbol">)</a> <a id="7849" class="Symbol">→</a> <a id="7851" class="Symbol">(</a><a id="7852" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7854" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7856" href="README.Nary.html#886" class="Generalizable">B</a> <a id="7858" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7860" href="README.Nary.html#914" class="Generalizable">D</a> <a id="7862" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7864" href="README.Nary.html#928" class="Generalizable">E</a><a id="7865" class="Symbol">)</a>
<a id="7867" href="README.Nary.html#7819" class="Function">remove₁</a> <a id="7875" class="Symbol">=</a> <a id="7877" href="Data.Product.Nary.NonDependent.html#7678" class="Function">removeₙ</a> <a id="7885" class="Number">5</a> <a id="7887" class="Symbol">(</a><a id="7888" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7890" class="Number">2</a><a id="7891" class="Symbol">)</a>

<a id="7894" class="Comment">-- Inserting at `k` and then removing at `inject₁ k` should yield the identity</a>

<a id="remove-insert"></a><a id="7974" href="README.Nary.html#7974" class="Function">remove-insert</a> <a id="7988" class="Symbol">:</a> <a id="7990" href="README.Nary.html#900" class="Generalizable">C</a> <a id="7992" class="Symbol">→</a> <a id="7994" class="Symbol">(</a><a id="7995" href="README.Nary.html#872" class="Generalizable">A</a> <a id="7997" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7999" href="README.Nary.html#886" class="Generalizable">B</a> <a id="8001" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8003" href="README.Nary.html#914" class="Generalizable">D</a> <a id="8005" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8007" href="README.Nary.html#928" class="Generalizable">E</a><a id="8008" class="Symbol">)</a> <a id="8010" class="Symbol">→</a> <a id="8012" class="Symbol">(</a><a id="8013" href="README.Nary.html#872" class="Generalizable">A</a> <a id="8015" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8017" href="README.Nary.html#886" class="Generalizable">B</a> <a id="8019" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8021" href="README.Nary.html#914" class="Generalizable">D</a> <a id="8023" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8025" href="README.Nary.html#928" class="Generalizable">E</a><a id="8026" class="Symbol">)</a>
<a id="8028" href="README.Nary.html#7974" class="Function">remove-insert</a> <a id="8042" href="README.Nary.html#8042" class="Bound">c</a> <a id="8044" class="Symbol">=</a> <a id="8046" href="Data.Product.Nary.NonDependent.html#7678" class="Function">removeₙ</a> <a id="8054" class="Number">5</a> <a id="8056" class="Symbol">(</a><a id="8057" href="Data.Fin.Base.html#3077" class="Function">inject₁</a> <a id="8065" href="README.Nary.html#8095" class="Function">k</a><a id="8066" class="Symbol">)</a> <a id="8068" href="Function.Base.html#3626" class="Function Operator">∘′</a> <a id="8071" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="8079" class="Number">4</a> <a id="8081" href="README.Nary.html#8095" class="Function">k</a> <a id="8083" href="README.Nary.html#8042" class="Bound">c</a>
    <a id="8089" class="Keyword">where</a> <a id="8095" href="README.Nary.html#8095" class="Function">k</a> <a id="8097" class="Symbol">=</a> <a id="8099" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8101" class="Number">2</a>

<a id="8104" class="Comment">-----------------------------------------------------------------------</a>
<a id="8176" class="Comment">-- updateₙ : ∀ n (k : Fin n) (f : (a : Aₖ₊₁) → B a) →</a>
<a id="8230" class="Comment">--           (p : A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B (projₙ n k p) × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="8308" class="Comment">-- We can not only project out, insert or remove values: we can update them</a>
<a id="8384" class="Comment">-- in place. The type (and value) of the replacement at position k may depend</a>
<a id="8462" class="Comment">-- upon the current value at position k.</a>

<a id="update₁"></a><a id="8504" href="README.Nary.html#8504" class="Function">update₁</a> <a id="8512" class="Symbol">:</a> <a id="8514" class="Symbol">(</a><a id="8515" href="README.Nary.html#8515" class="Bound">p</a> <a id="8517" class="Symbol">:</a> <a id="8519" href="README.Nary.html#872" class="Generalizable">A</a> <a id="8521" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8523" href="README.Nary.html#886" class="Generalizable">B</a> <a id="8525" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8527" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8529" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8531" href="README.Nary.html#900" class="Generalizable">C</a> <a id="8533" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8535" href="README.Nary.html#914" class="Generalizable">D</a><a id="8536" class="Symbol">)</a> <a id="8538" class="Symbol">→</a> <a id="8540" class="Symbol">(</a><a id="8541" href="README.Nary.html#872" class="Generalizable">A</a> <a id="8543" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8545" href="README.Nary.html#886" class="Generalizable">B</a> <a id="8547" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8549" href="Data.Fin.Base.html#1154" class="Datatype">Fin</a> <a id="8553" class="Symbol">_</a> <a id="8555" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8557" href="README.Nary.html#900" class="Generalizable">C</a> <a id="8559" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8561" href="README.Nary.html#914" class="Generalizable">D</a><a id="8562" class="Symbol">)</a>
<a id="8564" href="README.Nary.html#8504" class="Function">update₁</a> <a id="8572" class="Symbol">=</a> <a id="8574" href="Data.Product.Nary.NonDependent.html#9348" class="Function">updateₙ</a> <a id="8582" class="Number">5</a> <a id="8584" class="Symbol">(</a><a id="8585" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8587" class="Number">2</a><a id="8588" class="Symbol">)</a> <a id="8590" href="Data.Fin.Base.html#1847" class="Function">fromℕ</a>

<a id="8597" class="Comment">-- We can explicitly use the primed version of `updateₙ` to make it known to</a>
<a id="8674" class="Comment">-- Agda that the update function is non dependent. This type of information</a>
<a id="8750" class="Comment">-- is useful for inference: the tighter the constraints, the easier it is to</a>
<a id="8827" class="Comment">-- find a solution (if possible).</a>

<a id="update₂"></a><a id="8862" href="README.Nary.html#8862" class="Function">update₂</a> <a id="8870" class="Symbol">:</a> <a id="8872" class="Symbol">(</a><a id="8873" href="README.Nary.html#8873" class="Bound">p</a> <a id="8875" class="Symbol">:</a> <a id="8877" href="README.Nary.html#872" class="Generalizable">A</a> <a id="8879" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8881" href="README.Nary.html#886" class="Generalizable">B</a> <a id="8883" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8885" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8887" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8889" href="README.Nary.html#900" class="Generalizable">C</a> <a id="8891" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8893" href="README.Nary.html#914" class="Generalizable">D</a><a id="8894" class="Symbol">)</a> <a id="8896" class="Symbol">→</a> <a id="8898" class="Symbol">(</a><a id="8899" href="README.Nary.html#872" class="Generalizable">A</a> <a id="8901" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8903" href="README.Nary.html#886" class="Generalizable">B</a> <a id="8905" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8907" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="8912" href="README.Nary.html#914" class="Generalizable">D</a> <a id="8914" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8916" href="README.Nary.html#900" class="Generalizable">C</a> <a id="8918" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8920" href="README.Nary.html#914" class="Generalizable">D</a><a id="8921" class="Symbol">)</a>
<a id="8923" href="README.Nary.html#8862" class="Function">update₂</a> <a id="8931" class="Symbol">=</a> <a id="8933" class="Symbol">λ</a> <a id="8935" href="README.Nary.html#8935" class="Bound">p</a> <a id="8937" class="Symbol">→</a> <a id="8939" href="Data.Product.Nary.NonDependent.html#9694" class="Function">updateₙ′</a> <a id="8948" class="Number">5</a> <a id="8950" class="Symbol">(</a><a id="8951" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8953" class="Number">2</a><a id="8954" class="Symbol">)</a> <a id="8956" class="Symbol">(λ</a> <a id="8959" href="README.Nary.html#8959" class="Bound">n</a> <a id="8961" class="Symbol">→</a> <a id="8963" href="Data.List.Base.html#5358" class="Function">replicate</a> <a id="8973" href="README.Nary.html#8959" class="Bound">n</a> <a id="8975" class="Symbol">(</a><a id="8976" href="Data.Product.Nary.NonDependent.html#6488" class="Function">projₙ</a> <a id="8982" class="Number">5</a> <a id="8984" class="Symbol">(</a><a id="8985" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8987" class="Number">4</a><a id="8988" class="Symbol">)</a> <a id="8990" href="README.Nary.html#8935" class="Bound">p</a><a id="8991" class="Symbol">))</a> <a id="8994" href="README.Nary.html#8935" class="Bound">p</a>

<a id="8997" class="Comment">-----------------------------------------------------------------------</a>
<a id="9069" class="Comment">-- _%=_⊢_ : ∀ n → (C → D) → (A₁ → ⋯ Aₙ → D → B) → A₁ → ⋯ → Aₙ → C → B</a>

<a id="9140" class="Comment">-- Traditional composition (also known as the index update operator `_⊢_`</a>
<a id="9214" class="Comment">-- in `Relation.Unary`) focuses solely on the first argument of an n-ary</a>
<a id="9287" class="Comment">-- function. `_%=_⊢_` on the other hand allows us to touch any one of the</a>
<a id="9361" class="Comment">-- arguments.</a>

<a id="9376" class="Comment">-- In the following example we have a function `f : A → B` and `replicate`</a>
<a id="9451" class="Comment">-- of type `ℕ → B → List B`. We want ̀f` to act on the second argument of</a>
<a id="9525" class="Comment">-- replicate. Which we can do like so.</a>

<a id="compose₁"></a><a id="9565" href="README.Nary.html#9565" class="Function">compose₁</a> <a id="9574" class="Symbol">:</a> <a id="9576" class="Symbol">(</a><a id="9577" href="README.Nary.html#872" class="Generalizable">A</a> <a id="9579" class="Symbol">→</a> <a id="9581" href="README.Nary.html#886" class="Generalizable">B</a><a id="9582" class="Symbol">)</a> <a id="9584" class="Symbol">→</a> <a id="9586" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="9588" class="Symbol">→</a> <a id="9590" href="README.Nary.html#872" class="Generalizable">A</a> <a id="9592" class="Symbol">→</a> <a id="9594" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="9599" href="README.Nary.html#886" class="Generalizable">B</a>
<a id="9601" href="README.Nary.html#9565" class="Function">compose₁</a> <a id="9610" href="README.Nary.html#9610" class="Bound">f</a> <a id="9612" class="Symbol">=</a> <a id="9614" class="Number">1</a> <a id="9616" href="Function.Nary.NonDependent.Base.html#3868" class="Function Operator">%=</a> <a id="9619" href="README.Nary.html#9610" class="Bound">f</a> <a id="9621" href="Function.Nary.NonDependent.Base.html#3868" class="Function Operator">⊢</a> <a id="9623" href="Data.List.Base.html#5358" class="Function">replicate</a>

<a id="9634" class="Comment">-- Here we spell out the equivalent explicit variable-manipulation and</a>
<a id="9705" class="Comment">-- prove the two functions equal.</a>

<a id="compose₁′"></a><a id="9740" href="README.Nary.html#9740" class="Function">compose₁′</a> <a id="9750" class="Symbol">:</a> <a id="9752" class="Symbol">(</a><a id="9753" href="README.Nary.html#872" class="Generalizable">A</a> <a id="9755" class="Symbol">→</a> <a id="9757" href="README.Nary.html#886" class="Generalizable">B</a><a id="9758" class="Symbol">)</a> <a id="9760" class="Symbol">→</a> <a id="9762" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="9764" class="Symbol">→</a> <a id="9766" href="README.Nary.html#872" class="Generalizable">A</a> <a id="9768" class="Symbol">→</a> <a id="9770" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="9775" href="README.Nary.html#886" class="Generalizable">B</a>
<a id="9777" href="README.Nary.html#9740" class="Function">compose₁′</a> <a id="9787" href="README.Nary.html#9787" class="Bound">f</a> <a id="9789" href="README.Nary.html#9789" class="Bound">n</a> <a id="9791" href="README.Nary.html#9791" class="Bound">a</a> <a id="9793" class="Symbol">=</a> <a id="9795" href="Data.List.Base.html#5358" class="Function">replicate</a> <a id="9805" href="README.Nary.html#9789" class="Bound">n</a> <a id="9807" class="Symbol">(</a><a id="9808" href="README.Nary.html#9787" class="Bound">f</a> <a id="9810" href="README.Nary.html#9791" class="Bound">a</a><a id="9811" class="Symbol">)</a>

<a id="compose₁-eq"></a><a id="9814" href="README.Nary.html#9814" class="Function">compose₁-eq</a> <a id="9826" class="Symbol">:</a> <a id="9828" href="README.Nary.html#9565" class="Function">compose₁</a> <a id="9837" class="Symbol">{</a><a id="9838" href="README.Nary.html#850" class="Generalizable">a</a><a id="9839" class="Symbol">}</a> <a id="9841" class="Symbol">{</a><a id="9842" href="README.Nary.html#872" class="Generalizable">A</a><a id="9843" class="Symbol">}</a> <a id="9845" class="Symbol">{</a><a id="9846" href="README.Nary.html#852" class="Generalizable">b</a><a id="9847" class="Symbol">}</a> <a id="9849" class="Symbol">{</a><a id="9850" href="README.Nary.html#886" class="Generalizable">B</a><a id="9851" class="Symbol">}</a> <a id="9853" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="9855" href="README.Nary.html#9740" class="Function">compose₁′</a>
<a id="9865" href="README.Nary.html#9814" class="Function">compose₁-eq</a> <a id="9877" class="Symbol">=</a> <a id="9879" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="9885" class="Comment">-----------------------------------------------------------------------</a>
<a id="9957" class="Comment">-- _∷=_⊢_ : ∀ n → A → (A₁ → ⋯ Aₙ → A → B) → A₁ → ⋯ → Aₙ → B</a>

<a id="10018" class="Comment">-- Partial application usually focuses on the first argument of a function.</a>
<a id="10094" class="Comment">-- We can now partially apply a function in any of its arguments using</a>
<a id="10165" class="Comment">-- `_∷=_⊢_`. Reusing our example involving replicate: we can specialise it</a>
<a id="10240" class="Comment">-- to only output finite lists of `0`:</a>

<a id="apply₁"></a><a id="10280" href="README.Nary.html#10280" class="Function">apply₁</a> <a id="10287" class="Symbol">:</a> <a id="10289" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="10291" class="Symbol">→</a> <a id="10293" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="10298" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="10300" href="README.Nary.html#10280" class="Function">apply₁</a> <a id="10307" class="Symbol">=</a> <a id="10309" class="Number">1</a> <a id="10311" href="Function.Nary.NonDependent.Base.html#4040" class="Function Operator">∷=</a> <a id="10314" class="Number">0</a> <a id="10316" href="Function.Nary.NonDependent.Base.html#4040" class="Function Operator">⊢</a> <a id="10318" href="Data.List.Base.html#5358" class="Function">replicate</a>

<a id="apply₁-eq"></a><a id="10329" href="README.Nary.html#10329" class="Function">apply₁-eq</a> <a id="10339" class="Symbol">:</a> <a id="10341" href="README.Nary.html#10280" class="Function">apply₁</a> <a id="10348" class="Number">3</a> <a id="10350" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10352" class="Number">0</a> <a id="10354" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10356" class="Number">0</a> <a id="10358" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10360" class="Number">0</a> <a id="10362" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10364" class="InductiveConstructor">[]</a>
<a id="10367" href="README.Nary.html#10329" class="Function">apply₁-eq</a> <a id="10377" class="Symbol">=</a> <a id="10379" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="10385" class="Comment">------------------------------------------------------------------------</a>
<a id="10458" class="Comment">-- holeₙ : ∀ n → (A → (A₁ → ⋯ Aₙ → B)) → A₁ → ⋯ → Aₙ → (A → B)</a>

<a id="10522" class="Comment">-- As we have seen earlier, `cong` acts on a function&#39;s first variable.</a>
<a id="10594" class="Comment">-- If we want to access the second one, we can use `flip`. But what about</a>
<a id="10668" class="Comment">-- the fourth one? We typically use an explicit λ-abstraction shuffling</a>
<a id="10740" class="Comment">-- variables. Not anymore.</a>

<a id="10768" class="Comment">-- Reusing mod-helper just because it takes a lot of arguments:</a>

<a id="hole₁"></a><a id="10833" href="README.Nary.html#10833" class="Function">hole₁</a> <a id="10839" class="Symbol">:</a> <a id="10841" class="Symbol">∀</a> <a id="10843" href="README.Nary.html#10843" class="Bound">k</a> <a id="10845" href="README.Nary.html#10845" class="Bound">m</a> <a id="10847" href="README.Nary.html#10847" class="Bound">n</a> <a id="10849" href="README.Nary.html#10849" class="Bound">j</a> <a id="10851" class="Symbol">→</a> <a id="10853" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a> <a id="10864" href="README.Nary.html#10843" class="Bound">k</a> <a id="10866" class="Symbol">(</a><a id="10867" href="README.Nary.html#10845" class="Bound">m</a> <a id="10869" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="10871" class="Number">1</a><a id="10872" class="Symbol">)</a> <a id="10874" href="README.Nary.html#10847" class="Bound">n</a> <a id="10876" href="README.Nary.html#10849" class="Bound">j</a> <a id="10878" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="10880" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a> <a id="10891" href="README.Nary.html#10843" class="Bound">k</a> <a id="10893" class="Symbol">(</a><a id="10894" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="10898" href="README.Nary.html#10845" class="Bound">m</a><a id="10899" class="Symbol">)</a> <a id="10901" href="README.Nary.html#10847" class="Bound">n</a> <a id="10903" href="README.Nary.html#10849" class="Bound">j</a>
<a id="10905" href="README.Nary.html#10833" class="Function">hole₁</a> <a id="10911" class="Symbol">=</a> <a id="10913" class="Symbol">λ</a> <a id="10915" href="README.Nary.html#10915" class="Bound">k</a> <a id="10917" href="README.Nary.html#10917" class="Bound">m</a> <a id="10919" href="README.Nary.html#10919" class="Bound">n</a> <a id="10921" href="README.Nary.html#10921" class="Bound">j</a> <a id="10923" class="Symbol">→</a> <a id="10925" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="10930" class="Symbol">(</a><a id="10931" href="Function.Nary.NonDependent.Base.html#4164" class="Function">holeₙ</a> <a id="10937" class="Number">2</a> <a id="10939" class="Symbol">(</a><a id="10940" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a> <a id="10951" href="README.Nary.html#10915" class="Bound">k</a><a id="10952" class="Symbol">)</a> <a id="10954" href="README.Nary.html#10919" class="Bound">n</a> <a id="10956" href="README.Nary.html#10921" class="Bound">j</a><a id="10957" class="Symbol">)</a> <a id="10959" class="Symbol">(</a><a id="10960" href="Data.Nat.Properties.html#14883" class="Function">+-comm</a> <a id="10967" href="README.Nary.html#10917" class="Bound">m</a> <a id="10969" class="Number">1</a><a id="10970" class="Symbol">)</a>

<a id="10973" class="Comment">-----------------------------------------------------------------------</a>
<a id="11045" class="Comment">-- mapₙ : ∀ n → (B → C) → (A₁ → ⋯ Aₙ → B) → (A₁ → ⋯ → Aₙ → C)</a>

<a id="11108" class="Comment">-- (R →_) gives us the reader monad (and, a fortiori, functor). That is to</a>
<a id="11183" class="Comment">-- say that given a function (A → B) and an (R → A) we can get an (R → B)</a>
<a id="11257" class="Comment">-- This generalises to n-ary functions.</a>

<a id="11298" class="Comment">-- Reusing our `composeₙ` example: instead of applying `f` to the replicated</a>
<a id="11375" class="Comment">-- element, we can map it on the resulting list. Giving us:</a>

<a id="map₁"></a><a id="11436" href="README.Nary.html#11436" class="Function">map₁</a> <a id="11441" class="Symbol">:</a> <a id="11443" class="Symbol">(</a><a id="11444" href="README.Nary.html#872" class="Generalizable">A</a> <a id="11446" class="Symbol">→</a> <a id="11448" href="README.Nary.html#886" class="Generalizable">B</a><a id="11449" class="Symbol">)</a> <a id="11451" class="Symbol">→</a> <a id="11453" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="11455" class="Symbol">→</a> <a id="11457" href="README.Nary.html#872" class="Generalizable">A</a> <a id="11459" class="Symbol">→</a> <a id="11461" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="11466" href="README.Nary.html#886" class="Generalizable">B</a>
<a id="11468" href="README.Nary.html#11436" class="Function">map₁</a> <a id="11473" href="README.Nary.html#11473" class="Bound">f</a> <a id="11475" class="Symbol">=</a> <a id="11477" href="Function.Nary.NonDependent.Base.html#3692" class="Function">mapₙ</a> <a id="11482" class="Number">2</a> <a id="11484" class="Symbol">(</a><a id="11485" href="Data.List.Base.html#1631" class="Function">map</a> <a id="11489" href="README.Nary.html#11473" class="Bound">f</a><a id="11490" class="Symbol">)</a> <a id="11492" href="Data.List.Base.html#5358" class="Function">replicate</a>

<a id="11503" class="Comment">------------------------------------------------------------------------</a>
<a id="11576" class="Comment">-- constₙ : ∀ n → B → A₁ → ⋯ → Aₙ → B</a>

<a id="11615" class="Comment">-- `const` is basically `pure` for the reader monad discussed above. Just</a>
<a id="11689" class="Comment">-- like we can generalise the functorial action corresponding to the reader</a>
<a id="11765" class="Comment">-- functor to n-ary functions, we can do the same for `pure`.</a>

<a id="const₁"></a><a id="11828" href="README.Nary.html#11828" class="Function">const₁</a> <a id="11835" class="Symbol">:</a> <a id="11837" href="README.Nary.html#872" class="Generalizable">A</a> <a id="11839" class="Symbol">→</a> <a id="11841" href="README.Nary.html#886" class="Generalizable">B</a> <a id="11843" class="Symbol">→</a> <a id="11845" href="README.Nary.html#900" class="Generalizable">C</a> <a id="11847" class="Symbol">→</a> <a id="11849" href="README.Nary.html#914" class="Generalizable">D</a> <a id="11851" class="Symbol">→</a> <a id="11853" href="README.Nary.html#928" class="Generalizable">E</a> <a id="11855" class="Symbol">→</a> <a id="11857" href="README.Nary.html#872" class="Generalizable">A</a>
<a id="11859" href="README.Nary.html#11828" class="Function">const₁</a> <a id="11866" class="Symbol">=</a> <a id="11868" href="Function.Nary.NonDependent.Base.html#4546" class="Function">constₙ</a> <a id="11875" class="Number">4</a>

<a id="11878" class="Comment">-- Together with `holeₙ`, this means we can make a constant function out</a>
<a id="11951" class="Comment">-- of any of the arguments. The fourth for instance:</a>

<a id="const₂"></a><a id="12005" href="README.Nary.html#12005" class="Function">const₂</a> <a id="12012" class="Symbol">:</a> <a id="12014" href="README.Nary.html#872" class="Generalizable">A</a> <a id="12016" class="Symbol">→</a> <a id="12018" href="README.Nary.html#886" class="Generalizable">B</a> <a id="12020" class="Symbol">→</a> <a id="12022" href="README.Nary.html#900" class="Generalizable">C</a> <a id="12024" class="Symbol">→</a> <a id="12026" href="README.Nary.html#914" class="Generalizable">D</a> <a id="12028" class="Symbol">→</a> <a id="12030" href="README.Nary.html#928" class="Generalizable">E</a> <a id="12032" class="Symbol">→</a> <a id="12034" href="README.Nary.html#914" class="Generalizable">D</a>
<a id="12036" href="README.Nary.html#12005" class="Function">const₂</a> <a id="12043" class="Symbol">=</a> <a id="12045" href="Function.Nary.NonDependent.Base.html#4164" class="Function">holeₙ</a> <a id="12051" class="Number">3</a> <a id="12053" class="Symbol">(</a><a id="12054" href="Function.Nary.NonDependent.Base.html#4546" class="Function">constₙ</a> <a id="12061" class="Number">4</a><a id="12062" class="Symbol">)</a>

<a id="12065" class="Comment">------------------------------------------------------------------------</a>
<a id="12138" class="Comment">-- Generalised quantifiers</a>
<a id="12165" class="Comment">------------------------------------------------------------------------</a>

<a id="12239" class="Comment">-- As we have seen multiple times already, one of the advantages of working</a>
<a id="12315" class="Comment">-- with non-dependent products is that they can be easily inferred. This is</a>
<a id="12391" class="Comment">-- a prime opportunity to define generic quantifiers.</a>

<a id="12446" class="Comment">-- And because n-ary relations are Set-terminated, there is no ambiguity</a>
<a id="12519" class="Comment">-- where to split between arguments &amp; codomain. As a consequence Agda can</a>
<a id="12593" class="Comment">-- infer even `n`, the number of arguments. We can use notations which are</a>
<a id="12668" class="Comment">-- just like the ones defined in `Relation.Unary`.</a>

<a id="12720" class="Comment">------------------------------------------------------------------------</a>
<a id="12793" class="Comment">-- ∃⟨_⟩ : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="12833" class="Comment">-- ∃⟨ P ⟩ = ∃ λ a₁ → ⋯ → ∃ λ aₙ → P a₁ ⋯ aₙ</a>

<a id="12878" class="Comment">-- Returning to our favourite function taking a lot of arguments: we can</a>
<a id="12951" class="Comment">-- find a set of input for which it evaluates to 666</a>

<a id="exist₁"></a><a id="13005" href="README.Nary.html#13005" class="Function">exist₁</a> <a id="13012" class="Symbol">:</a> <a id="13014" href="Relation.Nary.html#2380" class="Function Operator">∃⟨</a> <a id="13017" class="Symbol">(λ</a> <a id="13020" href="README.Nary.html#13020" class="Bound">k</a> <a id="13022" href="README.Nary.html#13022" class="Bound">m</a> <a id="13024" href="README.Nary.html#13024" class="Bound">n</a> <a id="13026" href="README.Nary.html#13026" class="Bound">j</a> <a id="13028" class="Symbol">→</a> <a id="13030" href="Agda.Builtin.Nat.html#3040" class="Primitive">mod-helper</a> <a id="13041" href="README.Nary.html#13020" class="Bound">k</a> <a id="13043" href="README.Nary.html#13022" class="Bound">m</a> <a id="13045" href="README.Nary.html#13024" class="Bound">n</a> <a id="13047" href="README.Nary.html#13026" class="Bound">j</a> <a id="13049" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="13051" class="Number">666</a><a id="13054" class="Symbol">)</a> <a id="13056" href="Relation.Nary.html#2380" class="Function Operator">⟩</a>
<a id="13058" href="README.Nary.html#13005" class="Function">exist₁</a> <a id="13065" class="Symbol">=</a> <a id="13067" class="Number">19</a> <a id="13070" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13072" class="Number">793</a> <a id="13076" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13078" class="Number">3059</a> <a id="13083" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13085" class="Number">10</a> <a id="13088" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13090" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="13096" class="Comment">------------------------------------------------------------------------</a>
<a id="13169" class="Comment">-- ∀[_] : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13209" class="Comment">-- ∀[_] P = ∀ {a₁} → ⋯ → ∀ {aₙ} → P a₁ ⋯ aₙ</a>

<a id="all₁"></a><a id="13254" href="README.Nary.html#13254" class="Function">all₁</a> <a id="13259" class="Symbol">:</a> <a id="13261" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="13264" class="Symbol">(λ</a> <a id="13267" class="Symbol">(</a><a id="13268" href="README.Nary.html#13268" class="Bound">a₁</a> <a id="13271" href="README.Nary.html#13271" class="Bound">a₂</a> <a id="13274" class="Symbol">:</a> <a id="13276" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="13277" class="Symbol">)</a> <a id="13279" class="Symbol">→</a> <a id="13281" href="Relation.Nullary.Decidable.Core.html#1485" class="Record">Dec</a> <a id="13285" class="Symbol">(</a><a id="13286" href="README.Nary.html#13268" class="Bound">a₁</a> <a id="13289" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="13291" href="README.Nary.html#13271" class="Bound">a₂</a><a id="13293" class="Symbol">))</a> <a id="13296" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="13298" href="README.Nary.html#13254" class="Function">all₁</a> <a id="13303" class="Symbol">{</a><a id="13304" href="README.Nary.html#13304" class="Bound">a₁</a><a id="13306" class="Symbol">}</a> <a id="13308" class="Symbol">{</a><a id="13309" href="README.Nary.html#13309" class="Bound">a₂</a><a id="13311" class="Symbol">}</a> <a id="13313" class="Symbol">=</a> <a id="13315" href="README.Nary.html#13304" class="Bound">a₁</a> <a id="13318" href="Data.Nat.Properties.html#3311" class="Function Operator">≟</a> <a id="13320" href="README.Nary.html#13309" class="Bound">a₂</a>

<a id="13324" class="Comment">------------------------------------------------------------------------</a>
<a id="13397" class="Comment">-- Π : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13434" class="Comment">-- Π P = ∀ a₁ → ⋯ → ∀ aₙ → P a₁ ⋯ aₙ</a>

<a id="all₂"></a><a id="13472" href="README.Nary.html#13472" class="Function">all₂</a> <a id="13477" class="Symbol">:</a> <a id="13479" href="Relation.Nary.html#2519" class="Function Operator">Π[</a> <a id="13482" class="Symbol">(λ</a> <a id="13485" class="Symbol">(</a><a id="13486" href="README.Nary.html#13486" class="Bound">a₁</a> <a id="13489" href="README.Nary.html#13489" class="Bound">a₂</a> <a id="13492" class="Symbol">:</a> <a id="13494" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="13495" class="Symbol">)</a> <a id="13497" class="Symbol">→</a> <a id="13499" href="Relation.Nullary.Decidable.Core.html#1485" class="Record">Dec</a> <a id="13503" class="Symbol">(</a><a id="13504" href="README.Nary.html#13486" class="Bound">a₁</a> <a id="13507" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="13509" href="README.Nary.html#13489" class="Bound">a₂</a><a id="13511" class="Symbol">))</a> <a id="13514" href="Relation.Nary.html#2519" class="Function Operator">]</a>
<a id="13516" href="README.Nary.html#13472" class="Function">all₂</a> <a id="13521" class="Symbol">=</a> <a id="13523" href="Data.Nat.Properties.html#3311" class="Function Operator">_≟_</a>

<a id="13528" class="Comment">------------------------------------------------------------------------</a>
<a id="13601" class="Comment">-- _⇒_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13680" class="Comment">-- P ⇒ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ → Q a₁ ⋯ aₙ</a>

<a id="antisym"></a><a id="13732" href="README.Nary.html#13732" class="Function">antisym</a> <a id="13740" class="Symbol">:</a> <a id="13742" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="13745" href="Data.Nat.Base.html#1691" class="Datatype Operator">_≤_</a> <a id="13749" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="13751" href="Data.Nat.Base.html#2259" class="Function Operator">_≥_</a> <a id="13755" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="13757" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a> <a id="13761" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="13763" href="README.Nary.html#13732" class="Function">antisym</a> <a id="13771" class="Symbol">=</a> <a id="13773" href="Data.Nat.Properties.html#5292" class="Function">≤-antisym</a>

<a id="13784" class="Comment">------------------------------------------------------------------------</a>
<a id="13857" class="Comment">-- _∪_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13936" class="Comment">-- P ∪ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ ⊎ Q a₁ ⋯ aₙ</a>

<a id="≤-&gt;-connex"></a><a id="13988" href="README.Nary.html#13988" class="Function">≤-&gt;-connex</a> <a id="13999" class="Symbol">:</a> <a id="14001" href="Relation.Nary.html#2519" class="Function Operator">Π[</a> <a id="14004" href="Data.Nat.Base.html#1691" class="Datatype Operator">_≤_</a> <a id="14008" href="Relation.Nary.html#5345" class="Function Operator">∪</a> <a id="14010" href="Data.Nat.Base.html#2289" class="Function Operator">_&gt;_</a> <a id="14014" href="Relation.Nary.html#2519" class="Function Operator">]</a>
<a id="14016" href="README.Nary.html#13988" class="Function">≤-&gt;-connex</a> <a id="14027" href="README.Nary.html#14027" class="Bound">m</a> <a id="14029" href="README.Nary.html#14029" class="Bound">n</a> <a id="14031" class="Keyword">with</a> <a id="14036" href="Data.Nat.Properties.html#10543" class="Function">&lt;-cmp</a> <a id="14042" href="README.Nary.html#14027" class="Bound">m</a> <a id="14044" href="README.Nary.html#14029" class="Bound">n</a>
<a id="14046" class="Symbol">...</a> <a id="14050" class="Symbol">|</a> <a id="14052" href="Relation.Binary.Definitions.html#3104" class="InductiveConstructor">tri&lt;</a> <a id="14057" href="README.Nary.html#14057" class="Bound">a</a> <a id="14059" href="README.Nary.html#14059" class="Bound">¬b</a> <a id="14062" href="README.Nary.html#14062" class="Bound">¬c</a> <a id="14065" class="Symbol">=</a> <a id="14067" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="14072" class="Symbol">(</a><a id="14073" href="Data.Nat.Properties.html#8416" class="Function">&lt;⇒≤</a> <a id="14077" href="README.Nary.html#14057" class="Bound">a</a><a id="14078" class="Symbol">)</a>
<a id="14080" class="Symbol">...</a> <a id="14084" class="Symbol">|</a> <a id="14086" href="Relation.Binary.Definitions.html#3158" class="InductiveConstructor">tri≈</a> <a id="14091" href="README.Nary.html#14091" class="Bound">¬a</a> <a id="14094" href="README.Nary.html#14094" class="Bound">b</a> <a id="14096" href="README.Nary.html#14096" class="Bound">¬c</a> <a id="14099" class="Symbol">=</a> <a id="14101" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="14106" class="Symbol">(</a><a id="14107" href="Data.Nat.Properties.html#5136" class="Function">≤-reflexive</a> <a id="14119" href="README.Nary.html#14094" class="Bound">b</a><a id="14120" class="Symbol">)</a>
<a id="14122" class="Symbol">...</a> <a id="14126" class="Symbol">|</a> <a id="14128" href="Relation.Binary.Definitions.html#3212" class="InductiveConstructor">tri&gt;</a> <a id="14133" href="README.Nary.html#14133" class="Bound">¬a</a> <a id="14136" href="README.Nary.html#14136" class="Bound">¬b</a> <a id="14139" href="README.Nary.html#14139" class="Bound">c</a> <a id="14141" class="Symbol">=</a> <a id="14143" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="14148" href="README.Nary.html#14139" class="Bound">c</a>

<a id="14151" class="Comment">------------------------------------------------------------------------</a>
<a id="14224" class="Comment">-- _∩_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14303" class="Comment">-- P ∩ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ × Q a₁ ⋯ aₙ</a>

<a id="&lt;-inversion"></a><a id="14355" href="README.Nary.html#14355" class="Function">&lt;-inversion</a> <a id="14367" class="Symbol">:</a> <a id="14369" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="14372" href="Data.Nat.Base.html#1801" class="Function Operator">_&lt;_</a> <a id="14376" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="14378" href="Data.Nat.Base.html#1691" class="Datatype Operator">_≤_</a> <a id="14382" href="Relation.Nary.html#5206" class="Function Operator">∩</a> <a id="14384" href="Relation.Binary.PropositionalEquality.Core.html#858" class="Function Operator">_≢_</a> <a id="14388" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="14390" href="README.Nary.html#14355" class="Function">&lt;-inversion</a> <a id="14402" href="README.Nary.html#14402" class="Bound">m&lt;n</a> <a id="14406" class="Symbol">=</a> <a id="14408" href="Data.Nat.Properties.html#8416" class="Function">&lt;⇒≤</a> <a id="14412" href="README.Nary.html#14402" class="Bound">m&lt;n</a> <a id="14416" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14418" href="Data.Nat.Properties.html#8499" class="Function">&lt;⇒≢</a> <a id="14422" href="README.Nary.html#14402" class="Bound">m&lt;n</a>

<a id="14427" class="Comment">------------------------------------------------------------------------</a>
<a id="14500" class="Comment">-- ∁ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14553" class="Comment">-- ∁ P = λ a₁ → ⋯ → λ aₙ → ¬ (P a₁ ⋯ aₙ)</a>

<a id="m&lt;n⇒m≱n"></a><a id="14595" href="README.Nary.html#14595" class="Function">m&lt;n⇒m≱n</a> <a id="14603" class="Symbol">:</a> <a id="14605" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="14608" href="Data.Nat.Base.html#2289" class="Function Operator">_&gt;_</a> <a id="14612" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="14614" href="Relation.Nary.html#5468" class="Function">∁</a> <a id="14616" href="Data.Nat.Base.html#1691" class="Datatype Operator">_≤_</a> <a id="14620" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="14622" href="README.Nary.html#14595" class="Function">m&lt;n⇒m≱n</a> <a id="14630" href="README.Nary.html#14630" class="Bound">m&gt;n</a> <a id="14634" href="README.Nary.html#14634" class="Bound">m≤n</a> <a id="14638" class="Symbol">=</a> <a id="14640" href="Data.Nat.Properties.html#8631" class="Function">&lt;⇒≱</a> <a id="14644" href="README.Nary.html#14630" class="Bound">m&gt;n</a> <a id="14648" href="README.Nary.html#14634" class="Bound">m≤n</a>
</pre></body></html>