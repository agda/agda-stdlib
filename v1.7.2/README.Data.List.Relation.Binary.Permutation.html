<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.List.Relation.Binary.Permutation</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Documentation for permutation over `List`s</a>
<a id="152" class="Comment">------------------------------------------------------------------------</a>

<a id="226" class="Keyword">module</a> <a id="233" href="README.Data.List.Relation.Binary.Permutation.html" class="Module">README.Data.List.Relation.Binary.Permutation</a> <a id="278" class="Keyword">where</a>

<a id="285" class="Keyword">open</a> <a id="290" class="Keyword">import</a> <a id="297" href="Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="316" class="Keyword">using</a> <a id="322" class="Symbol">(</a><a id="323" href="Algebra.Structures.html#3101" class="Record">IsCommutativeMonoid</a><a id="342" class="Symbol">)</a>
<a id="344" class="Keyword">open</a> <a id="349" class="Keyword">import</a> <a id="356" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="371" class="Keyword">open</a> <a id="376" class="Keyword">import</a> <a id="383" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="392" class="Keyword">using</a> <a id="398" class="Symbol">(</a><a id="399" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="400" class="Symbol">;</a> <a id="402" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="405" class="Symbol">)</a>
<a id="407" class="Keyword">open</a> <a id="412" class="Keyword">import</a> <a id="419" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="459" class="Keyword">using</a> <a id="465" class="Symbol">(</a><a id="466" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="469" class="Symbol">;</a> <a id="471" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="475" class="Symbol">;</a> <a id="477" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a><a id="480" class="Symbol">;</a> <a id="482" href="Relation.Binary.PropositionalEquality.Core.html#1139" class="Function">cong</a><a id="486" class="Symbol">;</a> <a id="488" href="Relation.Binary.PropositionalEquality.Properties.html#3981" class="Function">setoid</a><a id="494" class="Symbol">)</a>

<a id="497" class="Comment">------------------------------------------------------------------------</a>
<a id="570" class="Comment">-- Permutations</a>

<a id="587" class="Comment">-- As an alternative to pointwise equality you might consider two lists</a>
<a id="659" class="Comment">-- to be equal if they contain the same elements regardless of the order</a>
<a id="732" class="Comment">-- of the elements. This is known as either &quot;set equality&quot; or a</a>
<a id="796" class="Comment">-- &quot;permutation&quot;.</a>

<a id="815" class="Comment">-- The easiest-to-use formalisation of this relation is found in the</a>
<a id="884" class="Comment">-- module:</a>

<a id="896" class="Keyword">open</a> <a id="901" class="Keyword">import</a> <a id="908" href="Data.List.Relation.Binary.Permutation.Propositional.html" class="Module">Data.List.Relation.Binary.Permutation.Propositional</a>

<a id="961" class="Comment">-- The permutation relation is written as `_↭_` and has four</a>
<a id="1022" class="Comment">-- constructors. The first `refl` says that a list is always</a>
<a id="1083" class="Comment">-- a permutation of itself, the second `prep` says that if the</a>
<a id="1146" class="Comment">-- heads of the lists are the same they can be skipped, the third</a>
<a id="1212" class="Comment">-- `swap` says that the first two elements of the lists can be</a>
<a id="1275" class="Comment">-- swapped and the fourth `trans` says that permutation proofs</a>
<a id="1338" class="Comment">-- can be chained transitively.</a>

<a id="1371" class="Comment">-- For example a proof that two lists are a permutation of one</a>
<a id="1434" class="Comment">-- another can be written as follows:</a>

<a id="lem₁"></a><a id="1473" href="README.Data.List.Relation.Binary.Permutation.html#1473" class="Function">lem₁</a> <a id="1478" class="Symbol">:</a> <a id="1480" class="Number">1</a> <a id="1482" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1484" class="Number">2</a> <a id="1486" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1488" class="Number">3</a> <a id="1490" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1492" class="InductiveConstructor">[]</a> <a id="1495" href="Data.List.Relation.Binary.Permutation.Propositional.html#1050" class="Datatype Operator">↭</a> <a id="1497" class="Number">3</a> <a id="1499" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1501" class="Number">1</a> <a id="1503" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1505" class="Number">2</a> <a id="1507" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1509" class="InductiveConstructor">[]</a>
<a id="1512" href="README.Data.List.Relation.Binary.Permutation.html#1473" class="Function">lem₁</a> <a id="1517" class="Symbol">=</a> <a id="1519" href="Data.List.Relation.Binary.Permutation.Propositional.html#1225" class="InductiveConstructor">trans</a> <a id="1525" class="Symbol">(</a><a id="1526" href="Data.List.Relation.Binary.Permutation.Propositional.html#1113" class="InductiveConstructor">prep</a> <a id="1531" class="Number">1</a> <a id="1533" class="Symbol">(</a><a id="1534" href="Data.List.Relation.Binary.Permutation.Propositional.html#1165" class="InductiveConstructor">swap</a> <a id="1539" class="Number">2</a> <a id="1541" class="Number">3</a> <a id="1543" href="Data.List.Relation.Binary.Permutation.Propositional.html#1079" class="InductiveConstructor">refl</a><a id="1547" class="Symbol">))</a> <a id="1550" class="Symbol">(</a><a id="1551" href="Data.List.Relation.Binary.Permutation.Propositional.html#1165" class="InductiveConstructor">swap</a> <a id="1556" class="Number">1</a> <a id="1558" class="Number">3</a> <a id="1560" href="Data.List.Relation.Binary.Permutation.Propositional.html#1079" class="InductiveConstructor">refl</a><a id="1564" class="Symbol">)</a>

<a id="1567" class="Comment">-- In practice it is difficult to parse the constructors in the</a>
<a id="1631" class="Comment">-- proof above and hence understand why it holds. The</a>
<a id="1685" class="Comment">-- `PermutationReasoning` module can be used to write this proof</a>
<a id="1750" class="Comment">-- in a much more readable form:</a>

<a id="1784" class="Keyword">open</a> <a id="1789" href="Data.List.Relation.Binary.Permutation.Propositional.html#2249" class="Module">PermutationReasoning</a>

<a id="lem₂"></a><a id="1811" href="README.Data.List.Relation.Binary.Permutation.html#1811" class="Function">lem₂</a> <a id="1816" class="Symbol">:</a> <a id="1818" class="Number">1</a> <a id="1820" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1822" class="Number">2</a> <a id="1824" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1826" class="Number">3</a> <a id="1828" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1830" class="InductiveConstructor">[]</a> <a id="1833" href="Data.List.Relation.Binary.Permutation.Propositional.html#1050" class="Datatype Operator">↭</a> <a id="1835" class="Number">3</a> <a id="1837" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1839" class="Number">1</a> <a id="1841" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1843" class="Number">2</a> <a id="1845" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1847" class="InductiveConstructor">[]</a>
<a id="1850" href="README.Data.List.Relation.Binary.Permutation.html#1811" class="Function">lem₂</a> <a id="1855" class="Symbol">=</a> <a id="1857" href="Relation.Binary.Reasoning.Base.Single.html#1925" class="Function Operator">begin</a>
  <a id="1865" class="Number">1</a> <a id="1867" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1869" class="Number">2</a> <a id="1871" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1873" class="Number">3</a> <a id="1875" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1877" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>  <a id="1881" href="Data.List.Relation.Binary.Permutation.Propositional.html#2442" class="Function">↭⟨</a> <a id="1884" href="Data.List.Relation.Binary.Permutation.Propositional.html#1113" class="InductiveConstructor">prep</a> <a id="1889" class="Number">1</a> <a id="1891" class="Symbol">(</a><a id="1892" href="Data.List.Relation.Binary.Permutation.Propositional.html#1165" class="InductiveConstructor">swap</a> <a id="1897" class="Number">2</a> <a id="1899" class="Number">3</a> <a id="1901" href="Data.List.Relation.Binary.Permutation.Propositional.html#1079" class="InductiveConstructor">refl</a><a id="1905" class="Symbol">)</a> <a id="1907" href="Data.List.Relation.Binary.Permutation.Propositional.html#2442" class="Function">⟩</a>
  <a id="1911" class="Number">1</a> <a id="1913" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1915" class="Number">3</a> <a id="1917" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1919" class="Number">2</a> <a id="1921" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1923" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>  <a id="1927" href="Data.List.Relation.Binary.Permutation.Propositional.html#2442" class="Function">↭⟨</a> <a id="1930" href="Data.List.Relation.Binary.Permutation.Propositional.html#1165" class="InductiveConstructor">swap</a> <a id="1935" class="Number">1</a> <a id="1937" class="Number">3</a> <a id="1939" href="Data.List.Relation.Binary.Permutation.Propositional.html#1079" class="InductiveConstructor">refl</a> <a id="1944" href="Data.List.Relation.Binary.Permutation.Propositional.html#2442" class="Function">⟩</a>
  <a id="1948" class="Number">3</a> <a id="1950" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1952" class="Number">1</a> <a id="1954" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1956" class="Number">2</a> <a id="1958" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1960" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>  <a id="1964" href="Relation.Binary.Reasoning.Base.Single.html#2564" class="Function Operator">∎</a>

<a id="1967" class="Comment">-- As might be expected, properties of the permutation relation may be</a>
<a id="2038" class="Comment">-- found in:</a>

<a id="2052" class="Keyword">open</a> <a id="2057" class="Keyword">import</a> <a id="2064" href="Data.List.Relation.Binary.Permutation.Propositional.Properties.html" class="Module">Data.List.Relation.Binary.Permutation.Propositional.Properties</a>
  <a id="2129" class="Keyword">using</a> <a id="2135" class="Symbol">(</a><a id="2136" href="Data.List.Relation.Binary.Permutation.Propositional.Properties.html#3629" class="Function">map⁺</a><a id="2140" class="Symbol">;</a> <a id="2142" href="Data.List.Relation.Binary.Permutation.Propositional.Properties.html#10292" class="Function">++-isCommutativeMonoid</a><a id="2164" class="Symbol">)</a>

<a id="lem₃"></a><a id="2167" href="README.Data.List.Relation.Binary.Permutation.html#2167" class="Function">lem₃</a> <a id="2172" class="Symbol">:</a> <a id="2174" class="Symbol">∀</a> <a id="2176" class="Symbol">(</a><a id="2177" href="README.Data.List.Relation.Binary.Permutation.html#2177" class="Bound">f</a> <a id="2179" class="Symbol">:</a> <a id="2181" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2183" class="Symbol">→</a> <a id="2185" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2186" class="Symbol">)</a> <a id="2188" class="Symbol">{</a><a id="2189" href="README.Data.List.Relation.Binary.Permutation.html#2189" class="Bound">xs</a> <a id="2192" href="README.Data.List.Relation.Binary.Permutation.html#2192" class="Bound">ys</a> <a id="2195" class="Symbol">:</a> <a id="2197" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="2202" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2203" class="Symbol">}</a> <a id="2205" class="Symbol">→</a> <a id="2207" href="README.Data.List.Relation.Binary.Permutation.html#2189" class="Bound">xs</a> <a id="2210" href="Data.List.Relation.Binary.Permutation.Propositional.html#1050" class="Datatype Operator">↭</a> <a id="2212" href="README.Data.List.Relation.Binary.Permutation.html#2192" class="Bound">ys</a> <a id="2215" class="Symbol">→</a> <a id="2217" href="Data.List.Base.html#1553" class="Function">map</a> <a id="2221" href="README.Data.List.Relation.Binary.Permutation.html#2177" class="Bound">f</a> <a id="2223" href="README.Data.List.Relation.Binary.Permutation.html#2189" class="Bound">xs</a> <a id="2226" href="Data.List.Relation.Binary.Permutation.Propositional.html#1050" class="Datatype Operator">↭</a> <a id="2228" href="Data.List.Base.html#1553" class="Function">map</a> <a id="2232" href="README.Data.List.Relation.Binary.Permutation.html#2177" class="Bound">f</a> <a id="2234" href="README.Data.List.Relation.Binary.Permutation.html#2192" class="Bound">ys</a>
<a id="2237" href="README.Data.List.Relation.Binary.Permutation.html#2167" class="Function">lem₃</a> <a id="2242" class="Symbol">=</a> <a id="2244" href="Data.List.Relation.Binary.Permutation.Propositional.Properties.html#3629" class="Function">map⁺</a>

<a id="lem₄"></a><a id="2250" href="README.Data.List.Relation.Binary.Permutation.html#2250" class="Function">lem₄</a> <a id="2255" class="Symbol">:</a> <a id="2257" href="Algebra.Structures.html#3101" class="Record">IsCommutativeMonoid</a> <a id="2277" class="Symbol">{</a><a id="2278" class="Argument">A</a> <a id="2280" class="Symbol">=</a> <a id="2282" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="2287" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2288" class="Symbol">}</a> <a id="2290" href="Data.List.Relation.Binary.Permutation.Propositional.html#1050" class="Datatype Operator">_↭_</a> <a id="2294" href="Data.List.Base.html#1819" class="Function Operator">_++_</a> <a id="2299" class="InductiveConstructor">[]</a>
<a id="2302" href="README.Data.List.Relation.Binary.Permutation.html#2250" class="Function">lem₄</a> <a id="2307" class="Symbol">=</a> <a id="2309" href="Data.List.Relation.Binary.Permutation.Propositional.Properties.html#10292" class="Function">++-isCommutativeMonoid</a>

<a id="2333" class="Comment">-- Alternatively permutations using non-propositional equality can be</a>
<a id="2403" class="Comment">-- found in:</a>

<a id="2417" class="Keyword">import</a> <a id="2424" href="Data.List.Relation.Binary.Permutation.Setoid.html" class="Module">Data.List.Relation.Binary.Permutation.Setoid</a>
</pre></body></html>