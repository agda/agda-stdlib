<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.List.Relation.Binary.Equality</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Documentation for pointwise equality over `List`s</a>
<a id="159" class="Comment">------------------------------------------------------------------------</a>

<a id="233" class="Symbol">{-#</a> <a id="237" class="Keyword">OPTIONS</a> <a id="245" class="Pragma">--warning</a> <a id="255" class="Pragma">noMissingDefinitions</a> <a id="276" class="Symbol">#-}</a>

<a id="281" class="Keyword">module</a> <a id="288" href="README.Data.List.Relation.Binary.Equality.html" class="Module">README.Data.List.Relation.Binary.Equality</a> <a id="330" class="Keyword">where</a>

<a id="337" class="Keyword">open</a> <a id="342" class="Keyword">import</a> <a id="349" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="358" class="Keyword">using</a> <a id="364" class="Symbol">(</a><a id="365" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="366" class="Symbol">;</a> <a id="368" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="371" class="Symbol">;</a> <a id="373" href="Data.Nat.Base.html#1640" class="Function Operator">_&lt;_</a><a id="376" class="Symbol">;</a> <a id="378" href="Data.Nat.Base.html#1595" class="InductiveConstructor">s≤s</a><a id="381" class="Symbol">;</a> <a id="383" href="Data.Nat.Base.html#1553" class="InductiveConstructor">z≤n</a><a id="386" class="Symbol">;</a> <a id="388" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="391" class="Symbol">;</a> <a id="393" href="Data.Nat.Base.html#2869" class="Primitive Operator">_∸_</a><a id="396" class="Symbol">;</a> <a id="398" href="Data.Nat.Base.html#1530" class="Datatype Operator">_≤_</a><a id="401" class="Symbol">)</a>
<a id="403" class="Keyword">open</a> <a id="408" class="Keyword">import</a> <a id="415" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="435" class="Symbol">as</a> <a id="438" class="Module">NatProp</a>
<a id="446" class="Keyword">open</a> <a id="451" class="Keyword">import</a> <a id="458" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="473" class="Keyword">open</a> <a id="478" class="Keyword">import</a> <a id="485" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="525" class="Keyword">using</a> <a id="531" class="Symbol">(</a><a id="532" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="535" class="Symbol">;</a> <a id="537" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="541" class="Symbol">;</a> <a id="543" href="Relation.Binary.PropositionalEquality.Core.html#1727" class="Function">sym</a><a id="546" class="Symbol">;</a> <a id="548" href="Relation.Binary.PropositionalEquality.Core.html#1173" class="Function">cong</a><a id="552" class="Symbol">;</a> <a id="554" href="Relation.Binary.PropositionalEquality.Properties.html#3972" class="Function">setoid</a><a id="560" class="Symbol">)</a>

<a id="563" class="Comment">------------------------------------------------------------------------</a>
<a id="636" class="Comment">-- Pointwise equality</a>

<a id="659" class="Comment">-- There are many different options for what it means for two</a>
<a id="721" class="Comment">-- different lists of type `List A` to be &quot;equal&quot;. Here we will</a>
<a id="785" class="Comment">-- consider &quot;pointwise&quot; equality that requires the lists to be the</a>
<a id="852" class="Comment">-- same length and every pair of elements to be &quot;equal&quot;.</a>

<a id="910" class="Comment">-- The most basic option is simply to use propositional equality</a>
<a id="975" class="Comment">-- `_≡_` over lists:</a>

<a id="997" class="Keyword">open</a> <a id="1002" class="Keyword">import</a> <a id="1009" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="1049" class="Keyword">using</a> <a id="1055" class="Symbol">(</a><a id="1056" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1059" class="Symbol">;</a> <a id="1061" href="Relation.Binary.PropositionalEquality.Core.html#1727" class="Function">sym</a><a id="1064" class="Symbol">;</a> <a id="1066" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1070" class="Symbol">)</a>

<a id="lem₁"></a><a id="1073" href="README.Data.List.Relation.Binary.Equality.html#1073" class="Function">lem₁</a> <a id="1078" class="Symbol">:</a> <a id="1080" class="Number">1</a> <a id="1082" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1084" class="Number">2</a> <a id="1086" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1088" class="Number">3</a> <a id="1090" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1092" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="1095" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1097" class="Number">1</a> <a id="1099" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1101" class="Number">2</a> <a id="1103" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1105" class="Number">3</a> <a id="1107" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1109" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
<a id="1112" href="README.Data.List.Relation.Binary.Equality.html#1073" class="Function">lem₁</a> <a id="1117" class="Symbol">=</a> <a id="1119" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="1125" class="Comment">-- However propositional equality is only suitable when we want to</a>
<a id="1192" class="Comment">-- use propositional equality to compare the individual elements.</a>
<a id="1258" class="Comment">-- Although a contrived example, consider trying to prove the</a>
<a id="1320" class="Comment">-- equality of two lists of the type `List (ℕ → ℕ)`:</a>

<a id="lem₂"></a><a id="1374" href="README.Data.List.Relation.Binary.Equality.html#1374" class="MissingDefinition Postulate">lem₂</a><a id="1378" class="MissingDefinition"> </a><a id="1379" class="MissingDefinition Symbol">:</a><a id="1380" class="MissingDefinition"> </a><a id="1381" class="MissingDefinition Symbol">(λ</a><a id="1383" class="MissingDefinition"> </a><a id="1384" href="README.Data.List.Relation.Binary.Equality.html#1384" class="MissingDefinition Bound">x</a><a id="1385" class="MissingDefinition"> </a><a id="1386" class="MissingDefinition Symbol">→</a><a id="1387" class="MissingDefinition"> </a><a id="1388" class="MissingDefinition Number">2</a><a id="1389" class="MissingDefinition"> </a><a id="1390" href="Agda.Builtin.Nat.html#528" class="MissingDefinition Primitive Operator">*</a><a id="1391" class="MissingDefinition"> </a><a id="1392" href="README.Data.List.Relation.Binary.Equality.html#1384" class="MissingDefinition Bound">x</a><a id="1393" class="MissingDefinition"> </a><a id="1394" href="Agda.Builtin.Nat.html#325" class="MissingDefinition Primitive Operator">+</a><a id="1395" class="MissingDefinition"> </a><a id="1396" class="MissingDefinition Number">2</a><a id="1397" class="MissingDefinition Symbol">)</a><a id="1398" class="MissingDefinition"> </a><a id="1399" href="Agda.Builtin.List.html#200" class="MissingDefinition InductiveConstructor Operator">∷</a><a id="1400" class="MissingDefinition"> </a><a id="1401" href="Agda.Builtin.List.html#185" class="MissingDefinition InductiveConstructor">[]</a><a id="1403" class="MissingDefinition"> </a><a id="1404" href="Agda.Builtin.Equality.html#151" class="MissingDefinition Datatype Operator">≡</a><a id="1405" class="MissingDefinition"> </a><a id="1406" class="MissingDefinition Symbol">(λ</a><a id="1408" class="MissingDefinition"> </a><a id="1409" href="README.Data.List.Relation.Binary.Equality.html#1409" class="MissingDefinition Bound">x</a><a id="1410" class="MissingDefinition"> </a><a id="1411" class="MissingDefinition Symbol">→</a><a id="1412" class="MissingDefinition"> </a><a id="1413" class="MissingDefinition Number">2</a><a id="1414" class="MissingDefinition"> </a><a id="1415" href="Agda.Builtin.Nat.html#528" class="MissingDefinition Primitive Operator">*</a><a id="1416" class="MissingDefinition"> </a><a id="1417" class="MissingDefinition Symbol">(</a><a id="1418" href="README.Data.List.Relation.Binary.Equality.html#1409" class="MissingDefinition Bound">x</a><a id="1419" class="MissingDefinition"> </a><a id="1420" href="Agda.Builtin.Nat.html#325" class="MissingDefinition Primitive Operator">+</a><a id="1421" class="MissingDefinition"> </a><a id="1422" class="MissingDefinition Number">1</a><a id="1423" class="MissingDefinition Symbol">))</a><a id="1425" class="MissingDefinition"> </a><a id="1426" href="Agda.Builtin.List.html#200" class="MissingDefinition InductiveConstructor Operator">∷</a><a id="1427" class="MissingDefinition"> </a><a id="1428" href="Agda.Builtin.List.html#185" class="MissingDefinition InductiveConstructor">[]</a>

<a id="1432" class="Comment">-- In such a case it is impossible to prove the two lists equal with</a>
<a id="1501" class="Comment">-- refl as the two functions are not propositionally equal. In the</a>
<a id="1568" class="Comment">-- absence of postulating function extensionality (see README.Axioms),</a>
<a id="1639" class="Comment">-- the most common definition of function equality is to say that two</a>
<a id="1709" class="Comment">-- functions are equal if their outputs are always propositionally</a>
<a id="1776" class="Comment">-- equal for any input. This notion of function equality `_≗_` is</a>
<a id="1842" class="Comment">-- found in:</a>

<a id="1856" class="Keyword">open</a> <a id="1861" class="Keyword">import</a> <a id="1868" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1906" class="Keyword">using</a> <a id="1912" class="Symbol">(</a><a id="1913" href="Relation.Binary.PropositionalEquality.html#1471" class="Function Operator">_≗_</a><a id="1916" class="Symbol">)</a>

<a id="1919" class="Comment">-- We now want to use the `Pointwise` relation to say that the two</a>
<a id="1986" class="Comment">-- lists are equal if their elements are pointwise equal with resepct</a>
<a id="2056" class="Comment">-- to `_≗_`. However instead of using the pointwise module directly</a>
<a id="2124" class="Comment">-- to write:</a>

<a id="2138" class="Keyword">open</a> <a id="2143" class="Keyword">import</a> <a id="2150" href="Data.List.Relation.Binary.Pointwise.html" class="Module">Data.List.Relation.Binary.Pointwise</a> <a id="2186" class="Keyword">using</a> <a id="2192" class="Symbol">(</a><a id="2193" href="Data.List.Relation.Binary.Pointwise.html#1571" class="Datatype">Pointwise</a><a id="2202" class="Symbol">)</a>

<a id="lem₃"></a><a id="2205" href="README.Data.List.Relation.Binary.Equality.html#2205" class="MissingDefinition Postulate">lem₃</a><a id="2209" class="MissingDefinition"> </a><a id="2210" class="MissingDefinition Symbol">:</a><a id="2211" class="MissingDefinition"> </a><a id="2212" href="Data.List.Relation.Binary.Pointwise.html#1571" class="MissingDefinition Datatype">Pointwise</a><a id="2221" class="MissingDefinition"> </a><a id="2222" href="Relation.Binary.PropositionalEquality.html#1471" class="MissingDefinition Function Operator">_≗_</a><a id="2225" class="MissingDefinition"> </a><a id="2226" class="MissingDefinition Symbol">((λ</a><a id="2229" class="MissingDefinition"> </a><a id="2230" href="README.Data.List.Relation.Binary.Equality.html#2230" class="MissingDefinition Bound">x</a><a id="2231" class="MissingDefinition"> </a><a id="2232" class="MissingDefinition Symbol">→</a><a id="2233" class="MissingDefinition"> </a><a id="2234" href="README.Data.List.Relation.Binary.Equality.html#2230" class="MissingDefinition Bound">x</a><a id="2235" class="MissingDefinition"> </a><a id="2236" href="Agda.Builtin.Nat.html#325" class="MissingDefinition Primitive Operator">+</a><a id="2237" class="MissingDefinition"> </a><a id="2238" class="MissingDefinition Number">1</a><a id="2239" class="MissingDefinition Symbol">)</a><a id="2240" class="MissingDefinition"> </a><a id="2241" href="Agda.Builtin.List.html#200" class="MissingDefinition InductiveConstructor Operator">∷</a><a id="2242" class="MissingDefinition"> </a><a id="2243" href="Agda.Builtin.List.html#185" class="MissingDefinition InductiveConstructor">[]</a><a id="2245" class="MissingDefinition Symbol">)</a><a id="2246" class="MissingDefinition"> </a><a id="2247" class="MissingDefinition Symbol">((λ</a><a id="2250" class="MissingDefinition"> </a><a id="2251" href="README.Data.List.Relation.Binary.Equality.html#2251" class="MissingDefinition Bound">x</a><a id="2252" class="MissingDefinition"> </a><a id="2253" class="MissingDefinition Symbol">→</a><a id="2254" class="MissingDefinition"> </a><a id="2255" href="README.Data.List.Relation.Binary.Equality.html#2251" class="MissingDefinition Bound">x</a><a id="2256" class="MissingDefinition"> </a><a id="2257" href="Agda.Builtin.Nat.html#325" class="MissingDefinition Primitive Operator">+</a><a id="2258" class="MissingDefinition"> </a><a id="2259" class="MissingDefinition Number">2</a><a id="2260" class="MissingDefinition"> </a><a id="2261" href="Data.Nat.Base.html#2869" class="MissingDefinition Primitive Operator">∸</a><a id="2262" class="MissingDefinition"> </a><a id="2263" class="MissingDefinition Number">1</a><a id="2264" class="MissingDefinition Symbol">)</a><a id="2265" class="MissingDefinition"> </a><a id="2266" href="Agda.Builtin.List.html#200" class="MissingDefinition InductiveConstructor Operator">∷</a><a id="2267" class="MissingDefinition"> </a><a id="2268" href="Agda.Builtin.List.html#185" class="MissingDefinition InductiveConstructor">[]</a><a id="2270" class="MissingDefinition Symbol">)</a>

<a id="2273" class="Comment">-- the library provides some nicer wrappers and infix notation in the</a>
<a id="2343" class="Comment">-- folder &quot;Data.List.Relation.Binary.Equality&quot;.</a>

<a id="2392" class="Comment">-- Within this folder there are four different modules.</a>

<a id="2449" class="Keyword">import</a> <a id="2456" href="Data.List.Relation.Binary.Equality.Setoid.html" class="Module">Data.List.Relation.Binary.Equality.Setoid</a>           <a id="2508" class="Symbol">as</a> <a id="2511" class="Module">SetoidEq</a>
<a id="2520" class="Keyword">import</a> <a id="2527" href="Data.List.Relation.Binary.Equality.DecSetoid.html" class="Module">Data.List.Relation.Binary.Equality.DecSetoid</a>        <a id="2579" class="Symbol">as</a> <a id="2582" class="Module">DecSetoidEq</a>
<a id="2594" class="Keyword">import</a> <a id="2601" href="Data.List.Relation.Binary.Equality.Propositional.html" class="Module">Data.List.Relation.Binary.Equality.Propositional</a>    <a id="2653" class="Symbol">as</a> <a id="2656" class="Module">PropEq</a>
<a id="2663" class="Keyword">import</a> <a id="2670" href="Data.List.Relation.Binary.Equality.DecPropositional.html" class="Module">Data.List.Relation.Binary.Equality.DecPropositional</a> <a id="2722" class="Symbol">as</a> <a id="2725" class="Module">DecPropEq</a>

<a id="2736" class="Comment">-- Which one should be used depends on whether the underlying equality</a>
<a id="2807" class="Comment">-- over &quot;A&quot; is:</a>
<a id="2823" class="Comment">--   i)  propositional or setoid-based</a>
<a id="2862" class="Comment">--   ii) decidable.</a>

<a id="2883" class="Comment">-- Each of the modules except `PropEq` are designed to be opened with a</a>
<a id="2955" class="Comment">-- module parameter. This is to avoid having to specify the underlying</a>
<a id="3026" class="Comment">-- equality relation or the decidability proofs every time you use the</a>
<a id="3097" class="Comment">-- list equality.</a>

<a id="3116" class="Comment">-- In our example function equality is not decidable and not propositional</a>
<a id="3191" class="Comment">-- and so we want to use the `SetoidEq` module. This requires a proof that</a>
<a id="3266" class="Comment">-- the `_≗_` relation forms a setoid over functions of the type `ℕ → ℕ`.</a>
<a id="3339" class="Comment">-- This is found in:</a>

<a id="3361" class="Keyword">open</a> <a id="3366" class="Keyword">import</a> <a id="3373" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="3411" class="Keyword">using</a> <a id="3417" class="Symbol">(</a><a id="3418" href="Relation.Binary.PropositionalEquality.html#1357" class="Function Operator">_→-setoid_</a><a id="3428" class="Symbol">)</a>

<a id="3431" class="Comment">-- The `SetoidEq` module should therefore be opened as follows:</a>

<a id="3496" class="Keyword">open</a> <a id="3501" href="Data.List.Relation.Binary.Equality.Setoid.html" class="Module">SetoidEq</a> <a id="3510" class="Symbol">(</a><a id="3511" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="3513" href="Relation.Binary.PropositionalEquality.html#1357" class="Function Operator">→-setoid</a> <a id="3522" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3523" class="Symbol">)</a>

<a id="3526" class="Comment">-- All four equality modules provide an infix operator `_≋_` for the</a>
<a id="3595" class="Comment">-- new equality relation over lists. The type of `lem₃` can therefore</a>
<a id="3665" class="Comment">-- be rewritten as:</a>

<a id="lem₄"></a><a id="3686" href="README.Data.List.Relation.Binary.Equality.html#3686" class="Function">lem₄</a> <a id="3691" class="Symbol">:</a> <a id="3693" class="Symbol">(λ</a> <a id="3696" href="README.Data.List.Relation.Binary.Equality.html#3696" class="Bound">x</a> <a id="3698" class="Symbol">→</a> <a id="3700" href="README.Data.List.Relation.Binary.Equality.html#3696" class="Bound">x</a> <a id="3702" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="3704" class="Number">1</a><a id="3705" class="Symbol">)</a> <a id="3707" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3709" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="3712" href="Data.List.Relation.Binary.Equality.Setoid.html#1136" class="Function Operator">≋</a> <a id="3714" class="Symbol">(λ</a> <a id="3717" href="README.Data.List.Relation.Binary.Equality.html#3717" class="Bound">x</a> <a id="3719" class="Symbol">→</a> <a id="3721" href="README.Data.List.Relation.Binary.Equality.html#3717" class="Bound">x</a> <a id="3723" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="3725" class="Number">2</a> <a id="3727" href="Data.Nat.Base.html#2869" class="Primitive Operator">∸</a> <a id="3729" class="Number">1</a><a id="3730" class="Symbol">)</a> <a id="3732" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3734" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
<a id="3737" href="README.Data.List.Relation.Binary.Equality.html#3686" class="Function">lem₄</a> <a id="3742" class="Symbol">=</a> <a id="3744" href="README.Data.List.Relation.Binary.Equality.html#3771" class="Function">2x+2≗2[x+1]</a> <a id="3756" href="Data.List.Relation.Binary.Pointwise.html#1710" class="InductiveConstructor Operator">∷</a> <a id="3758" href="Data.List.Relation.Binary.Pointwise.html#1682" class="InductiveConstructor">[]</a>
  <a id="3763" class="Keyword">where</a>
  <a id="3771" href="README.Data.List.Relation.Binary.Equality.html#3771" class="Function">2x+2≗2[x+1]</a> <a id="3783" class="Symbol">:</a> <a id="3785" class="Symbol">(λ</a> <a id="3788" href="README.Data.List.Relation.Binary.Equality.html#3788" class="Bound">x</a> <a id="3790" class="Symbol">→</a> <a id="3792" href="README.Data.List.Relation.Binary.Equality.html#3788" class="Bound">x</a> <a id="3794" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="3796" class="Number">1</a><a id="3797" class="Symbol">)</a> <a id="3799" href="Relation.Binary.PropositionalEquality.html#1471" class="Function Operator">≗</a> <a id="3801" class="Symbol">(λ</a> <a id="3804" href="README.Data.List.Relation.Binary.Equality.html#3804" class="Bound">x</a> <a id="3806" class="Symbol">→</a> <a id="3808" href="README.Data.List.Relation.Binary.Equality.html#3804" class="Bound">x</a> <a id="3810" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="3812" class="Number">2</a> <a id="3814" href="Data.Nat.Base.html#2869" class="Primitive Operator">∸</a> <a id="3816" class="Number">1</a><a id="3817" class="Symbol">)</a>
  <a id="3821" href="README.Data.List.Relation.Binary.Equality.html#3771" class="Function">2x+2≗2[x+1]</a> <a id="3833" href="README.Data.List.Relation.Binary.Equality.html#3833" class="Bound">x</a> <a id="3835" class="Symbol">=</a> <a id="3837" href="Relation.Binary.PropositionalEquality.Core.html#1727" class="Function">sym</a> <a id="3841" class="Symbol">(</a><a id="3842" href="Data.Nat.Properties.html#47047" class="Function">+-∸-assoc</a> <a id="3852" href="README.Data.List.Relation.Binary.Equality.html#3833" class="Bound">x</a> <a id="3854" class="Symbol">(</a><a id="3855" href="Data.Nat.Base.html#1595" class="InductiveConstructor">s≤s</a> <a id="3859" href="Data.Nat.Base.html#1553" class="InductiveConstructor">z≤n</a><a id="3862" class="Symbol">))</a>

<a id="3866" class="Comment">-- The modules also provide proofs that the `_≋_` relation is a</a>
<a id="3930" class="Comment">-- setoid in its own right and therefore is reflexive, symmetric,</a>
<a id="3996" class="Comment">-- transitive:</a>

<a id="lem₅"></a><a id="4012" href="README.Data.List.Relation.Binary.Equality.html#4012" class="Function">lem₅</a> <a id="4017" class="Symbol">:</a> <a id="4019" class="Symbol">(λ</a> <a id="4022" href="README.Data.List.Relation.Binary.Equality.html#4022" class="Bound">x</a> <a id="4024" class="Symbol">→</a> <a id="4026" class="Number">2</a> <a id="4028" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="4030" href="README.Data.List.Relation.Binary.Equality.html#4022" class="Bound">x</a> <a id="4032" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="4034" class="Number">2</a><a id="4035" class="Symbol">)</a> <a id="4037" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4039" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="4042" href="Data.List.Relation.Binary.Equality.Setoid.html#1136" class="Function Operator">≋</a> <a id="4044" class="Symbol">(λ</a> <a id="4047" href="README.Data.List.Relation.Binary.Equality.html#4047" class="Bound">x</a> <a id="4049" class="Symbol">→</a> <a id="4051" class="Number">2</a> <a id="4053" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="4055" href="README.Data.List.Relation.Binary.Equality.html#4047" class="Bound">x</a> <a id="4057" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="4059" class="Number">2</a><a id="4060" class="Symbol">)</a> <a id="4062" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4064" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
<a id="4067" href="README.Data.List.Relation.Binary.Equality.html#4012" class="Function">lem₅</a> <a id="4072" class="Symbol">=</a> <a id="4074" href="Data.List.Relation.Binary.Equality.Setoid.html#1391" class="Function">≋-refl</a>

<a id="4082" class="Comment">-- If we could prove that `_≗_` forms a `DecSetoid` then we could use</a>
<a id="4152" class="Comment">-- the module `DecSetoidEq` instead. This exports everything from</a>
<a id="4218" class="Comment">-- `SetoidEq` as well as the additional proof `_≋?_` that the list</a>
<a id="4285" class="Comment">-- equality is decidable.</a>

<a id="4312" class="Comment">-- This pattern of four modules for each of the four different types</a>
<a id="4381" class="Comment">-- of equality is repeated throughout the library (e.g. see the</a>
<a id="4445" class="Comment">-- `Membership`). Note that in this case the modules `PropEq` and</a>
<a id="4511" class="Comment">-- `DecPropEq` are not very useful as if two lists are pointwise</a>
<a id="4576" class="Comment">-- propositionally equal they are necessarily propositionally equal</a>
<a id="4644" class="Comment">-- (and vice-versa). There are proofs of this fact exported by</a>
<a id="4707" class="Comment">-- `PropEq` and `DecPropEq`. Although, these two types of list equality</a>
<a id="4779" class="Comment">-- are not very useful in practice, they are included for completeness&#39;s</a>
<a id="4852" class="Comment">-- sake.</a>
</pre></body></html>