<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Inspect</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Explaining how to use the inspect idiom and elaborating on the way</a>
<a id="176" class="Comment">-- it is implemented in the standard library.</a>
<a id="222" class="Comment">------------------------------------------------------------------------</a>

<a id="296" class="Symbol">{-#</a> <a id="300" class="Keyword">OPTIONS</a> <a id="308" class="Pragma">--without-K</a> <a id="320" class="Pragma">--safe</a> <a id="327" class="Symbol">#-}</a>

<a id="332" class="Keyword">module</a> <a id="339" href="README.Inspect.html" class="Module">README.Inspect</a> <a id="354" class="Keyword">where</a>

<a id="361" class="Keyword">open</a> <a id="366" class="Keyword">import</a> <a id="373" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="387" class="Keyword">open</a> <a id="392" class="Keyword">import</a> <a id="399" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="419" class="Keyword">open</a> <a id="424" class="Keyword">import</a> <a id="431" href="Data.Product.html" class="Module">Data.Product</a>
<a id="444" class="Keyword">open</a> <a id="449" class="Keyword">import</a> <a id="456" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="495" class="Comment">------------------------------------------------------------------------</a>
<a id="568" class="Comment">-- Using inspect</a>

<a id="586" class="Comment">-- We start with the definition of a (silly) predicate: `Plus m n p` states</a>
<a id="662" class="Comment">-- that `m + n` is equal to `p` in a rather convoluted way. Crucially, it</a>
<a id="736" class="Comment">-- distinguishes two cases: whether `p` is 0 or not.</a>

<a id="Plus-eq"></a><a id="790" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="798" class="Symbol">:</a> <a id="800" class="Symbol">(</a><a id="801" href="README.Inspect.html#801" class="Bound">m</a> <a id="803" href="README.Inspect.html#803" class="Bound">n</a> <a id="805" href="README.Inspect.html#805" class="Bound">p</a> <a id="807" class="Symbol">:</a> <a id="809" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="810" class="Symbol">)</a> <a id="812" class="Symbol">→</a> <a id="814" class="PrimitiveType">Set</a>
<a id="818" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="826" href="README.Inspect.html#826" class="Bound">m</a> <a id="828" href="README.Inspect.html#828" class="Bound">n</a> <a id="830" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>      <a id="840" class="Symbol">=</a> <a id="842" href="README.Inspect.html#826" class="Bound">m</a> <a id="844" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="846" class="Number">0</a> <a id="848" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="850" href="README.Inspect.html#828" class="Bound">n</a> <a id="852" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="854" class="Number">0</a>
<a id="856" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="864" href="README.Inspect.html#864" class="Bound">m</a> <a id="866" href="README.Inspect.html#866" class="Bound">n</a> <a id="868" href="README.Inspect.html#868" class="Bound">p</a><a id="869" class="Symbol">@(</a><a id="871" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="875" class="Symbol">_)</a> <a id="878" class="Symbol">=</a> <a id="880" href="README.Inspect.html#864" class="Bound">m</a> <a id="882" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="884" href="README.Inspect.html#866" class="Bound">n</a> <a id="886" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="888" href="README.Inspect.html#868" class="Bound">p</a>

<a id="891" class="Comment">-- A sensible lemma to prove of this predicate is that whenever `p` is literally</a>
<a id="972" class="Comment">-- `m + n` then `Plus m n p` holds. That is to say `∀ m n → Plus m n (m + n)`.</a>
<a id="1051" class="Comment">-- To be able to prove `Plus-eq m n (m + n)`, we need `m + n` to have either</a>
<a id="1128" class="Comment">-- the shape `zero` or `suc _` so that `Plus-eq` may reduce.</a>

<a id="1190" class="Comment">-- We could follow the way `_+_` computes by mimicking the same splitting</a>
<a id="1264" class="Comment">-- strategy, thus forcing `m + n` to reduce:</a>

<a id="plus-eq-+"></a><a id="1310" href="README.Inspect.html#1310" class="Function">plus-eq-+</a> <a id="1320" class="Symbol">:</a> <a id="1322" class="Symbol">∀</a> <a id="1324" href="README.Inspect.html#1324" class="Bound">m</a> <a id="1326" href="README.Inspect.html#1326" class="Bound">n</a> <a id="1328" class="Symbol">→</a> <a id="1330" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="1338" href="README.Inspect.html#1324" class="Bound">m</a> <a id="1340" href="README.Inspect.html#1326" class="Bound">n</a> <a id="1342" class="Symbol">(</a><a id="1343" href="README.Inspect.html#1324" class="Bound">m</a> <a id="1345" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="1347" href="README.Inspect.html#1326" class="Bound">n</a><a id="1348" class="Symbol">)</a>
<a id="1350" href="README.Inspect.html#1310" class="Function">plus-eq-+</a> <a id="1360" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>   <a id="1367" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="1375" class="Symbol">=</a> <a id="1377" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="1382" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1384" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="1389" href="README.Inspect.html#1310" class="Function">plus-eq-+</a> <a id="1399" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>   <a id="1406" class="Symbol">(</a><a id="1407" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1411" href="README.Inspect.html#1411" class="Bound">n</a><a id="1412" class="Symbol">)</a> <a id="1414" class="Symbol">=</a> <a id="1416" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="1421" href="README.Inspect.html#1310" class="Function">plus-eq-+</a> <a id="1431" class="Symbol">(</a><a id="1432" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1436" href="README.Inspect.html#1436" class="Bound">m</a><a id="1437" class="Symbol">)</a> <a id="1439" href="README.Inspect.html#1439" class="Bound">n</a>      <a id="1446" class="Symbol">=</a> <a id="1448" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="1454" class="Comment">-- Or we could attempt to compute `m + n` first and check whether the result</a>
<a id="1531" class="Comment">-- is `zero` or `suc p`. By using `with m + n` and naming the result `p`,</a>
<a id="1605" class="Comment">-- the goal will become `Plus-eq m n p`. We can further refine this definition</a>
<a id="1684" class="Comment">-- by distinguishing two cases like so:</a>

<a id="1725" class="Comment">-- plus-eq-with : ∀ m n → Plus-eq m n (m + n)</a>
<a id="1771" class="Comment">-- plus-eq-with m n with m + n</a>
<a id="1802" class="Comment">-- ... | zero  = {!!}</a>
<a id="1824" class="Comment">-- ... | suc p = {!!}</a>

<a id="1847" class="Comment">-- The problem however is that we have abolutely lost the connection between the</a>
<a id="1928" class="Comment">-- computation `m + n` and its result `p`. Which makes the two goals unprovable:</a>

<a id="2010" class="Comment">-- 1. `m ≡ 0 × n ≡ 0`, with no assumption whatsoever</a>
<a id="2063" class="Comment">-- 2. `m + n ≡ suc p`, with no assumption either</a>

<a id="2113" class="Comment">-- By using the `with` construct, we have generated an auxiliary function that</a>
<a id="2192" class="Comment">-- looks like this:</a>
<a id="2212" class="Comment">-- `plus-eq-with-aux : ∀ m n p → Plus-eq m n p`</a>
<a id="2260" class="Comment">-- when we would have wanted a more precise type of the form:</a>
<a id="2322" class="Comment">-- `plus-eq-aux : ∀ m n p → m + n ≡ p → Plus-eq m n p`.</a>

<a id="2379" class="Comment">-- This is where we can use `inspect`. By using `with f x | inspect f x`,</a>
<a id="2453" class="Comment">-- we get both a `y` which is the result of `f x` and a proof that `f x ≡ y`.</a>
<a id="2531" class="Comment">-- Splitting on the result of `m + n`, we get two cases:</a>

<a id="2589" class="Comment">-- 1. `m ≡ 0 × n ≡ 0` under the assumption that `m + n ≡ zero`</a>
<a id="2652" class="Comment">-- 2. `m + n ≡ suc p` under the assumption that `m + n ≡ suc p`</a>

<a id="2717" class="Comment">-- The first one can be discharged using lemmas from Data.Nat.Properties and</a>
<a id="2794" class="Comment">-- the second one is trivial.</a>

<a id="plus-eq-with"></a><a id="2825" href="README.Inspect.html#2825" class="Function">plus-eq-with</a> <a id="2838" class="Symbol">:</a> <a id="2840" class="Symbol">∀</a> <a id="2842" href="README.Inspect.html#2842" class="Bound">m</a> <a id="2844" href="README.Inspect.html#2844" class="Bound">n</a> <a id="2846" class="Symbol">→</a> <a id="2848" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="2856" href="README.Inspect.html#2842" class="Bound">m</a> <a id="2858" href="README.Inspect.html#2844" class="Bound">n</a> <a id="2860" class="Symbol">(</a><a id="2861" href="README.Inspect.html#2842" class="Bound">m</a> <a id="2863" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2865" href="README.Inspect.html#2844" class="Bound">n</a><a id="2866" class="Symbol">)</a>
<a id="2868" href="README.Inspect.html#2825" class="Function">plus-eq-with</a> <a id="2881" href="README.Inspect.html#2881" class="Bound">m</a> <a id="2883" href="README.Inspect.html#2883" class="Bound">n</a> <a id="2885" class="Keyword">with</a> <a id="2890" href="README.Inspect.html#2881" class="Bound">m</a> <a id="2892" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2894" href="README.Inspect.html#2883" class="Bound">n</a> <a id="2896" class="Symbol">|</a> <a id="2898" href="Relation.Binary.PropositionalEquality.html#3249" class="Function">inspect</a> <a id="2906" class="Symbol">(</a><a id="2907" href="README.Inspect.html#2881" class="Bound">m</a> <a id="2909" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+_</a><a id="2911" class="Symbol">)</a> <a id="2913" href="README.Inspect.html#2883" class="Bound">n</a>
<a id="2915" class="Symbol">...</a> <a id="2919" class="Symbol">|</a> <a id="2921" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>  <a id="2927" class="Symbol">|</a> <a id="2929" href="Relation.Binary.PropositionalEquality.html#3223" class="InductiveConstructor Operator">[</a> <a id="2931" href="README.Inspect.html#2931" class="Bound">m+n≡0</a>   <a id="2939" href="Relation.Binary.PropositionalEquality.html#3223" class="InductiveConstructor Operator">]</a> <a id="2941" class="Symbol">=</a> <a id="2943" href="Data.Nat.Properties.html#13830" class="Function">i+j≡0⇒i≡0</a> <a id="2953" class="Bound">m</a> <a id="2955" href="README.Inspect.html#2931" class="Bound">m+n≡0</a> <a id="2961" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="2963" href="Data.Nat.Properties.html#13899" class="Function">i+j≡0⇒j≡0</a> <a id="2973" class="Bound">m</a> <a id="2975" href="README.Inspect.html#2931" class="Bound">m+n≡0</a>
<a id="2981" class="Symbol">...</a> <a id="2985" class="Symbol">|</a> <a id="2987" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="2991" href="README.Inspect.html#2991" class="Bound">p</a> <a id="2993" class="Symbol">|</a> <a id="2995" href="Relation.Binary.PropositionalEquality.html#3223" class="InductiveConstructor Operator">[</a> <a id="2997" href="README.Inspect.html#2997" class="Bound">m+n≡1+p</a> <a id="3005" href="Relation.Binary.PropositionalEquality.html#3223" class="InductiveConstructor Operator">]</a> <a id="3007" class="Symbol">=</a> <a id="3009" href="README.Inspect.html#2997" class="Bound">m+n≡1+p</a>


<a id="3019" class="Comment">------------------------------------------------------------------------</a>
<a id="3092" class="Comment">-- Understanding the implementation of inspect</a>

<a id="3140" class="Comment">-- So why is it that we have to go through the record type `Reveal_·_is_`</a>
<a id="3214" class="Comment">-- and the ̀inspect` function? The fact is: we don&#39;t have to if we write</a>
<a id="3287" class="Comment">-- our own auxiliary lemma:</a>

<a id="plus-eq-aux"></a><a id="3316" href="README.Inspect.html#3316" class="Function">plus-eq-aux</a> <a id="3328" class="Symbol">:</a> <a id="3330" class="Symbol">∀</a> <a id="3332" href="README.Inspect.html#3332" class="Bound">m</a> <a id="3334" href="README.Inspect.html#3334" class="Bound">n</a> <a id="3336" class="Symbol">→</a> <a id="3338" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="3346" href="README.Inspect.html#3332" class="Bound">m</a> <a id="3348" href="README.Inspect.html#3334" class="Bound">n</a> <a id="3350" class="Symbol">(</a><a id="3351" href="README.Inspect.html#3332" class="Bound">m</a> <a id="3353" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3355" href="README.Inspect.html#3334" class="Bound">n</a><a id="3356" class="Symbol">)</a>
<a id="3358" href="README.Inspect.html#3316" class="Function">plus-eq-aux</a> <a id="3370" href="README.Inspect.html#3370" class="Bound">m</a> <a id="3372" href="README.Inspect.html#3372" class="Bound">n</a> <a id="3374" class="Symbol">=</a> <a id="3376" href="README.Inspect.html#3406" class="Function">aux</a> <a id="3380" href="README.Inspect.html#3370" class="Bound">m</a> <a id="3382" href="README.Inspect.html#3372" class="Bound">n</a> <a id="3384" class="Symbol">(</a><a id="3385" href="README.Inspect.html#3370" class="Bound">m</a> <a id="3387" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3389" href="README.Inspect.html#3372" class="Bound">n</a><a id="3390" class="Symbol">)</a> <a id="3392" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="3397" class="Keyword">where</a>

  <a id="3406" href="README.Inspect.html#3406" class="Function">aux</a> <a id="3410" class="Symbol">:</a> <a id="3412" class="Symbol">∀</a> <a id="3414" href="README.Inspect.html#3414" class="Bound">m</a> <a id="3416" href="README.Inspect.html#3416" class="Bound">n</a> <a id="3418" href="README.Inspect.html#3418" class="Bound">p</a> <a id="3420" class="Symbol">→</a> <a id="3422" href="README.Inspect.html#3414" class="Bound">m</a> <a id="3424" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3426" href="README.Inspect.html#3416" class="Bound">n</a> <a id="3428" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3430" href="README.Inspect.html#3418" class="Bound">p</a> <a id="3432" class="Symbol">→</a> <a id="3434" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="3442" href="README.Inspect.html#3414" class="Bound">m</a> <a id="3444" href="README.Inspect.html#3416" class="Bound">n</a> <a id="3446" href="README.Inspect.html#3418" class="Bound">p</a>
  <a id="3450" href="README.Inspect.html#3406" class="Function">aux</a> <a id="3454" href="README.Inspect.html#3454" class="Bound">m</a> <a id="3456" href="README.Inspect.html#3456" class="Bound">n</a> <a id="3458" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="3466" href="README.Inspect.html#3466" class="Bound">m+n≡0</a>   <a id="3474" class="Symbol">=</a> <a id="3476" href="Data.Nat.Properties.html#13830" class="Function">i+j≡0⇒i≡0</a> <a id="3486" href="README.Inspect.html#3454" class="Bound">m</a> <a id="3488" href="README.Inspect.html#3466" class="Bound">m+n≡0</a> <a id="3494" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="3496" href="Data.Nat.Properties.html#13899" class="Function">i+j≡0⇒j≡0</a> <a id="3506" href="README.Inspect.html#3454" class="Bound">m</a> <a id="3508" href="README.Inspect.html#3466" class="Bound">m+n≡0</a>
  <a id="3516" href="README.Inspect.html#3406" class="Function">aux</a> <a id="3520" href="README.Inspect.html#3520" class="Bound">m</a> <a id="3522" href="README.Inspect.html#3522" class="Bound">n</a> <a id="3524" class="Symbol">(</a><a id="3525" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3529" href="README.Inspect.html#3529" class="Bound">p</a><a id="3530" class="Symbol">)</a> <a id="3532" href="README.Inspect.html#3532" class="Bound">m+n≡1+p</a> <a id="3540" class="Symbol">=</a> <a id="3542" href="README.Inspect.html#3532" class="Bound">m+n≡1+p</a>

<a id="3551" class="Comment">-- The problem is that when we write ̀with f x | pr`, `with` decides to call `y`</a>
<a id="3632" class="Comment">-- the result `f x` and to replace *all* of the occurences of `f x` in the type</a>
<a id="3712" class="Comment">-- of `pr` with `y`. That is to say that if we were to write:</a>

<a id="3775" class="Comment">-- plus-eq-naïve : ∀ m n → Plus-eq m n (m + n)</a>
<a id="3822" class="Comment">-- plus-eq-naïve m n with m + n | refl {x = m + n}</a>
<a id="3873" class="Comment">-- ... | p | eq = {!!}</a>

<a id="3897" class="Comment">-- then `with` would abstract `m + n` as `p` on *both* sides of the equality</a>
<a id="3974" class="Comment">-- proven by `refl` thus giving us the following goal with an extra, useless,</a>
<a id="4052" class="Comment">-- assumption:</a>

<a id="4068" class="Comment">-- 1. `Plus-eq m n p` under the assumption that `p ≡ p`</a>

<a id="4125" class="Comment">-- So how does `inspect` work? The standard library uses a more general version</a>
<a id="4205" class="Comment">-- of the following type and function:</a>

<a id="4245" class="Keyword">record</a> <a id="MyReveal_·_is_"></a><a id="4252" href="README.Inspect.html#4252" class="Record Operator">MyReveal_·_is_</a> <a id="4267" class="Symbol">(</a><a id="4268" href="README.Inspect.html#4268" class="Bound">f</a> <a id="4270" class="Symbol">:</a> <a id="4272" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="4274" class="Symbol">→</a> <a id="4276" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="4277" class="Symbol">)</a> <a id="4279" class="Symbol">(</a><a id="4280" href="README.Inspect.html#4280" class="Bound">x</a> <a id="4282" href="README.Inspect.html#4282" class="Bound">y</a> <a id="4284" class="Symbol">:</a> <a id="4286" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="4287" class="Symbol">)</a> <a id="4289" class="Symbol">:</a> <a id="4291" class="PrimitiveType">Set</a> <a id="4295" class="Keyword">where</a>
  <a id="4303" class="Keyword">constructor</a> <a id="MyReveal_·_is_.[_]"></a><a id="4315" href="README.Inspect.html#4315" class="InductiveConstructor Operator">[_]</a>
  <a id="4321" class="Keyword">field</a> <a id="MyReveal_·_is_.eq"></a><a id="4327" href="README.Inspect.html#4327" class="Field">eq</a> <a id="4330" class="Symbol">:</a> <a id="4332" href="README.Inspect.html#4268" class="Bound">f</a> <a id="4334" href="README.Inspect.html#4280" class="Bound">x</a> <a id="4336" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4338" href="README.Inspect.html#4282" class="Bound">y</a>

<a id="my-inspect"></a><a id="4341" href="README.Inspect.html#4341" class="Function">my-inspect</a> <a id="4352" class="Symbol">:</a> <a id="4354" class="Symbol">∀</a> <a id="4356" href="README.Inspect.html#4356" class="Bound">f</a> <a id="4358" href="README.Inspect.html#4358" class="Bound">n</a> <a id="4360" class="Symbol">→</a> <a id="4362" href="README.Inspect.html#4252" class="Record Operator">MyReveal</a> <a id="4371" href="README.Inspect.html#4356" class="Bound">f</a> <a id="4373" href="README.Inspect.html#4252" class="Record Operator">·</a> <a id="4375" href="README.Inspect.html#4358" class="Bound">n</a> <a id="4377" href="README.Inspect.html#4252" class="Record Operator">is</a> <a id="4380" class="Symbol">(</a><a id="4381" href="README.Inspect.html#4356" class="Bound">f</a> <a id="4383" href="README.Inspect.html#4358" class="Bound">n</a><a id="4384" class="Symbol">)</a>
<a id="4386" href="README.Inspect.html#4341" class="Function">my-inspect</a> <a id="4397" href="README.Inspect.html#4397" class="Bound">f</a> <a id="4399" href="README.Inspect.html#4399" class="Bound">n</a> <a id="4401" class="Symbol">=</a> <a id="4403" href="README.Inspect.html#4315" class="InductiveConstructor Operator">[</a> <a id="4405" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="4410" href="README.Inspect.html#4315" class="InductiveConstructor Operator">]</a>

<a id="4413" class="Comment">-- Given that `inspect` has the type `∀ f n → Reveal f · n is (f n)`, when we</a>
<a id="4491" class="Comment">-- write `with f n | inspect f n`, the only `f n` that can be abstracted in the</a>
<a id="4571" class="Comment">-- type of `inspect f n` is the third argument to `Reveal_·_is_`.</a>

<a id="4638" class="Comment">-- That is to say that the auxiliary definition generated looks like this:</a>

<a id="plus-eq-reveal"></a><a id="4714" href="README.Inspect.html#4714" class="Function">plus-eq-reveal</a> <a id="4729" class="Symbol">:</a> <a id="4731" class="Symbol">∀</a> <a id="4733" href="README.Inspect.html#4733" class="Bound">m</a> <a id="4735" href="README.Inspect.html#4735" class="Bound">n</a> <a id="4737" class="Symbol">→</a> <a id="4739" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="4747" href="README.Inspect.html#4733" class="Bound">m</a> <a id="4749" href="README.Inspect.html#4735" class="Bound">n</a> <a id="4751" class="Symbol">(</a><a id="4752" href="README.Inspect.html#4733" class="Bound">m</a> <a id="4754" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4756" href="README.Inspect.html#4735" class="Bound">n</a><a id="4757" class="Symbol">)</a>
<a id="4759" href="README.Inspect.html#4714" class="Function">plus-eq-reveal</a> <a id="4774" href="README.Inspect.html#4774" class="Bound">m</a> <a id="4776" href="README.Inspect.html#4776" class="Bound">n</a> <a id="4778" class="Symbol">=</a> <a id="4780" href="README.Inspect.html#4827" class="Function">aux</a> <a id="4784" href="README.Inspect.html#4774" class="Bound">m</a> <a id="4786" href="README.Inspect.html#4776" class="Bound">n</a> <a id="4788" class="Symbol">(</a><a id="4789" href="README.Inspect.html#4774" class="Bound">m</a> <a id="4791" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4793" href="README.Inspect.html#4776" class="Bound">n</a><a id="4794" class="Symbol">)</a> <a id="4796" class="Symbol">(</a><a id="4797" href="README.Inspect.html#4341" class="Function">my-inspect</a> <a id="4808" class="Symbol">(</a><a id="4809" href="README.Inspect.html#4774" class="Bound">m</a> <a id="4811" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+_</a><a id="4813" class="Symbol">)</a> <a id="4815" href="README.Inspect.html#4776" class="Bound">n</a><a id="4816" class="Symbol">)</a> <a id="4818" class="Keyword">where</a>

  <a id="4827" href="README.Inspect.html#4827" class="Function">aux</a> <a id="4831" class="Symbol">:</a> <a id="4833" class="Symbol">∀</a> <a id="4835" href="README.Inspect.html#4835" class="Bound">m</a> <a id="4837" href="README.Inspect.html#4837" class="Bound">n</a> <a id="4839" href="README.Inspect.html#4839" class="Bound">p</a> <a id="4841" class="Symbol">→</a> <a id="4843" href="README.Inspect.html#4252" class="Record Operator">MyReveal</a> <a id="4852" class="Symbol">(</a><a id="4853" href="README.Inspect.html#4835" class="Bound">m</a> <a id="4855" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+_</a><a id="4857" class="Symbol">)</a> <a id="4859" href="README.Inspect.html#4252" class="Record Operator">·</a> <a id="4861" href="README.Inspect.html#4837" class="Bound">n</a> <a id="4863" href="README.Inspect.html#4252" class="Record Operator">is</a> <a id="4866" href="README.Inspect.html#4839" class="Bound">p</a> <a id="4868" class="Symbol">→</a> <a id="4870" href="README.Inspect.html#790" class="Function">Plus-eq</a> <a id="4878" href="README.Inspect.html#4835" class="Bound">m</a> <a id="4880" href="README.Inspect.html#4837" class="Bound">n</a> <a id="4882" href="README.Inspect.html#4839" class="Bound">p</a>
  <a id="4886" href="README.Inspect.html#4827" class="Function">aux</a> <a id="4890" href="README.Inspect.html#4890" class="Bound">m</a> <a id="4892" href="README.Inspect.html#4892" class="Bound">n</a> <a id="4894" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="4902" href="README.Inspect.html#4315" class="InductiveConstructor Operator">[</a> <a id="4904" href="README.Inspect.html#4904" class="Bound">m+n≡0</a>   <a id="4912" href="README.Inspect.html#4315" class="InductiveConstructor Operator">]</a> <a id="4914" class="Symbol">=</a> <a id="4916" href="Data.Nat.Properties.html#13830" class="Function">i+j≡0⇒i≡0</a> <a id="4926" href="README.Inspect.html#4890" class="Bound">m</a> <a id="4928" href="README.Inspect.html#4904" class="Bound">m+n≡0</a> <a id="4934" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="4936" href="Data.Nat.Properties.html#13899" class="Function">i+j≡0⇒j≡0</a> <a id="4946" href="README.Inspect.html#4890" class="Bound">m</a> <a id="4948" href="README.Inspect.html#4904" class="Bound">m+n≡0</a>
  <a id="4956" href="README.Inspect.html#4827" class="Function">aux</a> <a id="4960" href="README.Inspect.html#4960" class="Bound">m</a> <a id="4962" href="README.Inspect.html#4962" class="Bound">n</a> <a id="4964" class="Symbol">(</a><a id="4965" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4969" href="README.Inspect.html#4969" class="Bound">p</a><a id="4970" class="Symbol">)</a> <a id="4972" href="README.Inspect.html#4315" class="InductiveConstructor Operator">[</a> <a id="4974" href="README.Inspect.html#4974" class="Bound">m+n≡1+p</a> <a id="4982" href="README.Inspect.html#4315" class="InductiveConstructor Operator">]</a> <a id="4984" class="Symbol">=</a> <a id="4986" href="README.Inspect.html#4974" class="Bound">m+n≡1+p</a>

<a id="4995" class="Comment">-- At the cost of having to unwrap the constructor `[_]` around the equality</a>
<a id="5072" class="Comment">-- we care about, we can keep relying on `with` and avoid having to roll out</a>
<a id="5149" class="Comment">-- handwritten auxiliary definitions.</a>
</pre></body></html>