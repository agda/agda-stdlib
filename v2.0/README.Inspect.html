<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Inspect</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Explaining how to use the inspect idiom and elaborating on the way</a>
<a id="176" class="Comment">-- it is implemented in the standard library.</a>
<a id="222" class="Comment">------------------------------------------------------------------------</a>

<a id="296" class="Symbol">{-#</a> <a id="300" class="Keyword">OPTIONS</a> <a id="308" class="Pragma">--cubical-compatible</a> <a id="329" class="Pragma">--safe</a> <a id="336" class="Symbol">#-}</a>

<a id="341" class="Keyword">module</a> <a id="348" href="README.Inspect.html" class="Module">README.Inspect</a> <a id="363" class="Keyword">where</a>

<a id="370" class="Keyword">open</a> <a id="375" class="Keyword">import</a> <a id="382" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="396" class="Keyword">open</a> <a id="401" class="Keyword">import</a> <a id="408" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="428" class="Keyword">open</a> <a id="433" class="Keyword">import</a> <a id="440" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="458" class="Keyword">using</a> <a id="464" class="Symbol">(</a><a id="465" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="468" class="Symbol">;</a> <a id="470" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="473" class="Symbol">)</a>
<a id="475" class="Keyword">open</a> <a id="480" class="Keyword">import</a> <a id="487" href="Relation.Binary.PropositionalEquality.Core.html" class="Module">Relation.Binary.PropositionalEquality.Core</a> <a id="530" class="Keyword">using</a> <a id="536" class="Symbol">(</a><a id="537" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="540" class="Symbol">;</a> <a id="542" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="546" class="Symbol">)</a>
<a id="548" class="Keyword">open</a> <a id="553" class="Keyword">import</a> <a id="560" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="598" class="Keyword">using</a> <a id="604" class="Symbol">(</a><a id="605" href="Relation.Binary.PropositionalEquality.html#4429" class="Function">inspect</a><a id="612" class="Symbol">;</a> <a id="614" href="Relation.Binary.PropositionalEquality.html#4403" class="InductiveConstructor Operator">[_]</a><a id="617" class="Symbol">)</a>

<a id="620" class="Comment">------------------------------------------------------------------------</a>
<a id="693" class="Comment">-- Using inspect</a>

<a id="711" class="Comment">-- We start with the definition of a (silly) predicate: `Plus m n p` states</a>
<a id="787" class="Comment">-- that `m + n` is equal to `p` in a rather convoluted way. Crucially, it</a>
<a id="861" class="Comment">-- distinguishes two cases: whether `p` is 0 or not.</a>

<a id="Plus-eq"></a><a id="915" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="923" class="Symbol">:</a> <a id="925" class="Symbol">(</a><a id="926" href="README.Inspect.html#926" class="Bound">m</a> <a id="928" href="README.Inspect.html#928" class="Bound">n</a> <a id="930" href="README.Inspect.html#930" class="Bound">p</a> <a id="932" class="Symbol">:</a> <a id="934" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="935" class="Symbol">)</a> <a id="937" class="Symbol">→</a> <a id="939" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="943" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="951" href="README.Inspect.html#951" class="Bound">m</a> <a id="953" href="README.Inspect.html#953" class="Bound">n</a> <a id="955" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>      <a id="965" class="Symbol">=</a> <a id="967" href="README.Inspect.html#951" class="Bound">m</a> <a id="969" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="971" class="Number">0</a> <a id="973" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="975" href="README.Inspect.html#953" class="Bound">n</a> <a id="977" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="979" class="Number">0</a>
<a id="981" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="989" href="README.Inspect.html#989" class="Bound">m</a> <a id="991" href="README.Inspect.html#991" class="Bound">n</a> <a id="993" href="README.Inspect.html#993" class="Bound">p</a><a id="994" class="Symbol">@(</a><a id="996" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1000" class="Symbol">_)</a> <a id="1003" class="Symbol">=</a> <a id="1005" href="README.Inspect.html#989" class="Bound">m</a> <a id="1007" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="1009" href="README.Inspect.html#991" class="Bound">n</a> <a id="1011" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1013" href="README.Inspect.html#993" class="Bound">p</a>

<a id="1016" class="Comment">-- A sensible lemma to prove of this predicate is that whenever `p` is literally</a>
<a id="1097" class="Comment">-- `m + n` then `Plus m n p` holds. That is to say `∀ m n → Plus m n (m + n)`.</a>
<a id="1176" class="Comment">-- To be able to prove `Plus-eq m n (m + n)`, we need `m + n` to have either</a>
<a id="1253" class="Comment">-- the shape `zero` or `suc _` so that `Plus-eq` may reduce.</a>

<a id="1315" class="Comment">-- We could follow the way `_+_` computes by mimicking the same splitting</a>
<a id="1389" class="Comment">-- strategy, thus forcing `m + n` to reduce:</a>

<a id="plus-eq-+"></a><a id="1435" href="README.Inspect.html#1435" class="Function">plus-eq-+</a> <a id="1445" class="Symbol">:</a> <a id="1447" class="Symbol">∀</a> <a id="1449" href="README.Inspect.html#1449" class="Bound">m</a> <a id="1451" href="README.Inspect.html#1451" class="Bound">n</a> <a id="1453" class="Symbol">→</a> <a id="1455" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="1463" href="README.Inspect.html#1449" class="Bound">m</a> <a id="1465" href="README.Inspect.html#1451" class="Bound">n</a> <a id="1467" class="Symbol">(</a><a id="1468" href="README.Inspect.html#1449" class="Bound">m</a> <a id="1470" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="1472" href="README.Inspect.html#1451" class="Bound">n</a><a id="1473" class="Symbol">)</a>
<a id="1475" href="README.Inspect.html#1435" class="Function">plus-eq-+</a> <a id="1485" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>   <a id="1492" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="1500" class="Symbol">=</a> <a id="1502" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="1507" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1509" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="1514" href="README.Inspect.html#1435" class="Function">plus-eq-+</a> <a id="1524" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>   <a id="1531" class="Symbol">(</a><a id="1532" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1536" href="README.Inspect.html#1536" class="Bound">n</a><a id="1537" class="Symbol">)</a> <a id="1539" class="Symbol">=</a> <a id="1541" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="1546" href="README.Inspect.html#1435" class="Function">plus-eq-+</a> <a id="1556" class="Symbol">(</a><a id="1557" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1561" href="README.Inspect.html#1561" class="Bound">m</a><a id="1562" class="Symbol">)</a> <a id="1564" href="README.Inspect.html#1564" class="Bound">n</a>      <a id="1571" class="Symbol">=</a> <a id="1573" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="1579" class="Comment">-- Or we could attempt to compute `m + n` first and check whether the result</a>
<a id="1656" class="Comment">-- is `zero` or `suc p`. By using `with m + n` and naming the result `p`,</a>
<a id="1730" class="Comment">-- the goal will become `Plus-eq m n p`. We can further refine this definition</a>
<a id="1809" class="Comment">-- by distinguishing two cases like so:</a>

<a id="1850" class="Comment">-- plus-eq-with : ∀ m n → Plus-eq m n (m + n)</a>
<a id="1896" class="Comment">-- plus-eq-with m n with m + n</a>
<a id="1927" class="Comment">-- ... | zero  = {!!}</a>
<a id="1949" class="Comment">-- ... | suc p = {!!}</a>

<a id="1972" class="Comment">-- The problem however is that we have abolutely lost the connection between the</a>
<a id="2053" class="Comment">-- computation `m + n` and its result `p`. Which makes the two goals unprovable:</a>

<a id="2135" class="Comment">-- 1. `m ≡ 0 × n ≡ 0`, with no assumption whatsoever</a>
<a id="2188" class="Comment">-- 2. `m + n ≡ suc p`, with no assumption either</a>

<a id="2238" class="Comment">-- By using the `with` construct, we have generated an auxiliary function that</a>
<a id="2317" class="Comment">-- looks like this:</a>
<a id="2337" class="Comment">-- `plus-eq-with-aux : ∀ m n p → Plus-eq m n p`</a>
<a id="2385" class="Comment">-- when we would have wanted a more precise type of the form:</a>
<a id="2447" class="Comment">-- `plus-eq-aux : ∀ m n p → m + n ≡ p → Plus-eq m n p`.</a>

<a id="2504" class="Comment">-- This is where we can use `inspect`. By using `with f x | inspect f x`,</a>
<a id="2578" class="Comment">-- we get both a `y` which is the result of `f x` and a proof that `f x ≡ y`.</a>
<a id="2656" class="Comment">-- Splitting on the result of `m + n`, we get two cases:</a>

<a id="2714" class="Comment">-- 1. `m ≡ 0 × n ≡ 0` under the assumption that `m + n ≡ zero`</a>
<a id="2777" class="Comment">-- 2. `m + n ≡ suc p` under the assumption that `m + n ≡ suc p`</a>

<a id="2842" class="Comment">-- The first one can be discharged using lemmas from Data.Nat.Properties and</a>
<a id="2919" class="Comment">-- the second one is trivial.</a>

<a id="plus-eq-with"></a><a id="2950" href="README.Inspect.html#2950" class="Function">plus-eq-with</a> <a id="2963" class="Symbol">:</a> <a id="2965" class="Symbol">∀</a> <a id="2967" href="README.Inspect.html#2967" class="Bound">m</a> <a id="2969" href="README.Inspect.html#2969" class="Bound">n</a> <a id="2971" class="Symbol">→</a> <a id="2973" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="2981" href="README.Inspect.html#2967" class="Bound">m</a> <a id="2983" href="README.Inspect.html#2969" class="Bound">n</a> <a id="2985" class="Symbol">(</a><a id="2986" href="README.Inspect.html#2967" class="Bound">m</a> <a id="2988" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2990" href="README.Inspect.html#2969" class="Bound">n</a><a id="2991" class="Symbol">)</a>
<a id="2993" href="README.Inspect.html#2950" class="Function">plus-eq-with</a> <a id="3006" href="README.Inspect.html#3006" class="Bound">m</a> <a id="3008" href="README.Inspect.html#3008" class="Bound">n</a> <a id="3010" class="Keyword">with</a> <a id="3015" href="README.Inspect.html#3006" class="Bound">m</a> <a id="3017" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3019" href="README.Inspect.html#3008" class="Bound">n</a> <a id="3021" class="Symbol">|</a> <a id="3023" href="Relation.Binary.PropositionalEquality.html#4429" class="Function">inspect</a> <a id="3031" class="Symbol">(</a><a id="3032" href="README.Inspect.html#3006" class="Bound">m</a> <a id="3034" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+_</a><a id="3036" class="Symbol">)</a> <a id="3038" href="README.Inspect.html#3008" class="Bound">n</a>
<a id="3040" class="Symbol">...</a> <a id="3044" class="Symbol">|</a> <a id="3046" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="3052" class="Symbol">|</a> <a id="3054" href="Relation.Binary.PropositionalEquality.html#4403" class="InductiveConstructor Operator">[</a> <a id="3056" href="README.Inspect.html#3056" class="Bound">m+n≡0</a>   <a id="3064" href="Relation.Binary.PropositionalEquality.html#4403" class="InductiveConstructor Operator">]</a> <a id="3066" class="Symbol">=</a> <a id="3068" href="Data.Nat.Properties.html#17290" class="Function">m+n≡0⇒m≡0</a> <a id="3078" class="Bound">m</a> <a id="3080" href="README.Inspect.html#3056" class="Bound">m+n≡0</a> <a id="3086" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3088" href="Data.Nat.Properties.html#17356" class="Function">m+n≡0⇒n≡0</a> <a id="3098" class="Bound">m</a> <a id="3100" href="README.Inspect.html#3056" class="Bound">m+n≡0</a>
<a id="3106" class="Symbol">...</a> <a id="3110" class="Symbol">|</a> <a id="3112" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3116" href="README.Inspect.html#3116" class="Bound">p</a> <a id="3118" class="Symbol">|</a> <a id="3120" href="Relation.Binary.PropositionalEquality.html#4403" class="InductiveConstructor Operator">[</a> <a id="3122" href="README.Inspect.html#3122" class="Bound">m+n≡1+p</a> <a id="3130" href="Relation.Binary.PropositionalEquality.html#4403" class="InductiveConstructor Operator">]</a> <a id="3132" class="Symbol">=</a> <a id="3134" href="README.Inspect.html#3122" class="Bound">m+n≡1+p</a>


<a id="3144" class="Comment">------------------------------------------------------------------------</a>
<a id="3217" class="Comment">-- Understanding the implementation of inspect</a>

<a id="3265" class="Comment">-- So why is it that we have to go through the record type `Reveal_·_is_`</a>
<a id="3339" class="Comment">-- and the ̀inspect` function? The fact is: we don&#39;t have to if we write</a>
<a id="3412" class="Comment">-- our own auxiliary lemma:</a>

<a id="plus-eq-aux"></a><a id="3441" href="README.Inspect.html#3441" class="Function">plus-eq-aux</a> <a id="3453" class="Symbol">:</a> <a id="3455" class="Symbol">∀</a> <a id="3457" href="README.Inspect.html#3457" class="Bound">m</a> <a id="3459" href="README.Inspect.html#3459" class="Bound">n</a> <a id="3461" class="Symbol">→</a> <a id="3463" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="3471" href="README.Inspect.html#3457" class="Bound">m</a> <a id="3473" href="README.Inspect.html#3459" class="Bound">n</a> <a id="3475" class="Symbol">(</a><a id="3476" href="README.Inspect.html#3457" class="Bound">m</a> <a id="3478" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3480" href="README.Inspect.html#3459" class="Bound">n</a><a id="3481" class="Symbol">)</a>
<a id="3483" href="README.Inspect.html#3441" class="Function">plus-eq-aux</a> <a id="3495" href="README.Inspect.html#3495" class="Bound">m</a> <a id="3497" href="README.Inspect.html#3497" class="Bound">n</a> <a id="3499" class="Symbol">=</a> <a id="3501" href="README.Inspect.html#3531" class="Function">aux</a> <a id="3505" href="README.Inspect.html#3495" class="Bound">m</a> <a id="3507" href="README.Inspect.html#3497" class="Bound">n</a> <a id="3509" class="Symbol">(</a><a id="3510" href="README.Inspect.html#3495" class="Bound">m</a> <a id="3512" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3514" href="README.Inspect.html#3497" class="Bound">n</a><a id="3515" class="Symbol">)</a> <a id="3517" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3522" class="Keyword">where</a>

  <a id="3531" href="README.Inspect.html#3531" class="Function">aux</a> <a id="3535" class="Symbol">:</a> <a id="3537" class="Symbol">∀</a> <a id="3539" href="README.Inspect.html#3539" class="Bound">m</a> <a id="3541" href="README.Inspect.html#3541" class="Bound">n</a> <a id="3543" href="README.Inspect.html#3543" class="Bound">p</a> <a id="3545" class="Symbol">→</a> <a id="3547" href="README.Inspect.html#3539" class="Bound">m</a> <a id="3549" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3551" href="README.Inspect.html#3541" class="Bound">n</a> <a id="3553" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3555" href="README.Inspect.html#3543" class="Bound">p</a> <a id="3557" class="Symbol">→</a> <a id="3559" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="3567" href="README.Inspect.html#3539" class="Bound">m</a> <a id="3569" href="README.Inspect.html#3541" class="Bound">n</a> <a id="3571" href="README.Inspect.html#3543" class="Bound">p</a>
  <a id="3575" href="README.Inspect.html#3531" class="Function">aux</a> <a id="3579" href="README.Inspect.html#3579" class="Bound">m</a> <a id="3581" href="README.Inspect.html#3581" class="Bound">n</a> <a id="3583" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="3591" href="README.Inspect.html#3591" class="Bound">m+n≡0</a>   <a id="3599" class="Symbol">=</a> <a id="3601" href="Data.Nat.Properties.html#17290" class="Function">m+n≡0⇒m≡0</a> <a id="3611" href="README.Inspect.html#3579" class="Bound">m</a> <a id="3613" href="README.Inspect.html#3591" class="Bound">m+n≡0</a> <a id="3619" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3621" href="Data.Nat.Properties.html#17356" class="Function">m+n≡0⇒n≡0</a> <a id="3631" href="README.Inspect.html#3579" class="Bound">m</a> <a id="3633" href="README.Inspect.html#3591" class="Bound">m+n≡0</a>
  <a id="3641" href="README.Inspect.html#3531" class="Function">aux</a> <a id="3645" href="README.Inspect.html#3645" class="Bound">m</a> <a id="3647" href="README.Inspect.html#3647" class="Bound">n</a> <a id="3649" class="Symbol">(</a><a id="3650" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3654" href="README.Inspect.html#3654" class="Bound">p</a><a id="3655" class="Symbol">)</a> <a id="3657" href="README.Inspect.html#3657" class="Bound">m+n≡1+p</a> <a id="3665" class="Symbol">=</a> <a id="3667" href="README.Inspect.html#3657" class="Bound">m+n≡1+p</a>

<a id="3676" class="Comment">-- The problem is that when we write ̀with f x | pr`, `with` decides to call `y`</a>
<a id="3757" class="Comment">-- the result `f x` and to replace *all* of the occurences of `f x` in the type</a>
<a id="3837" class="Comment">-- of `pr` with `y`. That is to say that if we were to write:</a>

<a id="3900" class="Comment">-- plus-eq-naïve : ∀ m n → Plus-eq m n (m + n)</a>
<a id="3947" class="Comment">-- plus-eq-naïve m n with m + n | refl {x = m + n}</a>
<a id="3998" class="Comment">-- ... | p | eq = {!!}</a>

<a id="4022" class="Comment">-- then `with` would abstract `m + n` as `p` on *both* sides of the equality</a>
<a id="4099" class="Comment">-- proven by `refl` thus giving us the following goal with an extra, useless,</a>
<a id="4177" class="Comment">-- assumption:</a>

<a id="4193" class="Comment">-- 1. `Plus-eq m n p` under the assumption that `p ≡ p`</a>

<a id="4250" class="Comment">-- So how does `inspect` work? The standard library uses a more general version</a>
<a id="4330" class="Comment">-- of the following type and function:</a>

<a id="4370" class="Keyword">record</a> <a id="MyReveal_·_is_"></a><a id="4377" href="README.Inspect.html#4377" class="Record Operator">MyReveal_·_is_</a> <a id="4392" class="Symbol">(</a><a id="4393" href="README.Inspect.html#4393" class="Bound">f</a> <a id="4395" class="Symbol">:</a> <a id="4397" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4399" class="Symbol">→</a> <a id="4401" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="4402" class="Symbol">)</a> <a id="4404" class="Symbol">(</a><a id="4405" href="README.Inspect.html#4405" class="Bound">x</a> <a id="4407" href="README.Inspect.html#4407" class="Bound">y</a> <a id="4409" class="Symbol">:</a> <a id="4411" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="4412" class="Symbol">)</a> <a id="4414" class="Symbol">:</a> <a id="4416" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="4420" class="Keyword">where</a>
  <a id="4428" class="Keyword">constructor</a> <a id="[_]"></a><a id="4440" href="README.Inspect.html#4440" class="InductiveConstructor Operator">[_]</a>
  <a id="4446" class="Keyword">field</a> <a id="MyReveal_·_is_.eq"></a><a id="4452" href="README.Inspect.html#4452" class="Field">eq</a> <a id="4455" class="Symbol">:</a> <a id="4457" href="README.Inspect.html#4393" class="Bound">f</a> <a id="4459" href="README.Inspect.html#4405" class="Bound">x</a> <a id="4461" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4463" href="README.Inspect.html#4407" class="Bound">y</a>

<a id="my-inspect"></a><a id="4466" href="README.Inspect.html#4466" class="Function">my-inspect</a> <a id="4477" class="Symbol">:</a> <a id="4479" class="Symbol">∀</a> <a id="4481" href="README.Inspect.html#4481" class="Bound">f</a> <a id="4483" href="README.Inspect.html#4483" class="Bound">n</a> <a id="4485" class="Symbol">→</a> <a id="4487" href="README.Inspect.html#4377" class="Record Operator">MyReveal</a> <a id="4496" href="README.Inspect.html#4481" class="Bound">f</a> <a id="4498" href="README.Inspect.html#4377" class="Record Operator">·</a> <a id="4500" href="README.Inspect.html#4483" class="Bound">n</a> <a id="4502" href="README.Inspect.html#4377" class="Record Operator">is</a> <a id="4505" class="Symbol">(</a><a id="4506" href="README.Inspect.html#4481" class="Bound">f</a> <a id="4508" href="README.Inspect.html#4483" class="Bound">n</a><a id="4509" class="Symbol">)</a>
<a id="4511" href="README.Inspect.html#4466" class="Function">my-inspect</a> <a id="4522" href="README.Inspect.html#4522" class="Bound">f</a> <a id="4524" href="README.Inspect.html#4524" class="Bound">n</a> <a id="4526" class="Symbol">=</a> <a id="4528" href="README.Inspect.html#4440" class="InductiveConstructor Operator">[</a> <a id="4530" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="4535" href="README.Inspect.html#4440" class="InductiveConstructor Operator">]</a>

<a id="4538" class="Comment">-- Given that `inspect` has the type `∀ f n → Reveal f · n is (f n)`, when we</a>
<a id="4616" class="Comment">-- write `with f n | inspect f n`, the only `f n` that can be abstracted in the</a>
<a id="4696" class="Comment">-- type of `inspect f n` is the third argument to `Reveal_·_is_`.</a>

<a id="4763" class="Comment">-- That is to say that the auxiliary definition generated looks like this:</a>

<a id="plus-eq-reveal"></a><a id="4839" href="README.Inspect.html#4839" class="Function">plus-eq-reveal</a> <a id="4854" class="Symbol">:</a> <a id="4856" class="Symbol">∀</a> <a id="4858" href="README.Inspect.html#4858" class="Bound">m</a> <a id="4860" href="README.Inspect.html#4860" class="Bound">n</a> <a id="4862" class="Symbol">→</a> <a id="4864" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="4872" href="README.Inspect.html#4858" class="Bound">m</a> <a id="4874" href="README.Inspect.html#4860" class="Bound">n</a> <a id="4876" class="Symbol">(</a><a id="4877" href="README.Inspect.html#4858" class="Bound">m</a> <a id="4879" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4881" href="README.Inspect.html#4860" class="Bound">n</a><a id="4882" class="Symbol">)</a>
<a id="4884" href="README.Inspect.html#4839" class="Function">plus-eq-reveal</a> <a id="4899" href="README.Inspect.html#4899" class="Bound">m</a> <a id="4901" href="README.Inspect.html#4901" class="Bound">n</a> <a id="4903" class="Symbol">=</a> <a id="4905" href="README.Inspect.html#4952" class="Function">aux</a> <a id="4909" href="README.Inspect.html#4899" class="Bound">m</a> <a id="4911" href="README.Inspect.html#4901" class="Bound">n</a> <a id="4913" class="Symbol">(</a><a id="4914" href="README.Inspect.html#4899" class="Bound">m</a> <a id="4916" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4918" href="README.Inspect.html#4901" class="Bound">n</a><a id="4919" class="Symbol">)</a> <a id="4921" class="Symbol">(</a><a id="4922" href="README.Inspect.html#4466" class="Function">my-inspect</a> <a id="4933" class="Symbol">(</a><a id="4934" href="README.Inspect.html#4899" class="Bound">m</a> <a id="4936" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+_</a><a id="4938" class="Symbol">)</a> <a id="4940" href="README.Inspect.html#4901" class="Bound">n</a><a id="4941" class="Symbol">)</a> <a id="4943" class="Keyword">where</a>

  <a id="4952" href="README.Inspect.html#4952" class="Function">aux</a> <a id="4956" class="Symbol">:</a> <a id="4958" class="Symbol">∀</a> <a id="4960" href="README.Inspect.html#4960" class="Bound">m</a> <a id="4962" href="README.Inspect.html#4962" class="Bound">n</a> <a id="4964" href="README.Inspect.html#4964" class="Bound">p</a> <a id="4966" class="Symbol">→</a> <a id="4968" href="README.Inspect.html#4377" class="Record Operator">MyReveal</a> <a id="4977" class="Symbol">(</a><a id="4978" href="README.Inspect.html#4960" class="Bound">m</a> <a id="4980" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+_</a><a id="4982" class="Symbol">)</a> <a id="4984" href="README.Inspect.html#4377" class="Record Operator">·</a> <a id="4986" href="README.Inspect.html#4962" class="Bound">n</a> <a id="4988" href="README.Inspect.html#4377" class="Record Operator">is</a> <a id="4991" href="README.Inspect.html#4964" class="Bound">p</a> <a id="4993" class="Symbol">→</a> <a id="4995" href="README.Inspect.html#915" class="Function">Plus-eq</a> <a id="5003" href="README.Inspect.html#4960" class="Bound">m</a> <a id="5005" href="README.Inspect.html#4962" class="Bound">n</a> <a id="5007" href="README.Inspect.html#4964" class="Bound">p</a>
  <a id="5011" href="README.Inspect.html#4952" class="Function">aux</a> <a id="5015" href="README.Inspect.html#5015" class="Bound">m</a> <a id="5017" href="README.Inspect.html#5017" class="Bound">n</a> <a id="5019" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="5027" href="README.Inspect.html#4440" class="InductiveConstructor Operator">[</a> <a id="5029" href="README.Inspect.html#5029" class="Bound">m+n≡0</a>   <a id="5037" href="README.Inspect.html#4440" class="InductiveConstructor Operator">]</a> <a id="5039" class="Symbol">=</a> <a id="5041" href="Data.Nat.Properties.html#17290" class="Function">m+n≡0⇒m≡0</a> <a id="5051" href="README.Inspect.html#5015" class="Bound">m</a> <a id="5053" href="README.Inspect.html#5029" class="Bound">m+n≡0</a> <a id="5059" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5061" href="Data.Nat.Properties.html#17356" class="Function">m+n≡0⇒n≡0</a> <a id="5071" href="README.Inspect.html#5015" class="Bound">m</a> <a id="5073" href="README.Inspect.html#5029" class="Bound">m+n≡0</a>
  <a id="5081" href="README.Inspect.html#4952" class="Function">aux</a> <a id="5085" href="README.Inspect.html#5085" class="Bound">m</a> <a id="5087" href="README.Inspect.html#5087" class="Bound">n</a> <a id="5089" class="Symbol">(</a><a id="5090" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5094" href="README.Inspect.html#5094" class="Bound">p</a><a id="5095" class="Symbol">)</a> <a id="5097" href="README.Inspect.html#4440" class="InductiveConstructor Operator">[</a> <a id="5099" href="README.Inspect.html#5099" class="Bound">m+n≡1+p</a> <a id="5107" href="README.Inspect.html#4440" class="InductiveConstructor Operator">]</a> <a id="5109" class="Symbol">=</a> <a id="5111" href="README.Inspect.html#5099" class="Bound">m+n≡1+p</a>

<a id="5120" class="Comment">-- At the cost of having to unwrap the constructor `[_]` around the equality</a>
<a id="5197" class="Comment">-- we care about, we can keep relying on `with` and avoid having to roll out</a>
<a id="5274" class="Comment">-- handwritten auxiliary definitions.</a>
</pre></body></html>