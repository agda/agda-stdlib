<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--without-K</a> <a id="296" class="Pragma">--safe</a> <a id="303" class="Symbol">#-}</a>

<a id="308" class="Keyword">module</a> <a id="315" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="333" class="Keyword">where</a>

<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="Agda.Builtin.Reflection.html" class="Module">Agda.Builtin.Reflection</a>

<a id="377" class="Keyword">open</a> <a id="382" class="Keyword">import</a> <a id="389" href="Algebra.html" class="Module">Algebra</a>
<a id="397" class="Keyword">open</a> <a id="402" class="Keyword">import</a> <a id="409" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="420" class="Symbol">as</a> <a id="423" class="Module">Fin</a>   <a id="429" class="Keyword">using</a> <a id="435" class="Symbol">(</a><a id="436" href="Data.Fin.Base.html#1138" class="Datatype">Fin</a><a id="439" class="Symbol">)</a>
<a id="441" class="Keyword">open</a> <a id="446" class="Keyword">import</a> <a id="453" href="Data.Vec.html" class="Module">Data.Vec</a>   <a id="464" class="Symbol">as</a> <a id="467" class="Module">Vec</a>   <a id="473" class="Keyword">using</a> <a id="479" class="Symbol">(</a><a id="480" href="Data.Vec.Base.html#959" class="Datatype">Vec</a><a id="483" class="Symbol">;</a> <a id="485" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">_∷_</a><a id="488" class="Symbol">;</a> <a id="490" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a><a id="492" class="Symbol">)</a>
<a id="494" class="Keyword">open</a> <a id="499" class="Keyword">import</a> <a id="506" href="Data.List.html" class="Module">Data.List</a>  <a id="517" class="Symbol">as</a> <a id="520" class="Module">List</a>  <a id="526" class="Keyword">using</a> <a id="532" class="Symbol">(</a><a id="533" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="537" class="Symbol">;</a> <a id="539" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="542" class="Symbol">;</a> <a id="544" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="546" class="Symbol">)</a>
<a id="548" class="Keyword">open</a> <a id="553" class="Keyword">import</a> <a id="560" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="576" class="Symbol">as</a> <a id="579" class="Module">Maybe</a> <a id="585" class="Keyword">using</a> <a id="591" class="Symbol">(</a><a id="592" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="597" class="Symbol">;</a> <a id="599" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="603" class="Symbol">;</a> <a id="605" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="612" class="Symbol">;</a> <a id="614" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a><a id="623" class="Symbol">)</a>
<a id="625" class="Keyword">open</a> <a id="630" class="Keyword">import</a> <a id="637" href="Data.Nat.html" class="Module">Data.Nat</a>            <a id="657" class="Keyword">using</a> <a id="663" class="Symbol">(</a><a id="664" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="665" class="Symbol">;</a> <a id="667" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="670" class="Symbol">;</a> <a id="672" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="676" class="Symbol">;</a> <a id="678" href="Data.Nat.Base.html#1296" class="Primitive Operator">_&lt;ᵇ_</a><a id="682" class="Symbol">)</a>
<a id="684" class="Keyword">open</a> <a id="689" class="Keyword">import</a> <a id="696" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a> <a id="716" class="Keyword">using</a> <a id="722" class="Symbol">(</a><a id="723" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a><a id="729" class="Symbol">;</a> <a id="731" href="Data.Nat.Reflection.html#637" class="Function">toFinTerm</a><a id="740" class="Symbol">)</a>
<a id="742" class="Keyword">open</a> <a id="747" class="Keyword">import</a> <a id="754" href="Data.Bool.html" class="Module">Data.Bool</a>           <a id="774" class="Keyword">using</a> <a id="780" class="Symbol">(</a><a id="781" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="785" class="Symbol">;</a> <a id="787" href="Data.Bool.Base.html#1283" class="Function Operator">if_then_else_</a><a id="800" class="Symbol">;</a> <a id="802" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="806" class="Symbol">;</a> <a id="808" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="813" class="Symbol">)</a>
<a id="815" class="Keyword">open</a> <a id="820" class="Keyword">import</a> <a id="827" href="Data.Unit.html" class="Module">Data.Unit</a>           <a id="847" class="Keyword">using</a> <a id="853" class="Symbol">(</a><a id="854" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="855" class="Symbol">)</a>
<a id="857" class="Keyword">open</a> <a id="862" class="Keyword">import</a> <a id="869" href="Data.String.html" class="Module">Data.String</a>         <a id="889" class="Keyword">using</a> <a id="895" class="Symbol">(</a><a id="896" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="902" class="Symbol">)</a>
<a id="904" class="Keyword">open</a> <a id="909" class="Keyword">import</a> <a id="916" href="Data.Product.html" class="Module">Data.Product</a>        <a id="936" class="Keyword">using</a> <a id="942" class="Symbol">(</a><a id="943" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="946" class="Symbol">)</a>
<a id="948" class="Keyword">open</a> <a id="953" class="Keyword">import</a> <a id="960" href="Function.html" class="Module">Function</a>
<a id="969" class="Keyword">open</a> <a id="974" class="Keyword">import</a> <a id="981" href="Reflection.Argument.html" class="Module">Reflection.Argument</a>
<a id="1001" class="Keyword">open</a> <a id="1006" class="Keyword">import</a> <a id="1013" href="Reflection.Term.html" class="Module">Reflection.Term</a>
<a id="1029" class="Keyword">open</a> <a id="1034" class="Keyword">import</a> <a id="1041" href="Reflection.TypeChecking.Monad.Syntax.html" class="Module">Reflection.TypeChecking.Monad.Syntax</a>

<a id="1079" class="Keyword">open</a> <a id="1084" class="Keyword">import</a> <a id="1091" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1123" class="Keyword">renaming</a> <a id="1132" class="Symbol">(</a><a id="1133" href="Tactic.RingSolver.NonReflective.html#2889" class="Function">solve</a> <a id="1139" class="Symbol">to</a> <a id="1142" class="Function">solve-fn</a><a id="1150" class="Symbol">)</a>
<a id="1152" class="Keyword">open</a> <a id="1157" class="Keyword">import</a> <a id="1164" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1209" class="Keyword">open</a> <a id="1214" class="Keyword">import</a> <a id="1221" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1251" class="Symbol">as</a> <a id="1254" class="Module">NatSet</a>
<a id="1261" class="Keyword">open</a> <a id="1266" class="Keyword">import</a> <a id="1273" href="Tactic.RingSolver.Core.ReflectionHelp.html" class="Module">Tactic.RingSolver.Core.ReflectionHelp</a>

<a id="1312" class="Keyword">open</a> <a id="1317" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1241" class="Module">AlmostCommutativeRing</a>

<a id="1340" class="Comment">------------------------------------------------------------------------</a>
<a id="1413" class="Comment">-- Processing</a>
<a id="1427" class="Comment">------------------------------------------------------------------------</a>

<a id="1501" class="Keyword">private</a>
  <a id="1511" class="Keyword">record</a> <a id="RingNames"></a><a id="1518" href="Tactic.RingSolver.html#1518" class="Record">RingNames</a> <a id="1528" class="Symbol">:</a> <a id="1530" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1534" class="Keyword">where</a>
    <a id="1544" class="Keyword">constructor</a> <a id="+⇒_*⇒_^⇒_-⇒_"></a><a id="1556" href="Tactic.RingSolver.html#1556" class="InductiveConstructor Operator">+⇒_*⇒_^⇒_-⇒_</a>
    <a id="1573" class="Keyword">field</a>
      <a id="RingNames.+′"></a><a id="1585" href="Tactic.RingSolver.html#1585" class="Field">+′</a> <a id="RingNames.*′"></a><a id="1588" href="Tactic.RingSolver.html#1588" class="Field">*′</a> <a id="RingNames.^′"></a><a id="1591" href="Tactic.RingSolver.html#1591" class="Field">^′</a> <a id="RingNames.-′"></a><a id="1594" href="Tactic.RingSolver.html#1594" class="Field">-′</a> <a id="1597" class="Symbol">:</a> <a id="1599" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1605" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a>

  <a id="checkIsRing"></a><a id="1613" href="Tactic.RingSolver.html#1613" class="Function">checkIsRing</a> <a id="1625" class="Symbol">:</a> <a id="1627" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="1632" class="Symbol">→</a> <a id="1634" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="1637" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
  <a id="1644" href="Tactic.RingSolver.html#1613" class="Function">checkIsRing</a> <a id="1656" href="Tactic.RingSolver.html#1656" class="Bound">ring</a> <a id="1661" class="Symbol">=</a> <a id="1663" href="Agda.Builtin.Reflection.html#7812" class="Postulate">checkType</a> <a id="1673" href="Tactic.RingSolver.html#1656" class="Bound">ring</a> <a id="1678" class="Symbol">(</a><a id="1679" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="1683" class="Symbol">(</a><a id="1684" class="Keyword">quote</a> <a id="1690" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1241" class="Record">AlmostCommutativeRing</a><a id="1711" class="Symbol">)</a> <a id="1713" class="Symbol">(</a><a id="1714" class="Number">2</a> <a id="1716" href="Reflection.Term.html#2442" class="Function Operator">⋯⟨∷⟩</a> <a id="1721" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="1723" class="Symbol">))</a>

  <a id="getVariableIDs"></a><a id="1729" href="Tactic.RingSolver.html#1729" class="Function">getVariableIDs</a> <a id="1744" class="Symbol">:</a> <a id="1746" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="1751" class="Symbol">→</a> <a id="1753" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1759" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
  <a id="1768" href="Tactic.RingSolver.html#1729" class="Function">getVariableIDs</a> <a id="1783" class="Symbol">=</a> <a id="1785" href="Tactic.RingSolver.html#1805" class="Function">go</a> <a id="1788" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
    <a id="1795" class="Keyword">where</a>
    <a id="1805" href="Tactic.RingSolver.html#1805" class="Function">go</a> <a id="1808" class="Symbol">:</a> <a id="1810" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="1817" class="Symbol">→</a> <a id="1819" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="1824" class="Symbol">→</a> <a id="1826" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1832" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
    <a id="1843" href="Tactic.RingSolver.html#1805" class="Function">go</a> <a id="1846" href="Tactic.RingSolver.html#1846" class="Bound">t</a> <a id="1848" class="Symbol">(</a><a id="1849" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="1853" class="Symbol">(</a><a id="1854" class="Keyword">quote</a> <a id="1860" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">List._∷_</a><a id="1868" class="Symbol">)</a> <a id="1870" class="Symbol">(_</a> <a id="1873" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1875" class="Symbol">_</a> <a id="1877" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1879" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="1883" href="Tactic.RingSolver.html#1883" class="Bound">i</a> <a id="1885" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="1888" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="1892" href="Tactic.RingSolver.html#1892" class="Bound">xs</a> <a id="1895" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="1899" class="Symbol">_))</a> <a id="1903" class="Symbol">=</a> <a id="1905" href="Tactic.RingSolver.html#1805" class="Function">go</a> <a id="1908" class="Symbol">(</a><a id="1909" href="Tactic.RingSolver.Core.NatSet.html#2233" class="Function">insert</a> <a id="1916" href="Tactic.RingSolver.html#1883" class="Bound">i</a> <a id="1918" href="Tactic.RingSolver.html#1846" class="Bound">t</a><a id="1919" class="Symbol">)</a> <a id="1921" href="Tactic.RingSolver.html#1892" class="Bound">xs</a>
    <a id="1928" href="Tactic.RingSolver.html#1805" class="Function">go</a> <a id="1931" href="Tactic.RingSolver.html#1931" class="Bound">t</a> <a id="1933" class="Symbol">(</a><a id="1934" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="1938" class="Symbol">(</a><a id="1939" class="Keyword">quote</a> <a id="1945" href="Agda.Builtin.List.html#185" class="InductiveConstructor">List.List.[]</a><a id="1957" class="Symbol">)</a> <a id="1959" class="Symbol">_)</a>                           <a id="1988" class="Symbol">=</a> <a id="1990" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="1995" href="Tactic.RingSolver.html#1931" class="Bound">t</a>
    <a id="2001" href="Tactic.RingSolver.html#1805" class="CatchallClause Function">go</a><a id="2003" class="CatchallClause"> </a><a id="2004" class="CatchallClause Symbol">_</a><a id="2005" class="CatchallClause"> </a><a id="2006" class="CatchallClause Symbol">_</a>                                                      <a id="2061" class="Symbol">=</a> <a id="2063" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="2074" class="Keyword">module</a> <a id="OverRing"></a><a id="2081" href="Tactic.RingSolver.html#2081" class="Module">OverRing</a> <a id="2090" class="Symbol">(</a><a id="2091" href="Tactic.RingSolver.html#2091" class="Bound">ring</a> <a id="2096" class="Symbol">:</a> <a id="2098" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="2102" class="Symbol">)</a> <a id="2104" class="Keyword">where</a>

    <a id="2115" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
    <a id="2185" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
    <a id="2254" class="Comment">-- the required ring arguments</a>
    <a id="2289" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
    <a id="2339" class="Keyword">infixr</a> <a id="2346" class="Number">6</a> <a id="2348" href="Tactic.RingSolver.html#2358" class="Function Operator">_$ʳ_</a>

    <a id="OverRing._$ʳ_"></a><a id="2358" href="Tactic.RingSolver.html#2358" class="Function Operator">_$ʳ_</a> <a id="2363" class="Symbol">:</a> <a id="2365" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="2370" class="Symbol">→</a> <a id="2372" href="Reflection.Argument.html#1325" class="Function">Args</a> <a id="2377" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="2382" class="Symbol">→</a> <a id="2384" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
    <a id="2393" href="Tactic.RingSolver.html#2393" class="Bound">nm</a> <a id="2396" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="2399" href="Tactic.RingSolver.html#2399" class="Bound">args</a> <a id="2404" class="Symbol">=</a> <a id="2406" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2410" href="Tactic.RingSolver.html#2393" class="Bound">nm</a> <a id="2413" class="Symbol">(</a><a id="2414" class="Number">2</a> <a id="2416" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a> <a id="2421" href="Tactic.RingSolver.html#2091" class="Bound">ring</a> <a id="2426" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="2430" href="Tactic.RingSolver.html#2399" class="Bound">args</a><a id="2434" class="Symbol">)</a>

    <a id="OverRing.checkIsListOfVariables"></a><a id="2441" href="Tactic.RingSolver.html#2441" class="Function">checkIsListOfVariables</a> <a id="2464" class="Symbol">:</a> <a id="2466" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="2471" class="Symbol">→</a> <a id="2473" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="2476" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
    <a id="2485" href="Tactic.RingSolver.html#2441" class="Function">checkIsListOfVariables</a> <a id="2508" href="Tactic.RingSolver.html#2508" class="Bound">xs</a> <a id="2511" class="Symbol">=</a>
      <a id="2519" href="Agda.Builtin.Reflection.html#7812" class="Postulate">checkType</a> <a id="2529" href="Tactic.RingSolver.html#2508" class="Bound">xs</a> <a id="2532" class="Symbol">(</a><a id="2533" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2537" class="Symbol">(</a><a id="2538" class="Keyword">quote</a> <a id="2544" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="2548" class="Symbol">)</a> <a id="2550" class="Symbol">(</a><a id="2551" class="Number">1</a> <a id="2553" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a> <a id="2558" class="Symbol">(</a><a id="2559" class="Keyword">quote</a> <a id="2565" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1379" class="Field">Carrier</a> <a id="2573" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="2576" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="2578" class="Symbol">)</a> <a id="2580" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="2584" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="2586" class="Symbol">))</a> <a id="2589" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="2593" href="Agda.Builtin.Reflection.html#7855" class="Postulate">normalise</a>

    <a id="OverRing.getFieldName"></a><a id="2608" href="Tactic.RingSolver.html#2608" class="Function">getFieldName</a> <a id="2621" class="Symbol">:</a> <a id="2623" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="2628" class="Symbol">→</a> <a id="2630" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="2633" class="Symbol">(</a><a id="2634" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2640" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a><a id="2644" class="Symbol">)</a>
    <a id="2650" href="Tactic.RingSolver.html#2608" class="Function">getFieldName</a> <a id="2663" href="Tactic.RingSolver.html#2663" class="Bound">nm</a> <a id="2666" class="Symbol">=</a> <a id="2668" href="Agda.Builtin.Reflection.html#7855" class="Postulate">normalise</a> <a id="2678" class="Symbol">(</a><a id="2679" href="Tactic.RingSolver.html#2663" class="Bound">nm</a> <a id="2682" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="2685" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="2687" class="Symbol">)</a> <a id="2689" href="Reflection.TypeChecking.Monad.Syntax.html#1154" class="Function Operator">&lt;&amp;&gt;</a> <a id="2693" class="Symbol">λ</a> <a id="2695" class="Keyword">where</a>
      <a id="2707" class="Symbol">(</a><a id="2708" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2712" href="Tactic.RingSolver.html#2712" class="Bound">f</a> <a id="2714" href="Tactic.RingSolver.html#2714" class="Bound">args</a><a id="2718" class="Symbol">)</a> <a id="2720" class="Symbol">→</a> <a id="2722" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2727" href="Tactic.RingSolver.html#2712" class="Bound">f</a>
      <a id="2735" class="CatchallClause Symbol">_</a>            <a id="2748" class="Symbol">→</a> <a id="2750" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

    <a id="OverRing.getRingOperatorNames"></a><a id="2763" href="Tactic.RingSolver.html#2763" class="Function">getRingOperatorNames</a> <a id="2784" class="Symbol">:</a> <a id="2786" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="2789" href="Tactic.RingSolver.html#1518" class="Record">RingNames</a>
    <a id="2803" href="Tactic.RingSolver.html#2763" class="Function">getRingOperatorNames</a> <a id="2824" class="Symbol">=</a> <a id="2826" class="Symbol">⦇</a>
      <a id="2834" href="Tactic.RingSolver.html#1556" class="InductiveConstructor Operator">+⇒</a> <a id="2837" href="Tactic.RingSolver.html#2608" class="Function">getFieldName</a> <a id="2850" class="Symbol">(</a><a id="2851" class="Keyword">quote</a> <a id="2857" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1459" class="Field Operator">_+_</a><a id="2860" class="Symbol">)</a>
      <a id="2868" href="Tactic.RingSolver.html#1556" class="InductiveConstructor Operator">*⇒</a> <a id="2871" href="Tactic.RingSolver.html#2608" class="Function">getFieldName</a> <a id="2884" class="Symbol">(</a><a id="2885" class="Keyword">quote</a> <a id="2891" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1501" class="Field Operator">_*_</a><a id="2894" class="Symbol">)</a>
      <a id="2902" href="Tactic.RingSolver.html#1556" class="InductiveConstructor Operator">^⇒</a> <a id="2905" href="Tactic.RingSolver.html#2608" class="Function">getFieldName</a> <a id="2918" class="Symbol">(</a><a id="2919" class="Keyword">quote</a> <a id="2925" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2401" class="Function Operator">_^_</a><a id="2928" class="Symbol">)</a>
      <a id="2936" href="Tactic.RingSolver.html#1556" class="InductiveConstructor Operator">-⇒</a> <a id="2939" href="Tactic.RingSolver.html#2608" class="Function">getFieldName</a> <a id="2952" class="Symbol">(</a><a id="2953" class="Keyword">quote</a> <a id="2959" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1543" class="Field Operator">-_</a><a id="2961" class="Symbol">)</a>
      <a id="2969" class="Symbol">⦈</a>

    <a id="2976" class="Keyword">module</a> <a id="2983" href="Tactic.RingSolver.html#2983" class="Module">_</a> <a id="2985" class="Symbol">(</a><a id="2986" href="Tactic.RingSolver.html#2986" class="Bound">nms</a> <a id="2990" class="Symbol">:</a> <a id="2992" href="Tactic.RingSolver.html#1518" class="Record">RingNames</a><a id="3001" class="Symbol">)</a> <a id="3003" class="Symbol">(</a><a id="3004" href="Tactic.RingSolver.html#3004" class="Bound">numVars</a> <a id="3012" class="Symbol">:</a> <a id="3014" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3015" class="Symbol">)</a> <a id="3017" class="Keyword">where</a>
      <a id="3029" class="Keyword">open</a> <a id="3034" href="Tactic.RingSolver.html#1518" class="Module">RingNames</a> <a id="3044" href="Tactic.RingSolver.html#2986" class="Bound">nms</a>

      <a id="3055" class="Comment">-- This function applies the hidden arguments that the constructors</a>
      <a id="3129" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
      <a id="3206" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
      <a id="3279" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
      <a id="3352" class="Comment">-- make things easier we supply the third because we know it.</a>
      <a id="3420" class="Keyword">infix</a> <a id="3426" class="Number">-1</a> <a id="3429" href="Tactic.RingSolver.html#3440" class="Function Operator">_$ᵉ_</a>
      <a id="3440" href="Tactic.RingSolver.html#3440" class="Function Operator">_$ᵉ_</a> <a id="3445" class="Symbol">:</a> <a id="3447" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="3452" class="Symbol">→</a> <a id="3454" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="3459" class="Symbol">(</a><a id="3460" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="3464" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="3468" class="Symbol">)</a> <a id="3470" class="Symbol">→</a> <a id="3472" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
      <a id="3483" href="Tactic.RingSolver.html#3483" class="Bound">e</a> <a id="3485" href="Tactic.RingSolver.html#3440" class="Function Operator">$ᵉ</a> <a id="3488" href="Tactic.RingSolver.html#3488" class="Bound">xs</a> <a id="3491" class="Symbol">=</a> <a id="3493" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="3497" href="Tactic.RingSolver.html#3483" class="Bound">e</a> <a id="3499" class="Symbol">(</a><a id="3500" class="Number">1</a> <a id="3502" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a> <a id="3507" class="Keyword">quote</a> <a id="3513" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1379" class="Field">Carrier</a> <a id="3521" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="3524" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="3527" href="Reflection.Argument.html#1449" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="3531" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a> <a id="3538" href="Tactic.RingSolver.html#3004" class="Bound">numVars</a> <a id="3546" href="Reflection.Argument.html#1449" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="3550" href="Tactic.RingSolver.html#3488" class="Bound">xs</a><a id="3552" class="Symbol">)</a>

      <a id="3561" class="Comment">-- A constant expression.</a>
      <a id="3593" href="Tactic.RingSolver.html#3593" class="Function">Κ′</a> <a id="3596" class="Symbol">:</a> <a id="3598" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="3603" class="Symbol">→</a> <a id="3605" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
      <a id="3616" href="Tactic.RingSolver.html#3593" class="Function">Κ′</a> <a id="3619" href="Tactic.RingSolver.html#3619" class="Bound">x</a> <a id="3621" class="Symbol">=</a> <a id="3623" class="Keyword">quote</a> <a id="3629" href="Tactic.RingSolver.Core.Expression.html#538" class="InductiveConstructor">Κ</a> <a id="3631" href="Tactic.RingSolver.html#3440" class="Function Operator">$ᵉ</a> <a id="3634" class="Symbol">(</a><a id="3635" href="Tactic.RingSolver.html#3619" class="Bound">x</a> <a id="3637" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3641" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3643" class="Symbol">)</a>

      <a id="3652" class="Keyword">infix</a> <a id="3658" class="Number">4</a> <a id="3660" href="Tactic.RingSolver.html#3671" class="Function Operator">_⇓≟_</a>
      <a id="3671" href="Tactic.RingSolver.html#3671" class="Function Operator">_⇓≟_</a> <a id="3676" class="Symbol">:</a> <a id="3678" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="3684" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="3689" class="Symbol">→</a> <a id="3691" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="3696" class="Symbol">→</a> <a id="3698" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
      <a id="3709" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="3717" href="Tactic.RingSolver.html#3671" class="Function Operator">⇓≟</a> <a id="3720" class="Symbol">_</a> <a id="3722" class="Symbol">=</a> <a id="3724" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
      <a id="3736" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3741" href="Tactic.RingSolver.html#3741" class="Bound">x</a>  <a id="3744" href="Tactic.RingSolver.html#3671" class="Function Operator">⇓≟</a> <a id="3747" href="Tactic.RingSolver.html#3747" class="Bound">y</a> <a id="3749" class="Symbol">=</a> <a id="3751" href="Agda.Builtin.Reflection.html#540" class="Primitive">primQNameEquality</a> <a id="3769" href="Tactic.RingSolver.html#3741" class="Bound">x</a> <a id="3771" href="Tactic.RingSolver.html#3747" class="Bound">y</a>
      <a id="3779" class="Symbol">{-#</a> <a id="3783" class="Keyword">INLINE</a> <a id="3790" href="Tactic.RingSolver.html#3671" class="Function Operator">_⇓≟_</a> <a id="3795" class="Symbol">#-}</a>

      <a id="3806" class="Keyword">module</a> <a id="ToExpr"></a><a id="3813" href="Tactic.RingSolver.html#3813" class="Module">ToExpr</a> <a id="3820" class="Symbol">(</a><a id="3821" href="Tactic.RingSolver.html#3821" class="Bound">Ι′</a> <a id="3824" class="Symbol">:</a> <a id="3826" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="3828" class="Symbol">→</a> <a id="3830" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="3836" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="3840" class="Symbol">)</a> <a id="3842" class="Keyword">where</a>
        <a id="3856" class="Keyword">mutual</a>
          <a id="3873" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
          <a id="3946" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
          <a id="4020" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
          <a id="4093" class="Comment">-- by just taking the last two explicit arguments.</a>
          <a id="4154" href="Tactic.RingSolver.html#4154" class="Function Operator">E⟨_⟩₂</a> <a id="4160" class="Symbol">:</a> <a id="4162" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="4167" class="Symbol">→</a> <a id="4169" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4174" class="Symbol">(</a><a id="4175" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="4179" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="4183" class="Symbol">)</a> <a id="4185" class="Symbol">→</a> <a id="4187" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
          <a id="4202" href="Tactic.RingSolver.html#4154" class="Function Operator">E⟨</a> <a id="4205" href="Tactic.RingSolver.html#4205" class="Bound">nm</a> <a id="4208" href="Tactic.RingSolver.html#4154" class="Function Operator">⟩₂</a> <a id="4211" class="Symbol">(</a><a id="4212" href="Tactic.RingSolver.html#4212" class="Bound">x</a> <a id="4214" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4218" href="Tactic.RingSolver.html#4218" class="Bound">y</a> <a id="4220" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4224" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4226" class="Symbol">)</a> <a id="4228" class="Symbol">=</a> <a id="4230" href="Tactic.RingSolver.html#4205" class="Bound">nm</a> <a id="4233" href="Tactic.RingSolver.html#3440" class="Function Operator">$ᵉ</a> <a id="4236" class="Symbol">(</a><a id="4237" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="4239" href="Tactic.RingSolver.html#4212" class="Bound">x</a> <a id="4241" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4245" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="4247" href="Tactic.RingSolver.html#4218" class="Bound">y</a> <a id="4249" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4253" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4255" class="Symbol">)</a>
          <a id="4267" href="Tactic.RingSolver.html#4154" class="CatchallClause Function Operator">E⟨</a><a id="4269" class="CatchallClause"> </a><a id="4270" href="Tactic.RingSolver.html#4270" class="CatchallClause Bound">nm</a><a id="4272" class="CatchallClause"> </a><a id="4273" href="Tactic.RingSolver.html#4154" class="CatchallClause Function Operator">⟩₂</a><a id="4275" class="CatchallClause"> </a><a id="4276" class="CatchallClause Symbol">(</a><a id="4277" href="Tactic.RingSolver.html#4277" class="CatchallClause Bound">x</a><a id="4278" class="CatchallClause"> </a><a id="4279" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4280" class="CatchallClause"> </a><a id="4281" href="Tactic.RingSolver.html#4281" class="CatchallClause Bound">xs</a><a id="4283" class="CatchallClause Symbol">)</a>         <a id="4293" class="Symbol">=</a> <a id="4295" href="Tactic.RingSolver.html#4154" class="Function Operator">E⟨</a> <a id="4298" href="Tactic.RingSolver.html#4270" class="Bound">nm</a> <a id="4301" href="Tactic.RingSolver.html#4154" class="Function Operator">⟩₂</a> <a id="4304" href="Tactic.RingSolver.html#4281" class="Bound">xs</a>
          <a id="4317" href="Tactic.RingSolver.html#4154" class="CatchallClause Function Operator">E⟨</a><a id="4319" class="CatchallClause"> </a><a id="4320" href="Tactic.RingSolver.html#4320" class="CatchallClause Bound">nm</a><a id="4322" class="CatchallClause"> </a><a id="4323" href="Tactic.RingSolver.html#4154" class="CatchallClause Function Operator">⟩₂</a><a id="4325" class="CatchallClause"> </a><a id="4326" class="CatchallClause Symbol">_</a>                <a id="4343" class="Symbol">=</a> <a id="4345" href="Agda.Builtin.Reflection.html#4804" class="InductiveConstructor">unknown</a>

          <a id="4364" href="Tactic.RingSolver.html#4364" class="Function Operator">E⟨_⟩₁</a> <a id="4370" class="Symbol">:</a> <a id="4372" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="4377" class="Symbol">→</a> <a id="4379" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4384" class="Symbol">(</a><a id="4385" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="4389" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="4393" class="Symbol">)</a> <a id="4395" class="Symbol">→</a> <a id="4397" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
          <a id="4412" href="Tactic.RingSolver.html#4364" class="Function Operator">E⟨</a> <a id="4415" href="Tactic.RingSolver.html#4415" class="Bound">nm</a> <a id="4418" href="Tactic.RingSolver.html#4364" class="Function Operator">⟩₁</a> <a id="4421" class="Symbol">(</a><a id="4422" href="Tactic.RingSolver.html#4422" class="Bound">x</a> <a id="4424" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4428" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4430" class="Symbol">)</a> <a id="4432" class="Symbol">=</a> <a id="4434" href="Tactic.RingSolver.html#4415" class="Bound">nm</a> <a id="4437" href="Tactic.RingSolver.html#3440" class="Function Operator">$ᵉ</a> <a id="4440" class="Symbol">(</a><a id="4441" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="4443" href="Tactic.RingSolver.html#4422" class="Bound">x</a> <a id="4445" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4449" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4451" class="Symbol">)</a>
          <a id="4463" href="Tactic.RingSolver.html#4364" class="CatchallClause Function Operator">E⟨</a><a id="4465" class="CatchallClause"> </a><a id="4466" href="Tactic.RingSolver.html#4466" class="CatchallClause Bound">nm</a><a id="4468" class="CatchallClause"> </a><a id="4469" href="Tactic.RingSolver.html#4364" class="CatchallClause Function Operator">⟩₁</a><a id="4471" class="CatchallClause"> </a><a id="4472" class="CatchallClause Symbol">(</a><a id="4473" href="Tactic.RingSolver.html#4473" class="CatchallClause Bound">x</a><a id="4474" class="CatchallClause"> </a><a id="4475" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4476" class="CatchallClause"> </a><a id="4477" href="Tactic.RingSolver.html#4477" class="CatchallClause Bound">xs</a><a id="4479" class="CatchallClause Symbol">)</a>   <a id="4483" class="Symbol">=</a> <a id="4485" href="Tactic.RingSolver.html#4364" class="Function Operator">E⟨</a> <a id="4488" href="Tactic.RingSolver.html#4466" class="Bound">nm</a> <a id="4491" href="Tactic.RingSolver.html#4364" class="Function Operator">⟩₁</a> <a id="4494" href="Tactic.RingSolver.html#4477" class="Bound">xs</a>
          <a id="4507" href="Tactic.RingSolver.html#4364" class="CatchallClause Function Operator">E⟨</a><a id="4509" class="CatchallClause"> </a><a id="4510" class="CatchallClause Symbol">_</a><a id="4511" class="CatchallClause">  </a><a id="4513" href="Tactic.RingSolver.html#4364" class="CatchallClause Function Operator">⟩₁</a><a id="4515" class="CatchallClause"> </a><a id="4516" class="CatchallClause Symbol">_</a>          <a id="4527" class="Symbol">=</a> <a id="4529" href="Agda.Builtin.Reflection.html#4804" class="InductiveConstructor">unknown</a>

          <a id="4548" href="Tactic.RingSolver.html#4548" class="Function">E⟨^⟩</a> <a id="4553" class="Symbol">:</a> <a id="4555" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4560" class="Symbol">(</a><a id="4561" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="4565" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="4569" class="Symbol">)</a> <a id="4571" class="Symbol">→</a> <a id="4573" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
          <a id="4588" href="Tactic.RingSolver.html#4548" class="Function">E⟨^⟩</a> <a id="4593" class="Symbol">(</a><a id="4594" href="Tactic.RingSolver.html#4594" class="Bound">x</a> <a id="4596" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4600" href="Tactic.RingSolver.html#4600" class="Bound">y</a> <a id="4602" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4606" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4608" class="Symbol">)</a> <a id="4610" class="Symbol">=</a> <a id="4612" class="Keyword">quote</a> <a id="4618" href="Tactic.RingSolver.Core.Expression.html#748" class="InductiveConstructor Operator">_⊛_</a> <a id="4622" href="Tactic.RingSolver.html#3440" class="Function Operator">$ᵉ</a> <a id="4625" class="Symbol">(</a><a id="4626" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="4628" href="Tactic.RingSolver.html#4594" class="Bound">x</a> <a id="4630" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4634" href="Tactic.RingSolver.html#4600" class="Bound">y</a> <a id="4636" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4640" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4642" class="Symbol">)</a>
          <a id="4654" href="Tactic.RingSolver.html#4548" class="CatchallClause Function">E⟨^⟩</a><a id="4658" class="CatchallClause"> </a><a id="4659" class="CatchallClause Symbol">(</a><a id="4660" href="Tactic.RingSolver.html#4660" class="CatchallClause Bound">x</a><a id="4661" class="CatchallClause"> </a><a id="4662" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4663" class="CatchallClause"> </a><a id="4664" href="Tactic.RingSolver.html#4664" class="CatchallClause Bound">xs</a><a id="4666" class="CatchallClause Symbol">)</a>         <a id="4676" class="Symbol">=</a> <a id="4678" href="Tactic.RingSolver.html#4548" class="Function">E⟨^⟩</a> <a id="4683" href="Tactic.RingSolver.html#4664" class="Bound">xs</a>
          <a id="4696" href="Tactic.RingSolver.html#4548" class="CatchallClause Function">E⟨^⟩</a><a id="4700" class="CatchallClause"> </a><a id="4701" class="CatchallClause Symbol">_</a>                <a id="4718" class="Symbol">=</a> <a id="4720" href="Agda.Builtin.Reflection.html#4804" class="InductiveConstructor">unknown</a>

          <a id="4739" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
          <a id="4813" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
          <a id="4884" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
          <a id="4958" class="Comment">-- might look for its constructors: however, we want to deal with</a>
          <a id="5034" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
          <a id="5109" class="Comment">-- Term type contained type information we might be able to</a>
          <a id="5179" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
          <a id="5228" class="Comment">--</a>
          <a id="5241" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
          <a id="5318" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
          <a id="5394" class="Comment">-- will just assume that it has a constant expression.</a>
          <a id="5459" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="5461" class="Symbol">:</a> <a id="5463" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="5468" class="Symbol">→</a> <a id="5470" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
          <a id="5485" class="Comment">-- Recognise the ring&#39;s fields</a>
          <a id="5526" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="5528" class="Symbol">(</a><a id="5529" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="5533" class="Symbol">(</a><a id="5534" class="Keyword">quote</a> <a id="5540" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1459" class="Field Operator">_+_</a><a id="5543" class="Symbol">)</a> <a id="5545" href="Tactic.RingSolver.html#5545" class="Bound">xs</a><a id="5547" class="Symbol">)</a> <a id="5549" class="Symbol">=</a> <a id="5551" href="Tactic.RingSolver.html#4154" class="Function Operator">E⟨</a> <a id="5554" class="Keyword">quote</a> <a id="5560" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="5564" href="Tactic.RingSolver.html#4154" class="Function Operator">⟩₂</a> <a id="5567" href="Tactic.RingSolver.html#5545" class="Bound">xs</a>
          <a id="5580" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="5582" class="Symbol">(</a><a id="5583" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="5587" class="Symbol">(</a><a id="5588" class="Keyword">quote</a> <a id="5594" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1501" class="Field Operator">_*_</a><a id="5597" class="Symbol">)</a> <a id="5599" href="Tactic.RingSolver.html#5599" class="Bound">xs</a><a id="5601" class="Symbol">)</a> <a id="5603" class="Symbol">=</a> <a id="5605" href="Tactic.RingSolver.html#4154" class="Function Operator">E⟨</a> <a id="5608" class="Keyword">quote</a> <a id="5614" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a> <a id="5618" href="Tactic.RingSolver.html#4154" class="Function Operator">⟩₂</a> <a id="5621" href="Tactic.RingSolver.html#5599" class="Bound">xs</a>
          <a id="5634" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="5636" class="Symbol">(</a><a id="5637" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="5641" class="Symbol">(</a><a id="5642" class="Keyword">quote</a> <a id="5648" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2401" class="Function Operator">_^_</a><a id="5651" class="Symbol">)</a> <a id="5653" href="Tactic.RingSolver.html#5653" class="Bound">xs</a><a id="5655" class="Symbol">)</a> <a id="5657" class="Symbol">=</a> <a id="5659" href="Tactic.RingSolver.html#4548" class="Function">E⟨^⟩</a> <a id="5664" href="Tactic.RingSolver.html#5653" class="Bound">xs</a>
          <a id="5677" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="5679" class="Symbol">(</a><a id="5680" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="5684" class="Symbol">(</a><a id="5685" class="Keyword">quote</a> <a id="5691" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1543" class="Field Operator">-_</a><a id="5693" class="Symbol">)</a>  <a id="5696" href="Tactic.RingSolver.html#5696" class="Bound">xs</a><a id="5698" class="Symbol">)</a> <a id="5700" class="Symbol">=</a> <a id="5702" href="Tactic.RingSolver.html#4364" class="Function Operator">E⟨</a> <a id="5705" class="Keyword">quote</a> <a id="5711" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a> <a id="5714" href="Tactic.RingSolver.html#4364" class="Function Operator">⟩₁</a> <a id="5717" href="Tactic.RingSolver.html#5696" class="Bound">xs</a>
          <a id="5730" class="Comment">-- Recognise the underlying implementation of the ring&#39;s fields</a>
          <a id="5804" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="5806" class="Symbol">(</a><a id="5807" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="5811" href="Tactic.RingSolver.html#5811" class="Bound">nm</a>          <a id="5823" href="Tactic.RingSolver.html#5823" class="Bound">xs</a><a id="5825" class="Symbol">)</a> <a id="5827" class="Symbol">=</a> <a id="5829" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="5832" href="Tactic.RingSolver.html#1585" class="Function">+′</a> <a id="5835" href="Tactic.RingSolver.html#3671" class="Function Operator">⇓≟</a> <a id="5838" href="Tactic.RingSolver.html#5811" class="Bound">nm</a> <a id="5841" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="5846" href="Tactic.RingSolver.html#4154" class="Function Operator">E⟨</a> <a id="5849" class="Keyword">quote</a> <a id="5855" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="5859" href="Tactic.RingSolver.html#4154" class="Function Operator">⟩₂</a> <a id="5862" href="Tactic.RingSolver.html#5823" class="Bound">xs</a> <a id="5865" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                                   <a id="5905" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="5908" href="Tactic.RingSolver.html#1588" class="Function">*′</a> <a id="5911" href="Tactic.RingSolver.html#3671" class="Function Operator">⇓≟</a> <a id="5914" href="Tactic.RingSolver.html#5811" class="Bound">nm</a> <a id="5917" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="5922" href="Tactic.RingSolver.html#4154" class="Function Operator">E⟨</a> <a id="5925" class="Keyword">quote</a> <a id="5931" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a> <a id="5935" href="Tactic.RingSolver.html#4154" class="Function Operator">⟩₂</a> <a id="5938" href="Tactic.RingSolver.html#5823" class="Bound">xs</a> <a id="5941" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                                   <a id="5981" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="5984" href="Tactic.RingSolver.html#1591" class="Function">^′</a> <a id="5987" href="Tactic.RingSolver.html#3671" class="Function Operator">⇓≟</a> <a id="5990" href="Tactic.RingSolver.html#5811" class="Bound">nm</a> <a id="5993" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="5998" href="Tactic.RingSolver.html#4548" class="Function">E⟨^⟩</a> <a id="6003" href="Tactic.RingSolver.html#5823" class="Bound">xs</a> <a id="6006" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                                   <a id="6046" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="6049" href="Tactic.RingSolver.html#1594" class="Function">-′</a> <a id="6052" href="Tactic.RingSolver.html#3671" class="Function Operator">⇓≟</a> <a id="6055" href="Tactic.RingSolver.html#5811" class="Bound">nm</a> <a id="6058" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="6063" href="Tactic.RingSolver.html#4364" class="Function Operator">E⟨</a> <a id="6066" class="Keyword">quote</a> <a id="6072" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a> <a id="6075" href="Tactic.RingSolver.html#4364" class="Function Operator">⟩₁</a> <a id="6078" href="Tactic.RingSolver.html#5823" class="Bound">xs</a> <a id="6081" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                                   <a id="6121" href="Tactic.RingSolver.html#3593" class="Function">Κ′</a> <a id="6124" class="Symbol">(</a><a id="6125" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="6129" href="Tactic.RingSolver.html#5811" class="Bound">nm</a> <a id="6132" href="Tactic.RingSolver.html#5823" class="Bound">xs</a><a id="6134" class="Symbol">)</a>
          <a id="6146" class="Comment">-- Variables</a>
          <a id="6169" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="6171" href="Tactic.RingSolver.html#6171" class="Bound">v</a><a id="6172" class="Symbol">@(</a><a id="6174" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="6178" href="Tactic.RingSolver.html#6178" class="Bound">x</a> <a id="6180" class="Symbol">_)</a>          <a id="6192" class="Symbol">=</a> <a id="6194" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a> <a id="6204" class="Symbol">(</a><a id="6205" href="Tactic.RingSolver.html#3593" class="Function">Κ′</a> <a id="6208" href="Tactic.RingSolver.html#6171" class="Bound">v</a><a id="6209" class="Symbol">)</a> <a id="6211" class="Symbol">(</a><a id="6212" href="Tactic.RingSolver.html#3821" class="Bound">Ι′</a> <a id="6215" href="Tactic.RingSolver.html#6178" class="Bound">x</a><a id="6216" class="Symbol">)</a>
          <a id="6228" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
          <a id="6286" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="6288" class="Symbol">(</a><a id="6289" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="6293" class="Symbol">(</a><a id="6294" class="Keyword">quote</a> <a id="6300" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">ℕ.suc</a><a id="6305" class="Symbol">)</a> <a id="6307" class="Symbol">(</a><a id="6308" href="Tactic.RingSolver.html#6308" class="Bound">x</a> <a id="6310" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6314" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="6316" class="Symbol">))</a> <a id="6319" class="Symbol">=</a> <a id="6321" class="Keyword">quote</a> <a id="6327" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="6331" href="Tactic.RingSolver.html#3440" class="Function Operator">$ᵉ</a> <a id="6334" class="Symbol">(</a><a id="6335" href="Tactic.RingSolver.html#3593" class="Function">Κ′</a> <a id="6338" class="Symbol">(</a><a id="6339" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a> <a id="6346" class="Number">1</a><a id="6347" class="Symbol">)</a> <a id="6349" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6353" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="6355" href="Tactic.RingSolver.html#6308" class="Bound">x</a> <a id="6357" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6361" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="6363" class="Symbol">)</a>
          <a id="6375" href="Tactic.RingSolver.html#5459" class="CatchallClause Function">E</a><a id="6376" class="CatchallClause"> </a><a id="6377" href="Tactic.RingSolver.html#6377" class="CatchallClause Bound">t</a>                    <a id="6398" class="Symbol">=</a> <a id="6400" href="Tactic.RingSolver.html#3593" class="Function">Κ′</a> <a id="6403" href="Tactic.RingSolver.html#6377" class="Bound">t</a>

      <a id="6412" href="Tactic.RingSolver.html#6412" class="Function">callSolver</a> <a id="6423" class="Symbol">:</a> <a id="6425" href="Data.Vec.Base.html#959" class="Datatype">Vec</a> <a id="6429" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="6436" href="Tactic.RingSolver.html#3004" class="Bound">numVars</a> <a id="6444" class="Symbol">→</a> <a id="6446" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="6451" class="Symbol">→</a> <a id="6453" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="6458" class="Symbol">→</a> <a id="6460" href="Reflection.Argument.html#1325" class="Function">Args</a> <a id="6465" href="Agda.Builtin.Reflection.html#4317" class="Function">Type</a>
      <a id="6476" href="Tactic.RingSolver.html#6412" class="Function">callSolver</a> <a id="6487" href="Tactic.RingSolver.html#6487" class="Bound">nms</a> <a id="6491" href="Tactic.RingSolver.html#6491" class="Bound">lhs</a> <a id="6495" href="Tactic.RingSolver.html#6495" class="Bound">rhs</a> <a id="6499" class="Symbol">=</a>
          <a id="6511" class="Number">2</a> <a id="6513" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a> <a id="6518" href="Tactic.RingSolver.html#2091" class="Bound">ring</a> <a id="6523" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6527" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a> <a id="6534" href="Tactic.RingSolver.html#3004" class="Bound">numVars</a> <a id="6542" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6556" href="Tactic.RingSolver.Core.ReflectionHelp.html#1142" class="Function">vlams</a> <a id="6562" href="Tactic.RingSolver.html#6487" class="Bound">nms</a> <a id="6566" class="Symbol">(</a><a id="6567" class="Keyword">quote</a> <a id="6573" href="Tactic.RingSolver.NonReflective.html#3251" class="Function Operator">_⊜_</a>  <a id="6578" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="6581" class="Symbol">(</a><a id="6582" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a> <a id="6589" href="Tactic.RingSolver.html#3004" class="Bound">numVars</a> <a id="6597" href="Reflection.Argument.html#1449" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="6601" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="6603" href="Tactic.RingSolver.html#6491" class="Bound">lhs</a> <a id="6607" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6611" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="6613" href="Tactic.RingSolver.html#6495" class="Bound">rhs</a> <a id="6617" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6621" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="6623" class="Symbol">))</a> <a id="6626" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6640" href="Tactic.RingSolver.Core.ReflectionHelp.html#1022" class="Function">hlams</a> <a id="6646" href="Tactic.RingSolver.html#6487" class="Bound">nms</a> <a id="6650" class="Symbol">(</a><a id="6651" class="Keyword">quote</a> <a id="6657" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2479" class="Function">refl</a> <a id="6662" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="6665" class="Symbol">(</a><a id="6666" class="Number">1</a> <a id="6668" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a> <a id="6673" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="6675" class="Symbol">))</a> <a id="6678" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6692" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
        <a id="6703" class="Keyword">where</a>
        <a id="6717" href="Tactic.RingSolver.html#6717" class="Function">Ι′</a> <a id="6720" class="Symbol">:</a> <a id="6722" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="6724" class="Symbol">→</a> <a id="6726" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="6732" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
        <a id="6745" href="Tactic.RingSolver.html#6717" class="Function">Ι′</a> <a id="6748" href="Tactic.RingSolver.html#6748" class="Bound">i</a> <a id="6750" class="Symbol">=</a> <a id="6752" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="6755" href="Tactic.RingSolver.html#6748" class="Bound">i</a> <a id="6757" href="Data.Nat.Base.html#1296" class="Primitive Operator">&lt;ᵇ</a> <a id="6760" href="Tactic.RingSolver.html#3004" class="Bound">numVars</a> <a id="6768" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="6773" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="6778" class="Symbol">(</a><a id="6779" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="6783" href="Tactic.RingSolver.html#6748" class="Bound">i</a> <a id="6785" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="6787" class="Symbol">)</a> <a id="6789" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="6794" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
        <a id="6810" class="Keyword">open</a> <a id="6815" href="Tactic.RingSolver.html#3813" class="Module">ToExpr</a> <a id="6822" href="Tactic.RingSolver.html#6717" class="Function">Ι′</a>

      <a id="6832" href="Tactic.RingSolver.html#6832" class="Function">constructSoln</a> <a id="6846" class="Symbol">:</a> <a id="6848" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="6855" class="Symbol">→</a> <a id="6857" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="6862" class="Symbol">→</a> <a id="6864" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="6869" class="Symbol">→</a> <a id="6871" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
      <a id="6882" href="Tactic.RingSolver.html#6832" class="Function">constructSoln</a> <a id="6896" href="Tactic.RingSolver.html#6896" class="Bound">t</a> <a id="6898" href="Tactic.RingSolver.html#6898" class="Bound">lhs</a> <a id="6902" href="Tactic.RingSolver.html#6902" class="Bound">rhs</a> <a id="6906" class="Symbol">=</a>
          <a id="6918" class="Keyword">quote</a> <a id="6924" href="Relation.Binary.Structures.html#1620" class="Function">trans</a> <a id="6930" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="6933" class="Symbol">(</a><a id="6934" class="Number">3</a> <a id="6936" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a>
            <a id="6953" class="Keyword">quote</a> <a id="6959" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="6963" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="6966" class="Symbol">(</a><a id="6967" class="Number">2</a> <a id="6969" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a>
              <a id="6988" class="Keyword">quote</a> <a id="6994" href="Tactic.RingSolver.NonReflective.html#2224" class="Function">Ops.correct</a> <a id="7006" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="7009" class="Symbol">(</a><a id="7010" class="Number">1</a> <a id="7012" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a> <a id="7017" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="7019" href="Tactic.RingSolver.html#6898" class="Bound">lhs</a> <a id="7023" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7027" href="Tactic.RingSolver.html#7296" class="Function">ρ</a> <a id="7029" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7033" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7035" class="Symbol">)</a> <a id="7037" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7041" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7043" class="Symbol">)</a>
            <a id="7057" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
            <a id="7073" class="Symbol">(</a><a id="7074" class="Keyword">quote</a> <a id="7080" href="Tactic.RingSolver.NonReflective.html#2224" class="Function">Ops.correct</a> <a id="7092" href="Tactic.RingSolver.html#2358" class="Function Operator">$ʳ</a> <a id="7095" class="Symbol">(</a><a id="7096" class="Number">1</a> <a id="7098" href="Reflection.Term.html#2755" class="Function Operator">⋯⟅∷⟆</a> <a id="7103" href="Tactic.RingSolver.html#5459" class="Function">E</a> <a id="7105" href="Tactic.RingSolver.html#6902" class="Bound">rhs</a> <a id="7109" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7113" href="Tactic.RingSolver.html#7296" class="Function">ρ</a> <a id="7115" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7119" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7121" class="Symbol">))</a> <a id="7124" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
            <a id="7140" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7142" class="Symbol">)</a>
        <a id="7152" class="Keyword">where</a>
        <a id="7166" href="Tactic.RingSolver.html#7166" class="Function">Ι′</a> <a id="7169" class="Symbol">:</a> <a id="7171" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="7173" class="Symbol">→</a> <a id="7175" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="7181" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
        <a id="7194" href="Tactic.RingSolver.html#7166" class="Function">Ι′</a> <a id="7197" href="Tactic.RingSolver.html#7197" class="Bound">i</a> <a id="7199" class="Symbol">=</a> <a id="7201" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="7211" class="Symbol">(λ</a> <a id="7214" href="Tactic.RingSolver.html#7214" class="Bound">x</a> <a id="7216" class="Symbol">→</a> <a id="7218" class="Keyword">quote</a> <a id="7224" href="Tactic.RingSolver.Core.Expression.html#589" class="InductiveConstructor">Ι</a> <a id="7226" href="Tactic.RingSolver.html#3440" class="Function Operator">$ᵉ</a> <a id="7229" class="Symbol">(</a><a id="7230" href="Data.Nat.Reflection.html#637" class="Function">toFinTerm</a> <a id="7240" href="Tactic.RingSolver.html#7214" class="Bound">x</a> <a id="7242" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7246" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7248" class="Symbol">))</a> <a id="7251" class="Symbol">(</a><a id="7252" href="Tactic.RingSolver.Core.NatSet.html#2881" class="Function">lookup</a> <a id="7259" href="Tactic.RingSolver.html#7197" class="Bound">i</a> <a id="7261" href="Tactic.RingSolver.html#6896" class="Bound">t</a><a id="7262" class="Symbol">)</a>

        <a id="7273" class="Keyword">open</a> <a id="7278" href="Tactic.RingSolver.html#3813" class="Module">ToExpr</a> <a id="7285" href="Tactic.RingSolver.html#7166" class="Function">Ι′</a>
        <a id="7296" href="Tactic.RingSolver.html#7296" class="Function">ρ</a> <a id="7298" class="Symbol">:</a> <a id="7300" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a>
        <a id="7313" href="Tactic.RingSolver.html#7296" class="Function">ρ</a> <a id="7315" class="Symbol">=</a> <a id="7317" href="Tactic.RingSolver.Core.ReflectionHelp.html#2013" class="Function">curriedTerm</a> <a id="7329" href="Tactic.RingSolver.html#6896" class="Bound">t</a>

<a id="7332" class="Comment">------------------------------------------------------------------------</a>
<a id="7405" class="Comment">-- Macros</a>
<a id="7415" class="Comment">------------------------------------------------------------------------</a>

<a id="7489" class="Comment">-- This is the main macro which solves for equations in which the variables</a>
<a id="7565" class="Comment">-- are universally quantified over:</a>
<a id="7601" class="Comment">--</a>
<a id="7604" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="7639" class="Comment">--   lemma = solve-∀ TypeRing</a>
<a id="7669" class="Comment">--</a>
<a id="7672" class="Comment">-- where TypRing is your implementation of AlmostCommutativeRing. (Find some</a>
<a id="7749" class="Comment">-- example implementations in Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>

<a id="solve-∀-macro"></a><a id="7837" href="Tactic.RingSolver.html#7837" class="Function">solve-∀-macro</a> <a id="7851" class="Symbol">:</a> <a id="7853" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7858" class="Symbol">→</a> <a id="7860" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="7865" class="Symbol">→</a> <a id="7867" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="7870" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="7872" href="Tactic.RingSolver.html#7837" class="Function">solve-∀-macro</a> <a id="7886" href="Tactic.RingSolver.html#7886" class="Bound">ring</a> <a id="7891" href="Tactic.RingSolver.html#7891" class="Bound">hole</a> <a id="7896" class="Symbol">=</a> <a id="7898" class="Keyword">do</a>
  <a id="7903" href="Tactic.RingSolver.html#7903" class="Bound">ring′</a> <a id="7909" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7911" href="Tactic.RingSolver.html#1613" class="Function">checkIsRing</a> <a id="7923" class="Symbol">(</a><a id="7924" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="7928" href="Tactic.RingSolver.html#7886" class="Bound">ring</a> <a id="7933" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7935" class="Symbol">)</a>
  <a id="7939" href="Agda.Builtin.Reflection.html#8622" class="Postulate">commitTC</a>
  <a id="7950" class="Keyword">let</a> <a id="7954" class="Keyword">open</a> <a id="7959" href="Tactic.RingSolver.html#2081" class="Module">OverRing</a> <a id="7968" href="Tactic.RingSolver.html#7903" class="Bound">ring′</a>
  <a id="7976" href="Tactic.RingSolver.html#7976" class="Bound">operatorNames</a> <a id="7990" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7992" href="Tactic.RingSolver.html#2763" class="Function">getRingOperatorNames</a>
  <a id="8015" href="Tactic.RingSolver.html#8015" class="Bound">hole′</a> <a id="8021" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="8023" href="Agda.Builtin.Reflection.html#7776" class="Postulate">inferType</a> <a id="8033" href="Tactic.RingSolver.html#7891" class="Bound">hole</a> <a id="8038" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="8042" href="Agda.Builtin.Reflection.html#7891" class="Postulate">reduce</a>
  <a id="8051" class="Keyword">let</a> <a id="8055" href="Tactic.RingSolver.html#8055" class="Bound">variables</a> <a id="8065" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8067" href="Tactic.RingSolver.html#8067" class="Bound">k</a> <a id="8069" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8071" href="Tactic.RingSolver.html#8071" class="Bound">equation</a> <a id="8080" class="Symbol">=</a> <a id="8082" href="Tactic.RingSolver.Core.ReflectionHelp.html#1794" class="Function">underPi</a> <a id="8090" href="Tactic.RingSolver.html#8015" class="Bound">hole′</a>
  <a id="8098" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="8103" class="Symbol">(</a><a id="8104" href="Tactic.RingSolver.html#8104" class="Bound">lhs</a> <a id="8108" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="8110" href="Tactic.RingSolver.html#8110" class="Bound">rhs</a> <a id="8114" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="8116" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a><a id="8118" class="Symbol">)</a> <a id="8120" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="8122" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="8127" class="Symbol">(</a><a id="8128" href="Tactic.RingSolver.Core.ReflectionHelp.html#1412" class="Function">getArgs</a> <a id="8136" class="Number">2</a> <a id="8138" href="Tactic.RingSolver.html#8071" class="Bound">equation</a><a id="8146" class="Symbol">)</a>
    <a id="8152" class="Keyword">where</a> <a id="8158" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="8166" class="Symbol">→</a> <a id="8168" href="Agda.Builtin.Reflection.html#7713" class="Postulate">typeError</a> <a id="8178" class="Symbol">(</a><a id="8179" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="8186" class="String">&quot;Malformed call to solve.&quot;</a> <a id="8213" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="8246" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="8253" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a> <a id="8311" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="8344" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="8351" class="String">&quot;Instead: &quot;</a> <a id="8363" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="8396" href="Agda.Builtin.Reflection.html#7230" class="InductiveConstructor">termErr</a> <a id="8404" href="Tactic.RingSolver.html#8015" class="Bound">hole′</a> <a id="8410" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="8443" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8445" class="Symbol">)</a>
  <a id="8449" href="Agda.Builtin.Reflection.html#7673" class="Postulate">unify</a> <a id="8455" href="Tactic.RingSolver.html#7891" class="Bound">hole</a> <a id="8460" class="Symbol">(</a><a id="8461" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="8465" class="Symbol">(</a><a id="8466" class="Keyword">quote</a> <a id="8472" href="Tactic.RingSolver.html#1142" class="Function">solve-fn</a><a id="8480" class="Symbol">)</a> <a id="8482" class="Symbol">(</a><a id="8483" href="Tactic.RingSolver.html#6412" class="Function">callSolver</a> <a id="8494" href="Tactic.RingSolver.html#7976" class="Bound">operatorNames</a> <a id="8508" href="Tactic.RingSolver.html#8055" class="Bound">variables</a> <a id="8518" href="Tactic.RingSolver.html#8067" class="Bound">k</a> <a id="8520" href="Tactic.RingSolver.html#8104" class="Bound">lhs</a> <a id="8524" href="Tactic.RingSolver.html#8110" class="Bound">rhs</a><a id="8527" class="Symbol">))</a>

<a id="8531" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="8539" href="Tactic.RingSolver.html#8539" class="Function">solve-∀</a> <a id="8547" class="Symbol">:</a> <a id="8549" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="8554" class="Symbol">→</a> <a id="8556" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="8561" class="Symbol">→</a> <a id="8563" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="8566" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="8570" href="Tactic.RingSolver.html#8539" class="Function">solve-∀</a> <a id="8578" class="Symbol">=</a> <a id="8580" href="Tactic.RingSolver.html#7837" class="Function">solve-∀-macro</a>

<a id="8595" class="Comment">-- Use this macro when you want to solve something *under* a lambda. For example:</a>
<a id="8677" class="Comment">-- say you have a long proof, and you just want the solver to deal with an</a>
<a id="8752" class="Comment">-- intermediate step. Call it like so:</a>
<a id="8791" class="Comment">--</a>
<a id="8794" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="8846" class="Comment">--   lemma₃ x y = begin</a>
<a id="8870" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="8929" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="8983" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="9014" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="9037" class="Comment">--</a>
<a id="9040" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="9107" class="Comment">-- ring implementation (as before).</a>
<a id="9143" class="Comment">--</a>
<a id="9146" class="Comment">-- One thing to note here is that we need to be able to infer *both* sides of</a>
<a id="9224" class="Comment">-- the equality, which the normal equaltional reasoning combinators don&#39;t let you</a>
<a id="9306" class="Comment">-- do. You&#39;ll need the combinators defined in Relation.Binary.Reasoning.Inference.</a>
<a id="9389" class="Comment">-- These are just as powerful as the others, but have slightly better inference properties.</a>

<a id="solve-macro"></a><a id="9482" href="Tactic.RingSolver.html#9482" class="Function">solve-macro</a> <a id="9494" class="Symbol">:</a> <a id="9496" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="9501" class="Symbol">→</a> <a id="9503" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="9508" class="Symbol">→</a> <a id="9510" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="9515" class="Symbol">→</a> <a id="9517" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="9520" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="9522" href="Tactic.RingSolver.html#9482" class="Function">solve-macro</a> <a id="9534" href="Tactic.RingSolver.html#9534" class="Bound">i</a> <a id="9536" href="Tactic.RingSolver.html#9536" class="Bound">ring</a> <a id="9541" href="Tactic.RingSolver.html#9541" class="Bound">hole</a> <a id="9546" class="Symbol">=</a> <a id="9548" class="Keyword">do</a>
  <a id="9553" href="Tactic.RingSolver.html#9553" class="Bound">ring′</a> <a id="9559" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9561" href="Tactic.RingSolver.html#1613" class="Function">checkIsRing</a> <a id="9573" class="Symbol">(</a><a id="9574" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="9578" href="Tactic.RingSolver.html#9536" class="Bound">ring</a> <a id="9583" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="9585" class="Symbol">)</a>
  <a id="9589" href="Agda.Builtin.Reflection.html#8622" class="Postulate">commitTC</a>
  <a id="9600" class="Keyword">let</a> <a id="9604" class="Keyword">open</a> <a id="9609" href="Tactic.RingSolver.html#2081" class="Module">OverRing</a> <a id="9618" href="Tactic.RingSolver.html#9553" class="Bound">ring′</a>
  <a id="9626" href="Tactic.RingSolver.html#9626" class="Bound">operatorNames</a> <a id="9640" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9642" href="Tactic.RingSolver.html#2763" class="Function">getRingOperatorNames</a>
  <a id="9665" href="Tactic.RingSolver.html#9665" class="Bound">listOfVariables′</a> <a id="9682" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9684" href="Tactic.RingSolver.html#2441" class="Function">checkIsListOfVariables</a> <a id="9707" href="Tactic.RingSolver.html#9534" class="Bound">i</a>
  <a id="9711" href="Agda.Builtin.Reflection.html#8622" class="Postulate">commitTC</a>
  <a id="9722" href="Tactic.RingSolver.html#9722" class="Bound">hole′</a> <a id="9728" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9730" href="Agda.Builtin.Reflection.html#7776" class="Postulate">inferType</a> <a id="9740" href="Tactic.RingSolver.html#9541" class="Bound">hole</a> <a id="9745" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="9749" href="Agda.Builtin.Reflection.html#7891" class="Postulate">reduce</a>
  <a id="9758" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="9763" href="Tactic.RingSolver.html#9763" class="Bound">vars′</a> <a id="9769" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9771" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="9776" class="Symbol">(</a><a id="9777" href="Tactic.RingSolver.html#1729" class="Function">getVariableIDs</a> <a id="9792" href="Tactic.RingSolver.html#9665" class="Bound">listOfVariables′</a><a id="9808" class="Symbol">)</a>
    <a id="9814" class="Keyword">where</a> <a id="9820" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="9828" class="Symbol">→</a> <a id="9830" href="Agda.Builtin.Reflection.html#7713" class="Postulate">typeError</a> <a id="9840" class="Symbol">(</a><a id="9841" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="9848" class="String">&quot;Malformed call to solve.&quot;</a> <a id="9875" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="9908" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="9915" class="String">&quot;First argument should be a list of free variables.&quot;</a> <a id="9968" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="10001" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="10008" class="String">&quot;Instead: &quot;</a> <a id="10020" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="10053" href="Agda.Builtin.Reflection.html#7230" class="InductiveConstructor">termErr</a> <a id="10061" href="Tactic.RingSolver.html#9665" class="Bound">listOfVariables′</a> <a id="10078" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="10111" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="10113" class="Symbol">)</a>
  <a id="10117" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="10122" class="Symbol">(</a><a id="10123" href="Tactic.RingSolver.html#10123" class="Bound">lhs</a> <a id="10127" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="10129" href="Tactic.RingSolver.html#10129" class="Bound">rhs</a> <a id="10133" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="10135" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a><a id="10137" class="Symbol">)</a> <a id="10139" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10141" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="10146" class="Symbol">(</a><a id="10147" href="Tactic.RingSolver.Core.ReflectionHelp.html#1412" class="Function">getArgs</a> <a id="10155" class="Number">2</a> <a id="10157" href="Tactic.RingSolver.html#9722" class="Bound">hole′</a><a id="10162" class="Symbol">)</a>
    <a id="10168" class="Keyword">where</a> <a id="10174" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="10182" class="Symbol">→</a> <a id="10184" href="Agda.Builtin.Reflection.html#7713" class="Postulate">typeError</a> <a id="10194" class="Symbol">(</a><a id="10195" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="10202" class="String">&quot;Malformed call to solve.&quot;</a> <a id="10229" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="10262" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="10269" class="String">&quot;First argument should be a list of free variables.&quot;</a> <a id="10322" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="10355" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">strErr</a> <a id="10362" class="String">&quot;Instead: &quot;</a> <a id="10374" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="10407" href="Agda.Builtin.Reflection.html#7230" class="InductiveConstructor">termErr</a> <a id="10415" href="Tactic.RingSolver.html#9722" class="Bound">hole′</a> <a id="10421" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a>
                               <a id="10454" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="10456" class="Symbol">)</a>
  <a id="10460" href="Agda.Builtin.Reflection.html#7673" class="Postulate">unify</a> <a id="10466" href="Tactic.RingSolver.html#9541" class="Bound">hole</a> <a id="10471" class="Symbol">(</a><a id="10472" href="Tactic.RingSolver.html#6832" class="Function">constructSoln</a> <a id="10486" href="Tactic.RingSolver.html#9626" class="Bound">operatorNames</a> <a id="10500" class="Symbol">(</a><a id="10501" href="Data.List.Base.html#4577" class="Function">List.length</a> <a id="10513" href="Tactic.RingSolver.html#9763" class="Bound">vars′</a><a id="10518" class="Symbol">)</a> <a id="10520" href="Tactic.RingSolver.html#9763" class="Bound">vars′</a> <a id="10526" href="Tactic.RingSolver.html#10123" class="Bound">lhs</a> <a id="10530" href="Tactic.RingSolver.html#10129" class="Bound">rhs</a><a id="10533" class="Symbol">)</a>

<a id="10536" class="Keyword">macro</a>
  <a id="solve"></a><a id="10544" href="Tactic.RingSolver.html#10544" class="Function">solve</a> <a id="10550" class="Symbol">:</a> <a id="10552" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="10557" class="Symbol">→</a> <a id="10559" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="10564" class="Symbol">→</a> <a id="10566" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="10571" class="Symbol">→</a> <a id="10573" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="10576" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="10580" href="Tactic.RingSolver.html#10544" class="Function">solve</a> <a id="10586" class="Symbol">=</a> <a id="10588" href="Tactic.RingSolver.html#9482" class="Function">solve-macro</a>
</pre></body></html>